/*
 Navicat Premium Data Transfer

 Source Server         : cloudcone
 Source Server Type    : MySQL
 Source Server Version : 80031
 Source Host           : 198.211.27.20:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80031
 File Encoding         : 65001

 Date: 23/03/2023 02:25:35
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for tb_article
-- ----------------------------
DROP TABLE IF EXISTS `tb_article`;
CREATE TABLE `tb_article`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NOT NULL COMMENT '作者',
  `category_id` int NULL DEFAULT NULL COMMENT '文章分类',
  `article_cover` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文章缩略图',
  `article_title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '标题',
  `article_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '内容',
  `type` tinyint(1) NOT NULL DEFAULT 0 COMMENT '文章类型 1原创 2转载 3翻译',
  `original_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '原文链接',
  `is_top` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否置顶 0否 1是',
  `is_delete` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否删除  0否 1是',
  `status` tinyint(1) NOT NULL DEFAULT 1 COMMENT '状态值 1公开 2私密 3评论可见',
  `create_time` datetime NOT NULL COMMENT '发表时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 76 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_article
-- ----------------------------
INSERT INTO `tb_article` VALUES (57, 1, 188, 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/a5fad6cb39146011cd1ca3adf10d0ad9.jpg', 'Windows配置多个GitHub仓库', '# 1. 删除全局配置\n\n```cmd\ngit config --global --unset user.name   \ngit config --global --unset user.email   \n```\n# 2. 分别配置仓库\n```cmd\ncd 仓库地址1\ngit config user.name \"xxx\"\ngit config user.email \"xxx@xxx.com\"  \n```\n```cmd\ncd 仓库地址2\ngit config user.name \"xxx\"\ngit config user.email \"xxx@xxx.com\"   \n```\n```git\n......\n```\n\n# 3. 创建公钥\n```cmd\ncd ~/.ssh\nssh-keygen -t rsa -C \"111@xxx.com\" id_rsa_111 \nssh-keygen -t rsa -C \"222@xxx.com\" id_rsa_222   \n//将.pub文件内容添加到GitHub或gitee的ssh管理库中\n```\n* -C 表示提供一个注释，也就是后面的 *\"邮件地址@youremail.com\"* ，可以省略。双引号里为注释的内容，所以不一定得填邮箱，可以输入任何内容，只要你自己知道这个密钥对应哪个网站的仓库就行了。\n* 然后将.pub文件内容添加到GitHub或gitee的ssh管理库中\n\n# 4. 配置config文件\n```cmd\ncd ~/.ssh\n```\n新建文件config  \n输入\n```vim\n# gitee\nHost gitee.com\nHostName gitee.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/id_rsa_gitee\n# github\nHost 111.github.com\nHostName github.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/id_rsa_111\n# github\nHost 222.github.com\nHostName github.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/id_rsa_222\n```\n![config](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/config.png)\n**原因：**  \n\n1. ssh 客户端是通过类似`git@github.com:githubUserName/repName.git`的地址来识别使用本地的哪个私钥的，地址中的 `git@github.com` 其实就是`git@(config文件中的Host值)`。\n2. 如果所有账号的 `Host` 值都为 `github.com`，那么就只能使用一个私钥。所以要对 `Host` 进行配置，至少让每个账号使用自己的 `Host`，每个 `Host` 的域名做 `CNAME` 解析到 `github.com`，如上面配置中的`111.github.com`和`222.github.com`。\n3. 配置了别名之后，新的地址就是`git@111.github.com:githubUserName/repName.git`（在添加远程仓库时使用）。   \n\n这样 ssh 在连接时就可以区别不同的账号了。\n\n```cmd\nssh -T git@111.github.com\nssh -T git@222.github.com\n//测试ssh连接，返回“Hi xxx ...”则成功\n```\n![Hixxx](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/Hixxx.png)\n\n# 5. 查看远程分支\n\n```cmd\ngit remote -v     \n```\n# 6. 添加远程仓库\n```cmd\ncd 仓库1地址\ngit remote add origin git@111.github.com:githubUserName/repName.git\n\ncd 仓库2地址\ngit remote add origin git@222.github.com:githubUserName/repName.git\n```\n\n如下图，若是出现这种错误：\n\n![origin错误](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/origin%E9%94%99%E8%AF%AF.jpg)\n则表示远程 origin 已经存在，只需要将远程配置删除，再输入上述命令重新添加即可\n\n```cmd\ngit remote rm origin\ngit remote add origin......\n```', 1, '', 0, 0, 1, '2022-04-29 22:45:47', '2022-06-01 00:42:44');
INSERT INTO `tb_article` VALUES (58, 1, 188, 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/f336b8346cbf291881756a38b4aba123.jpg', 'icarus主题+gitalk评论插件的配置', '总体分为三步，相比较其他主题需要一些繁琐的配置，icarus就简单很多\n\n<!--more-->\n\n\n## 1. 登陆GitHub并[点此注册](https://github.com/settings/applications/new)一个新的OAuth应用\n\n   ![注册OAute](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/%E6%B3%A8%E5%86%8COAute.png)\n   随后记录下Client ID与Client Secre，等下要用\n\n   > Client ID\n   > xxxxxxxxxxxxxxxxxxxx\n   > Client Secret\n   > xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n\n<br />\n\n## 2. [进入此网页](https://github.com/gitalk/gitalk)往下拉，有这样一句命令，在博客根目录执行：\n\n   > npm i --save gitalk #安装gitalk插件\n\n<br />\n\n## 3. 打开根目录下的_config.icarus.yml文件，添加配置\n   \n   >   comment：\n   >   type: gitalk\n   >   owner: lxiuaunng   #你的GitHub用户名\n   >   repo: lxiuaunng.github.io   #你的博客地址\n   >   client_id: 0b26fddaf37d93589745\n   >   client_secret: 1c15538585140bf3ef0b9f5dd2c01569055cf8ba\n   >   admin: lxiuaunng   #同样是你的GitHub用户名\n\n<br />\n## 4. 在博客根目录下打开git bush，先hexo clean，再hexo s->g->d\n基本上就是这样了\n\n![样图](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/%E6%A0%B7%E5%9B%BE.png)\n', 1, '', 0, 0, 1, '2022-04-30 04:15:26', '2022-06-01 00:43:27');
INSERT INTO `tb_article` VALUES (59, 1, 188, 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/1ce48e5ebd61b7fae155b02a92ca278d.jpg', '图床', '# 1. 图床是什么？\n\n图床是指存放图片的服务器，一般要求有公网ip，能够在浏览器中访问。\n\n图床也分为免费和付费，绝大多数免费图床如：[七牛云 ](https://www.qiniu.com/)、[路过图床](https://imgtu.com/)、[聚合图床](https://www.superbed.cn/)、[Loukky免费公益图床](http://imgur.loukky.com/)、[SM.MS](https://sm.ms/)等，相对于对图片存储要求不高的人完全够用，但或多或少都有些空间或者速度上的限制，况且把图片放在别人的服务器万一跑路就很尴尬了，因此云存储便是一个方便而又稳定的选择\n\n# 2. 腾讯云存储\n\n* 腾讯云是一款比较便宜的对象存储产品，对于个人而言不贵，而且还新人半年的试用期\n* PicGo是方便图片上传和将存储后的图片转化为markdown链接的软件，有了它图片上传变得非常简单\n* 云存储并非只可以存储图片，而是可以存储任何文件\n\n1. 打开[腾讯云](https://cloud.tencent.com/)，在此处购买，如果是新人请跳过此处前往2\n\n![image-20220430033309452](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033309452.png)\n\n2. 领取半年的免费额度资源包\n\n![image-20220430033746881](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033746881.png)\n\n![image-20220430033844406](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033844406.png)\n\n![image-20220430033941899](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033941899.png)\n\n![image-20220430034028895](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034028895.png)\n\n3. 创建存储桶\n\n![image-20220430034210728](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034210728.png)\n\n![image-20220430034521279](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034521279.png)\n\n![image-20220430034714595](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034714595.png)\n\n![image-20220430034739901](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034739901.png)\n\n\n\n\n\n# 3. PicGo图床管理软件\n\n[PicGo (molunerfinn.com)](https://molunerfinn.com/PicGo/)\n\n![image-20220430040244537](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430040244537.png)\n\n![image-20220430035809218](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430035809218.png)\n\n1. 前三个\n\n![image-20220430035951372](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430035951372.png)\n\n2. 后两个\n\n   ![image-20220430040132579](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430040132579.png)\n\n', 1, '', 0, 0, 1, '2022-04-30 04:21:17', '2022-06-14 14:35:08');
INSERT INTO `tb_article` VALUES (60, 1, 189, 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/500759f158a03e9b10d359c1e939aab4.png', '公告记录', '2022/6/14 此项目登录功能已完美上线，欢迎各位来访！\n\n2022/6/13 此项目完善程度基本上已达95%，微博登录功能已申请通过，QQ互联还需要一段时间。', 1, '', 0, 0, 2, '2022-06-14 14:30:55', '2022-06-14 14:39:17');
INSERT INTO `tb_article` VALUES (63, 1, 188, 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg', '算法设计基础', '\n# 算法设计基础\n\n## 1. 算法的基本概念\n\n1. 算法的含义：\n\n   算法是为了解决某一问题而采用的方法与步骤\n\n2. 算法的5个特征：\n\n   确定性、可行性、有限性、输入性、输出型\n\n3. 算法的设计目标：\n\n   正确性、可使用性、可读性、健壮性、高效率与低存储量\n   \n4. 算法的分析：\n\n   * 时间复杂度：\n\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，n 表示问题的规模\n\n     1. *O(1)*：没有循环，每个语句只执行一遍\n\n     2. *O(n)*：一层循环，循环n次，循环里面的语句执行n次\n\n     3. *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\n\n     ```c++\n     int i = 0;\n     int sum = 0;\n     while {\n       sum = sum + i; /*执行log (2)n次*/\n       i = i * 2;     /*执行log (2)n次*/\n     }\n     ```\n\n     4. *O(n<sup>2</sup>)*：双重循环，*n\\*n* 或者*n\\*m*\n\n     ```c++\n     int sum = 0;\n     for (int i = 0; i < n; i ++){\n       for (int j = 0; j < m; i ++){\n         sum = sum + i * j;      /*执行n*m次*/\n       }\n     }\n     ```\n\n     5. *O(2<sup>n</sup>)*：斐波那契数列的递归算法\n\n     6. *O(n!)*：旅行商问题\n\n**上述算法中，*O(2<sup>n</sup>)* 和 *O(n!)* 是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法**\n     \n\n## 2. 蛮力法\n\n1. 基本思想：\n\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\n\n2. 蛮力法的要点：\n\n   循环、选择\n\n3. 蛮力法的应用：\n\n   * 顺序查找(*O(n)*)：从 1 查到 n\n\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\n\n     ```c++\n     for (int i = 0; i < n - 1; i ++){\n       for (int j = 0; j = n - i - 1; j++){\n         if (a[j] > a[j+1]){\n           temp = a[j];\n           a[j] = a[j+1];\n           a[j+1] = a[j];\n         }\n       }\n     }\n     ```\n\n   * 直接选择排序*O(n<sup>2</sup>)*：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\n\n     ```c++\n     int i,j,min;\n     int temp;\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\n       min = i;   //用min记录无序区中最小元素的位置\n       for(j = i + 1; j < n; j++){\n         if (a[j] < a[min])\n     		min=j;\n       }\n     	if (min! = i){ //若a[i]不是最小元素\n     	 	temp=a[i];//将a[min]与a[i]交换\n       	a[i]=a[min];\n       	a[min]=temp;\n     	}\n     }\n     ```\n\n   * 直接插入排序*O(n<sup>2</sup>)*：分为有序区和无序区，每一趟排序都将无序区中的第一个元素插入有序区中（插入过程蛮力法），让插入的元素和有序区的最后一个元素比较。\n\n     ```c++\n     int i, j;\n     int t;\n     for (i = 0; i < n - 1; i++){\n       t = a[i+1];\n       j = i;\n       while (t < a[j] && j >= 0){\n         a[j+1] = a[j];\n         j--;\n       }\n       a[j+1] = t;\n     }\n     ```\n\n## 2. 分治法\n\n1. 基本思想：\n\n   把一个复杂的问题分解成多个相同或相似的子问题，然后直接或间接地调用自己\n\n2. 递归实施步骤：\n\n   1. 根据实际构建递归关系（递归式）\n   2. 确定递归边界（递归出口）\n   3. 编写递归函数\n   4. 设计主函数调用递归函数\n\n3. 汉诺塔的时间复杂度分析：\n\n   设盘子个数为 *n* 时，需要 *T(n)* 步，把 *A* 柱子 *n-1* 个盘子移到 *B* 柱子，需要 *T(n-1)* 步， *A* 柱子最后一个盘子移到 *C* 柱子一步，*B* 柱子上 *n-1* 个盘子移到 *C* 柱子上 *T(n-1)* 步。得递推公式 *T(n) = 2T(n-1) + 1*\n   所以汉诺塔问题的时间复杂度为 *O(2<sup>n</sup>)*\n\n## 3. 贪心法\n\n1. 基本思想：\n\n   把复杂问题分解成若干个简单问题，每一步都做出在当前看最好的选择（局部最优）\n\n2. 算法应用：\n\n   哈夫曼树是带权路径最小的二叉树\n\n3. 最近顶点策略 Prim 算法：\n\n4. 最短边策略 Kruskal 算法：\n\n## 4. 动态规划算法\n\n1. 基本思想：\n\n   将待求解的问题按阶段分解成若干个子问题，其中各个子问题的解都是当前状态下所得的最优解（全局最优）\n\n2. 算法工具：\n\n   最优决策表：行代表问题的阶段，列代表问题的状态\n\n3. 最长公共子序列：\n\n   > 求序列 {34,52,18,6,76,322,145,57} 和 {2,18,54,6,78,145,57,9} 的最长公共子序列\n   >\n   > |      | 34   | 52   | 18                               | 6                                | 76   | 322  | 145                              | 57                               |\n   > | :--- | :--- | ---- | -------------------------------- | -------------------------------- | ---- | ---- | -------------------------------- | -------------------------------- |\n   > | 2    | 0    | 0    | 0                                | 0                                | 0    | 0    | 0                                | 0                                |\n   > | 18   | 0    | 0    | ==<font color = \"red\">1</font>== | 1                                | 1    | 1    | 1                                | 1                                |\n   > | 54   | 0    | 0    | 1                                | 1                                | 1    | 1    | 1                                | 1                                |\n   > | 6    | 0    | 0    | 1                                | ==<font color = \"red\">2</font>== | 2    | 2    | 2                                | 2                                |\n   > | 78   | 0    | 0    | 1                                | 2                                | 2    | 2    | 2                                | 2                                |\n   > | 145  | 0    | 0    | 1                                | 2                                | 2    | 2    | ==<font color = \"red\">3</font>== | 3                                |\n   > | 57   | 0    | 0    | 1                                | 2                                | 2    | 2    | 3                                | ==<font color = \"red\">4</font>== |\n   > | 9    | 0    | 0    | 1                                | 2                                | 2    | 2    | 3                                | 4                                |\n   >\n   > 最长公共子序列：{18，6，145，5}\n\n4. 排队购票：\n\n## 5. 回溯法\n\n\n\n## 6. 分支限界法\n\n1. 分支限界法和回溯法的区别：\n\n   回溯法一深度优先策略搜索解空间树，分支限界法则以广度优先策略搜索解空间树\n\n ', 1, '', 0, 0, 1, '2022-06-22 01:58:54', '2022-06-24 02:05:08');
INSERT INTO `tb_article` VALUES (67, 1, 188, 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg', '设计模式', '# <center>设计模式</center>\n\n## 1 设计模式基础\n\n### 1. 设计模式的优点\n\n   1. 可以提高程序员的思维能力、编程能力和设计能力\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\n\n### 2. 设计模式分为哪几类\n\n   1. 根据目的来分：\n\n      创建型模式：以灵活的方式创建对象集合，用于管理对象的创建。包含：单例、原型、工厂方法、抽象工程、<font color=\"#e1e9ee\">~~建造者~~</font>\n\n      结构型模式：将已有的代码集成到新的面向对象中，用于处理类或对象的组合。包含：代理、外观、<font color=\"#e1e9ee\">~~适配器、桥接、装饰、享元、组合~~</font>\n\n      行为型模式：用于描述对类或对象怎样交互和怎样分配职责。包含：模板方法、策略、<font color=\"#e1e9ee\">~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、</font>\n\n   2. 根据作用范围来分：\n\n      类模式：工厂方法、模板方法、<font color=\"#e1e9ee\">~~适配器、解释器~~</font>\n\n      对象模式：（除了以上四种都是）\n\n### 3. 类之间的关系\n\n   1. 耦合度从弱到强：\n\n      依赖关系（- - - >）：耦合度最低的一种关联方式，是临时性的关联\n\n      关联关系（—）：是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的关系\n\n      聚合关系（—◇）：强关联关系，是整体和部分之间的关系\n\n      组合关系（—◆）：关联关系的一种，是整体与部分之间更强烈的聚合的关系\n\n      泛化关系（—▷）：耦合度最大的的一种关系，表示父类和子类之间的继承关系\n\n      实现关系（- - - ▷）：是接口和实现类之间的关系，类中要实现接口中的所有抽象方法\n\n### 4. 单选题：\n\n   1. 以下对开闭原则的描述错误的是（A）\n\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\n\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\n\n      - [ ] C. 对修改关闭，是其原则之一\n\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\n\n### 5. 多选题\n\n   1. 以下是模式的基本要素（ABCD）\n\n      - [x] 名称\n\n      - [x] 意图\n\n      - [x] 解决方案\n\n      - [x] 参与者和协作者\n\n        \n\n   2. 面向对象系统中功能复用的最常用技术（AB）\n\n      - [x] 类继承\n\n      - [x] 对象组合\n\n      - [ ] 使用抽象类\n\n      - [ ] 使用实现类\n\n### 6. 设计模式的两大主题：\n\n   系统复用、系统扩展\n\n### 7. 七大原则\n\n   1. 开闭原则：\n\n      软件实体应当对扩展开放，对修改关闭。（对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性\n\n   2. 里氏替换原则：\n\n      继承必须确保父类拥有的性质在子类中仍然成立\n\n   3. 依赖倒置原则：\n\n      高层模块不应该依赖底层模块，两者都应该依赖其抽象\n\n   4. 单一职责原则：\n\n      一个类应该有且仅有一个引起它变化的原因\n\n   5. 接口隔离原则：\n\n      一个类对另一个类的依赖应该建立在最小的接口上\n\n   6. 迪米特法则：\n\n      又叫最少知识原则，如果两个软件实体无需直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用\n\n   7. 合成复用原则：\n\n      又叫组合/聚合原则，尽量使用合成或聚合等关系来实现，其次才考虑继承关系实现\n\n## 2 创建型模式\n\n### 1. 单例模式\n\n   1. 定义：\n\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\n\n   2. 主要角色：\n\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\n      2. 访问类：使用单例的类\n\n   3. 两种实现形式：\n\n      懒汉式单例、饿汉式单例\n\n   4. 应用场景：\n\n      1. 某类只要求生成一个对象的时候，如总统、班长、太阳等\n      2. 当对象需要被共享的场合，由于单例模式只允许创建一个对象，共享该对象可以节省资源\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\n\n### 2. 工厂方法\n\n   1. 主要角色：\n\n      1. 抽象工厂\n      2. 具体工厂\n      3. 抽象产品\n      4. 具体产品\n      \n   1. 工厂方法和简单工厂的区别\n\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\n\n### 3. 抽象工厂模式\n\n   1. 主要角色：\n\n      （与工厂方法一致）\n\n   2. 产品族、产品等级\n\n      产品族：将同一个具体工厂所产生的位于不同等级的一组产品称为一个产品族\n\n      产品等级：同一种产品称为一个产品等级\n\n   3. 工厂方法和抽象工厂方法区别\n\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式可以用来创建不同类的各个产品（不同品牌的空调、冰箱、洗衣机等产品）\n\n### 4. 单选题：\n\n   1. 以下关于创建型模式说法正确的是（A）\n\n      - [x] 创建型模式关注的是对象的创建\n\n      - [ ] 创建型模式关注的是功能的实现\n\n      - [ ] 创建型模式关注的是组织类和对象常用方法\n\n      - [ ] 创建型模式关注的是对象间的协作\n\n        \n\n   2. 在（C）适合使用单例模式\n\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\n\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\n\n      - [x] 当这个唯一实力应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时\n\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\n\n### 5. 多选题：\n\n   1. 下面属于原型模式的优点是（ABCD）\n      - [x] 运行时刻增加和删除产品\n      \n      - [x] 改变值以指定新对象\n      \n      - [x] 减少子类的构造\n      \n      - [x] 用类动态配置应用\n      \n        \n      \n   2. 以下属于单例模式的优点是（ABCD）\n      - [x] 对唯一实例的受控访问\n      \n      - [x] 允许对操作和表示的精化\n      \n      - [x] 允许可变数目的实例\n      \n      - [x] 比类操作更灵活\n      \n        \n      \n   3. 当应用工厂方法模式时需要考虑（ABCD）\n      - [x] 主要有两种不同的情况\n      \n      - [x] 参数化工厂方法\n\n      - [x] 特定语言的变化和问题\n\n      - [x] 使用模板以避免创建子类\n\n## 3 结构型模式\n\n### 1. 代理模式\n\n   1. 主要角色：\n\n      1. 抽象主题类\n      2. 真实主题类\n      3. 代理类\n\n   1. 结构图：\n\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\n\n   1. （明星）例子：\n\n      结构图：\n\n      ![明星代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/笔记/设计模式/图片1-f10.png)\n\n      代码：\n\n      ```java\n      package porxy;\n      \n      public interface Star {\n        void confer();                 //面谈\n        void signContrack();           //签合同\n        void bookTicket();             //订票\n        void sing();                  //唱歌\n        void collectmoney();            //收钱\n      }\n      \n      public class RealStar implements Star{\n      	 public void confer(){               //面谈\n      	    System.out.println(\"RealStar.confer()\");\n      	 }\n      	  public void signContrack(){           //签合同\n      		  System.out.println(\"RealStar.signContrack()\");  \n      	  }\n      	  public void bookTicket(){           //订票\n      		  System.out.println(\"RealStar.bookTicket()\");  \n      	  }\n      	  public void sing(){                  //唱歌\n      		  System.out.println(\"RealStar(周杰伦本人).sing()\");  \n      	  }\n      	  public void collectmoney(){            //收钱\n      		  System.out.println(\"RealStar.collectmoney()\");  \n      	  }\n      }\n      \n      public class porxyStar implements Star {\n         private Star star;\n         public porxyStar(Star star){\n      	   super();\n      	   this.star = star;\n           }\n         public void confer() {\n      	  System.out.println(\"porxyStar.confer()\");		\n      	}\n         public void signContrack() {\n      		 System.out.println(\"porxyStar.signContrack()\");	\n      	}\n      	public void bookTicket() {\n      		System.out.println(\"porxyStar.bookTicket()\");\n      	}\n      	public void sing() {\n      		 star.sing();\n      	}\n      	public void collectmoney() {\n      		 System.out.println(\"porxyStar.collectmoney()\");\n      	}\n      }\n      \n      public class client {\n      	public static void main(String[] args) {	\n      	Star real = new RealStar();\n      	Star porxy = new porxyStar(real);	\n              porxy.confer();\n              porxy.signContrack();\n              porxy.bookTicket();\n              porxy.sing();\n              porxy.collectmoney();\n      	}\n      }\n      ```\n\n      \n\n### 2. 外观模式\n\n   1. 主要角色：\n\n      1. 外观角色\n      2. 子系统角色\n      3. 客户角色\n\n   1. 结构图：\n\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\n\n   1. （注册公司）例子：\n\n      结构图：\n\n      ![注册公司外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/笔记/设计模式/外观模式2-015.png)\n\n      代码：\n\n      ```java\n      package chapter05.facade;         //外观角色\n      \n      public class  Client{\n      	public static void main(String[] args) {\n      \n      	new RegisterFacade().register();\n      \n      	}\n      }\n      \n      public class RegisterFacade  {\n          public void register(){\n            工商总局 a = new 工商局();\n            a.checkName();\n      	    税务总局 b = new 税务局();\n            b.texCertificate();\n            质监总局 c = new 质监局();\n            c.orgCodeCertificate();\n            银行 d = new 工商银行()\n            d.openAccount();\n         }			\n      }\n      \n      public interface 工商总局{\n         void checkName();\n      }\n      class 工商局 implements 工商总局  {\n      	System.out.println(“检查名字是否冲突！”);		\n      }\n      public interface 税务总局{\n         void texCertificate();   //办理税务登记证\n      }\n      class 税务局 implements 税务总局  {\n      	System.out.println(“在税务局办理税务登记证！”);		\n      }\n      public interface 银行{\n         void openAccount();   //开户\n      }\n      class 工商银行 implements 银行  {\n      	System.out.println(“在中国工商银行开户！”);			\n      }\n      public interface 质监总局{\n         void orgCodeCertificate();   //办理组织结构代码证\n      }\n      class 质监局 implements 质监总局  {\n      	System.out.println(“在质监总局办理组织结构代码证！”);		\n      }\n      ```\n\n      \n\n### 3. 单选题：\n\n   1. 以下意图用来描述代理（Proxy）的是（C）\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\n      \n      - [ ] 运用共享技术有效地支持大量细粒度的对象\n      \n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\n      \n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\n      \n        \n      \n   2. 以下情况不适合使用代理模式的是（A）\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\n      \n      - [ ] 根据需要创建开销很大的对象\n      \n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\n      \n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\n      \n        \n      \n   3. 以下意图可以用来描述外观（A）\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\n      \n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\n      \n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\n      \n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\n\n## 4 行为型模式\n\n### 1. 模板方法\n\n   1. 定义：\n\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\n\n   2. 主要角色：\n\n      1. 抽象类\n      2. 具体子类\n\n   3. 应用场景：\n\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。\n\n### 2. 策略模式\n\n   1. 定义：\n\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。<font color=\"#e1e9ee\">~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~</font>（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\n\n   2. 主要角色：\n\n      1. 抽象策略类\n      2. 具体策略类\n      3. 环境类\n   \n   3. 应用场景：\n   \n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\n      \n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\n      \n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\n      \n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。\n         \n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\n\n### 3. 单选题：\n\n   1. 以下意图（D）可用来描述策略\n      \n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\n      \n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\n      \n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\n      \n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\n      \n   2. 以下（A）不适合使用策略模式\n      \n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\n      \n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\n      \n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\n      \n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\n', 1, '', 0, 0, 1, '2022-06-24 01:57:31', '2022-06-30 22:08:07');
INSERT INTO `tb_article` VALUES (72, 1, 190, 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png', '紫罗兰永恒花园', '<font color=red>温馨提示：该文章写于三年前，makrdown、html、css 和 js都还不熟悉，因此文章和格式写的很烂很烂，请抱着死亡的心态阅读下去吧！</font>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\"></iframe>\n\n## <center>简介</center>\n\n薇尔莉特是这部剧的女主，是一名在战场上失去双臂，为寻求什么是爱而加入了自动手记人偶这一职业并逐渐成长的故事\n\n什么是自动手记人偶呢？在过去，尤其是战争时期，大多数人都未能接受良好的教育，以至于不会写字和识字，因此想要写信时，就需要代写的人帮忙写信，后来逐渐演变成为一种职业，在该剧中被称之为——自动手记人偶。【既然有职业代写人，自然有职业读信人，所以别产生 “寄了信对方看不懂，那怎么办” 的想法了】\n\n一种职业的产生和发展必定和“内卷”离不开关系，一开始代写的人只是重述着写信人的话语，但是大多数人来写信都因其抱有着思念之情无处安放，有的是爱人、家人、朋友；有的是国家、家乡；他们的感情浓厚且强烈，而如何把 “老伴儿啊，俺好想你了，你啷个时候能回来啊？娃儿都长高了” 这句话用生动、精彩、美丽又富有感情地表达出来，就显得尤为重要了。\n\n如果翻译成 “老公，我想你了，你什么时候能回来？” 好像也不错，但是似乎有点不够生动；如果翻译成 “亲爱的，你现在身在何方？又何时能够归来？风为我捎来讯息，硝烟在落叶上书信，诉说着远方的战火。想起了你拥我入眠的每个夜晚，你说星星是天使在偷看我们，你用温柔话语回应我的羞涩，而如今窗外只有军队的踏步声，偌大的床褥，却如此的拥挤而寒冷。林克慢慢长大，你离家的时候他还只会牙牙学语，如今已经是个强壮勇敢的男子汉了......” 这样似乎又有点太过华丽了，对于一个只会种的农民和打仗的士兵而言，反而没那么接地气。由此可见，感情是一封信中最重要的东西，怎样更能把写信人的想法全盘托出，又怎样能让读信人完美接收，就需要代写者细细品味两者之间感情的韵味了。\n\n<center>“只要是客人的愿望，不论天涯海角我们都竭诚为您服务</center>\n\n<center>自动笔记人偶薇尔莉特·伊芙加登”</center>\n\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\n\n## <center>OP</center>\n\n<center>\n\n每每学会未知的词语\n\n仿佛触及你的追忆\n\n但是或许也会有单词\n\n只身一人   终究无法理解\n\n再见  是苦涩的\n\n我爱你   则带着遥远的气息\n\n无可比拟的这份情愫\n\n让我胆战心惊   却又让我心动不已\n\n为什么的眼里噙满泪水\n\n该怎么回答我的心灵\n\n话语总在嘴边\n\n越是说不出口   越是揪人心肠\n\n让我想要与你相见\n\n</center>\n\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\n\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\n\n<br />\n\n“薇尔莉特，怎么样，你在看吗？”\n\n“我在，这是我第一次这么近的看星星”\n\n“不是星星，是彗星！”\n\n“我们今生今世再也不能与它相见了”\n<br />\n\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\n\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\n\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\n\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\n<br />\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\n\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\n\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\n\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%发E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\n\n## <center>剧场版-终</center>\n\n<pre style=\"white-space: pre-wrap;\n  word-wrap: break-word; background: #fafafa; border-top: 5px solid #f56c6c; border-bottom: 5px solid #f56c6c; line-height: 2; font-size: 16px; font-family:仿宋;\">\n    	首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\n    	剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\n    	我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\n    	祝愿世界上每一个生物都有能有配偶:-D\n</pre>\n\n\n自己截下来的一些图片：\n\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\n\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\n\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\n\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\n\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\n\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\n\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\n\n', 1, '', 1, 0, 1, '2022-06-30 22:48:02', '2022-10-11 19:44:06');
INSERT INTO `tb_article` VALUES (73, 1, 188, 'http://figurebed-1311634249.cos.ap-beijing.myqcloud.com/articles/62902b7bd74a3d1cb06e3aafd354e0c8.png', 'Java 基础', '# 📙Java基础\n\n## 1. 类与对象\n\n![对象在内存中的存在形式](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%9C%A8%E5%BD%A2%E5%BC%8F-cd2.jpg)\n\n\n\n### 1.1 作用域\n\n|  作用域   | 当前类 | 同一包 | 子类 | 不同包 |\n| :-------: | :----: | :----: | :--: | :----: |\n|  public   |   √    |   √    |  √   |   √    |\n| protected |   √    |   √    |  √   |   x    |\n|  default  |   √    |   √    |  x   |   x    |\n|  private  |   √    |   x    |  x   |   x    |\n\n全局变量（属性）可以不赋值，直接使用，因为有默认值，局部变量必须赋值后才能使用，因为没有默认值。\n\n1. 属性和局部变量可以重名，访问时遵循就近原则。\n2. 同一个作用域中，两个局部变量不能重名。\n3. 全局变量可以加修饰符，局部变量不行。\n\n### 1.2 构造器\n\n  构造方法又叫构造器（constructor），是类的一种特殊方法，它的主要作用是完成对<u>*新对象的初始化*</u>。\n\n1. 构造器修饰符可以默认，也可以是public protected private\n\n2. <u>构造器没有返回值</u>\n\n3. <u>方法名和类名必须一样</u>\n\n4. 参数列表和成员方法一样的规则\n\n5. 构造器的调用，由系统完成\n\n6. <u>构造器可以重载</u>\n\n   new 一个新对象的时候，会自动执行构造器，因此new时可以直接赋值，如：\n\n   Person p1 = new Person (\"梁渲\"， 20);\n\n### 1.3 this关键字\n\nthis(参数列表)只能在构造器中使用，也就是在一个构造器中访问另一个构造器，必须放在第一条语句，即同一给构造器中只能出现一次\n\n### 1.4 对象可以为空，也就是说返回值可以为null\n\n### 1.5 数组可以为空\n\n### 1.6 方法中的变量称为局部变量，之外的变量称为全局变量，this.是全局变量\n\n### 1.7 一个Java源文件中可以有多个主类，但是只能有一个公共类或者没有公共类\n\njava源文件在运行后会被编译成一个个class文件，但public类只能有一个，而主类main()方法可以有多个，main()方法是程序执行的入口\n\n## 2. 包\n\n作用：\n\n1. 区分相同名字的类\n2. 当类很多时，可以很好的管理类[看Java API 文档]\n3. 控制访问范围\n\n---\n\n\n\n## 3. 继承\n\n1. 如果子类有这个属性，则输出，如果子类没有这个属性，则依次往上找父类的属性。\n\n2. 私有属性不能直接在子类中访问，需要用父类提供的公共方法去访问，如下。\n\n   ```java\n   class A {\n     private name = \"张三\";\n     \n     public String getName () {\n       return name;\n     }\n   }\n   class B extends A {\n     \n   }\n   main{\n     B b1 = new B;\n     System.out.print(b1.name); // 报错\n     System.out.print(b1.getName); // 返回张三\n   }\n   ```\n\n3. 子类的任何方法的第一行都存在一个 super() 方法，该方法用于执行父类的无参构造器；但 this(); 和 super() 不能共存，若是子类的构造器中存在 this(); 方法，则super(); 也就不会存在了。\n\n---\n\n## 4. 多态\n\n1. 一个对象的编译类型和运行类型可以不一致\n2. 编译类型在定义对象时，就确定了，不能改变\n3. 运行类型是可以变化的\n4. 编译类型是看定义时 = 的左边，运行类型看 = 右边\n\n### 4.1 Java的动态绑定机制\n\n1. 当调用对象方法的时候，该方法会和该对象的**内存地址/运行类型**绑定\n2. 当调用对象的属性时，没有动态绑定机制，哪里声明就在哪里使用\n\n\n\n## 5 == 和 equals\n\n1. == 是一个比较运算符\n\n   1. 既可以判断基本类型，又可以判断引用类型\n   2. 如果判断基本类型，判断的是值是否相等。\n   3. 如果判断引用类型，判断的是地址是否相同，即判断是否是同一个对象。\n\n   **<font color = \"red\">如果 == 两边一个是基本类型，一个是引用类型，则只要存在基本类型就是判断两边的值是否相等</font>**\n\n2. equal 是 Object 类中的方法，只能判断引用类型，默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等\n\n   **<font color = \"red\">字符串对象的比较不能使用 == ，而应该使用 String 类的 equals 方法</font>**\n\n| 名称  | 概念                             | 用于基本数据类型     | 用于引用类型                                                 |\n| ----- | -------------------------------- | :------------------- | ------------------------------------------------------------ |\n| ==    | 比较运算符                       | 可以，判断值是否相等 | 可以，判断两个对象是否相等                                   |\n| equal         | object类的方法，Java类都可以使用 | 不可以               | 可以，默认是判断两个对象是否相等，但是子类往往重写该方法，比较对象的属性是否相等，比如（String,Integer) |\n\n## 6. javap 反编译\n\n![javap](assets/Java/javap.md)\n\n## 7. 三目运算符\n\n```java\npublic static void main(String[] args) {\n  Object obj1 = true ? new Integer(1) : new Double(2.0);\n  System.out.println(obj1);\n}\n//输出结果：1.0\n```\n\n1. 三目运算符只能使用基本数据类型，所以编译自动拆箱为 int、double\n2. 三目运算符是一个整体，要求数据类型一致，所以编译 int 自动提升为精度更高的 double\n\n## 8. Java 中只有值传递，没有引用传递\n\n这里涉及到值传递和引用传递两种传递机制：\n\n1. **值传递(pass by value)：** 是指在调用方法(或者函数)时，将实际参数复制一份传递到方法(或者函数)中，这样在函数中如果对形式参数进行修改，将不会影响到实参。\n\n2. **引用传递(pass by reference)：** 在调用方法(函数)时，将实参的地址直接传递到函数中，那么在函数中对形参进行修改，将影响到实参。\n\n**<font color = \"red\">Java 中只有值传递，始终是传值的。参数是基本数据类型，复制的是具体值；如果参数是引用类型，把地址当成值，复制的是地址；还有String类是一个非常特殊的类，它是不可变的。</font>**\n\n## 9. equals 和 hashCode\n\n**<font color = \"red\">equals 相等 hashCode 一定相等，hashCode 相等 equals不一定相等</font>**\n\n---', 1, '', 0, 0, 1, '2022-10-11 19:25:08', '2022-10-11 19:43:44');
INSERT INTO `tb_article` VALUES (74, 1, 188, 'http://figurebed-1311634249.cos.ap-beijing.myqcloud.com/articles/181fc31919c955d8e1cfb958ab132e18.jpg', 'Java 中级', '# 📙Java中级\n\n## 🖇️原生的equals和hashCode方法。\n\n1. **[equals](https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020)**\n\n   Object 中的 equals 方法和 == 是相同的，如下代码，比较的都是内存地址。\n\n   ```java\n    public boolean equals(Object obj) {\n      return (this == obj);\n   }\n   ```\n\n2. **hashCode**\n\n    原生的hashCode方法返回的是一个根据内存地址换算出来的一个值。它的定义是这样的：\n\n   ```java\n   public native int hashCode();\n   ```\n\n   可见这是一个 native 方法，因为 native 方法是并不是由 Java 语言来实现的，所以这个方法的定义中也没有具体的实现。根据 jdk 文档，该方法的实现一般是**“通过将该对象的内部地址转换成一个整数来实现的”**，这个返回值就作为该对象的哈希码值返回。\n\n3. **总结**\n\n    所以，在不重写equals和hashCode的情况下：\n\n   （1）两个对象如果equals相等的情况下，hashCode一定相等。因为equals默认是用“==”来比较，比较的是内存地址，而hashCode是根据内存地址得到哈希值，内存地址一样的话，得到的哈希值肯定是一样的。\n\n   （2）两个对象hashCode相等的情况下，equals不一定相等。这是为什么呢，首先我们来说一下哈希表，哈希表结合了直接寻址和链式寻址两个方式，简单来说就是先计算出要插入的数据的哈希值，然后插入到相应的分组当中去，因为哈希函数返回的是一个int类型，所以最多也就只有2的32次方个分组，对象多了，总有分组不够用的时候，这个时候，不同的对象就会产生相同的哈希值，也就是哈希冲突现象，此时就可以通过链地址法把分组用链表来代替，同一个链表上的对象hashCode肯定是相等的，因为是不同的对象，所以内存地址不同，所以他们的equals肯定是不相等的。这的hashCode就相当于是人名，equals就相当于身份证号，同名的人多了去了，但都不是同一个人。\n\n---\n\n## 🖇️ 类变量和类方法\n\n### 1. 类变量\n\n类变量也叫静态变量，被 static 修饰的变量会被所有对象实例共享。\n\n```java\npublic static int count = 0;\n```\n\n在jdk8以前，静态变量是放在方法区里的静态域，jdk8以后静态变量是放在堆里的，保存在class实例的尾部。\n\n---\n\n1. static被所有对象共享，任何一个对象访问的都是同一个值，修改的也是同一个变量。\n\n2. static类变量，在类加载的时候就生成了，所以即使没有对象实例也可以访问，如：\n\n   ```java\n   System.out.println(类名.静态变量);\n   ```\n\n   \n\n### 2. 类方法\n\n类方法与类变量同理\n\n我们在调用 Java 中的 Math 工具时，从来都不需要创建一个 Math 对象，就是因为 Math 类中的方法都是静态方法。\n\n因此我们可以将静态方法作为一种工具方法，放在工具类中随时调用。\n\n---\n\n1. 类方法中不允许使用和对象有关的关键字，比如 this 和 super ，普通方法可以。\n2. 类方法中**只能访问类变量和类方法**，普通方法都可以访问。\n\n### 3. 理解 main 方法语法\n\n解释 main 方法的形式：\n\n```java\npublic static vod main(String[] ages){}\n```\n\n1. main 方法是虚拟机调用\n\n2. Java虚拟机西药调用类的 main() 方法，所以该方法的访问权限必须是public\n\n3. java虚拟机在执行 main() 方法时不必创建对象，所以该方法必须是 static \n\n4. 该方法接收 String 类型的数组参数，该数组中保存执行 java 命令时传递给所运行的类的参数\n\n5. java 源文件执行的方式：java 类名.java 参数1 参数2 参数3\n\n   ```java\n   java hello.java qwe asd zxc\n   ```\n\n\n\n## 🖇️代码块\n\n1. 代码块主要解决构造器中重复出现的语句。\n2. 代码块调用的顺序优先于构造器。\n3. 静态代码块只能调用静态属性和静态方法\n4. 普通代码块都能调用\n\nstatic 代码块也叫静态代码块，作用就是对类进行初始化，伴随着类的加载而执行，且**只会执行一次**\n\n类什么时候被加载？\n\n* 创建对象实例（new）的时候\n* 创建子类对象实例，父类也会被加载\n* 实用类的静态成员时（类方法，类属性）\n\n普通代码块每创建一次就执行一次\n\n\n\n## 🖇️单例设计模式\n\n一个类只能同时存在一个实例（对象）\n\n1. 饿汉式\n   1. 构造器私有化\n   2. 类的内部创建实例（对象）\n   3. 创建一个公共的 static 方法，返回该实例（对象）\n2. 懒汉式\n   1. （与上相同）\n   2. 与饿汉式不同的是，懒汉式在用户不调用的时候不会加载对象\n\n\n\n## 🖇️final 关键字\n\n1. 定义：\n\n   final 修饰的属性又叫**常量**，一般用大写来命名\n\n2. 使用 final 的注意事项\n   1. final 修饰类的时候，**<font color=\"red\">类不能被继承</font>**\n   2. final 修饰方法的时候，父类的方法不能被子类**重写/覆盖**（override）\n   3. final 修饰属性值的时候，**属性值不能被修改**\n   4. final 修饰的属性在定义时必须赋值，之后就不能再修改（赋值位置：定义时、代码块中、构造器中）。如果 final 修饰的属性是静态的，则初始化位置只能是在定义时，代码块中（不能在构造器中）\n   5. 虽然被 final 修饰的方法不能被重写，但是可以被继承和使用\n   6. 如果一个类已经被 final 修饰，那类中的方法就不用 final 修饰了\n   7. final 不能被修饰构造器\n   8. final 和 static 搭配使用效率更高，底层代码做了优化（使用 static 会加载整个类，但是加上 final 就不会加载整个类了）\n\n\n\n## 🖇️ 抽象类\n\n1. 抽象类不一定要抽象方法，抽象方法必须为抽象类\n\n2. 抽象类不能被实例化\n\n3.  abstract 只能修饰类和方法，不能修饰属性和其他\n\n4. 如果一个类继承了抽=抽象类，则它必须实现抽象类中的所有方法，除非它自己也声明为抽象类\n\n5. 抽象方法不能使用 private、static 和  final 来修饰，因为这些修饰词都和重写相违背\n\n   > static：\n   >\n   > 被 static修饰的方法在和没有 static 修饰的方法在内存中的位置不一样。。\n   > 被static修饰的方法属于类，是类自己的东西，不是给子类来继承的。就好像类是个房子，它的静态方法是里面的一面墙，每个人都可已在墙上画画，你画的东西别人也能看到，属于大家共同使用。你想通过继承来把这面墙拿走也不可能拿走，他是从属于类的。\n   > 而抽象方法本身没有实现，就是用来给子类继承，存在内存中的位置也不是一样的。用 static修饰就不能被子类继承了。同样 你可以这么理解。\n   > 抽象方法相当于房子中地上的白纸，继承了它的子类就必须从地上拿一张白纸回去画画，你想怎么画怎么画。\n   > 一个相当于墙，你是拿不走的。一个相当于地上的纸，而且规定你实现了就必须拿走。\n   >\n   > final：\n   >\n   > final修饰的类不可继承，而抽象类本事是不能被实例化的，是需要让子类去继承，如果父类使用了 final 修饰符修饰方法，子类继承后，也无法重写该方法。\n   >\n   > private：\n   >\n   > private的访问权限是本类中，子类继承父类后，是无法方法 private 修饰的方法的。\n\n访问修饰符 abstract 类名{}\n\n\n\n## 🖇️模板设计模式\n\n1. 共同代码模板，不同代码抽象\n\n\n\n## 🖇️接口\n\n1. jdk8之前，在接口中，抽象方法可以省略 abstract 关键字，也就是说所有方法都是抽象方法，都不能有方法体\n\n2. jdk8后，接口中可以有默认方法，但是需要用 default 关键字修饰\n\n   ```java\n   public default void AA(){}\n   ```\n\n3. 也可以有静态方法\n\n   ```java\n   public static void BB(){}\n   ```\n\n4. 一个类可以实现多个接口\n\n   ```java\n   class AA implements BB,CC,DD{}\n   ```\n\n5. 接口中的属性只能是 final 的，而且是 public static final 修饰符\n\n6. 接口不能继承其它类，但是可以继承其它接口\n\n7. 接口的修饰符只能是 public 或者默认的，这点和类的修饰符是一样的\n\n### 1. 接口和继承\n\n1. 接口和继承解决的问题不同\n\n   接口的价值主要在于：设计、规定好各种方法，让其它类能够实现这些方法（功能）\n\n   继承的价值主要在于：解决代码的**复用性**和**可维护性**\n\n2. 接口比继承更加灵活\n\n   继承是满足 is - a 的关系\n\n   接口只需满足 like - a 的关系\n\n3. 接口在一定程度上实现代码解耦\n\n---\n\n## 🖇️四种内部类\n\n 类的五大成员：属性、方法、构造器、代码块、内部类\n\n内部类的最大特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系\n\n***定义在外部类局部位置上（比如方法内）:***\n\n### 1. 局部内部类（有类名）\n\n1. 定义在方法中 / 代码块中\n2. 可以直接访问定义在外部类的所有成员（属性和方法），包含私有的\n3. 不能添加访问修饰符，但是可以私用 final 修饰，被 final 修饰后就可以不被继承\n4. 作用域：仅仅在定义它的方法或代码块中\n5. 如果外部类和局部内部类的成员重名时，遵守就近原则。在此基础上访问外部成员可以使用 **`外部类名.this.成员`** 去访问，因为 **`外部类名.this`** 的意思就是访问创建了局部内部类这个方法的对象。\n\n### 2. 匿名内部类（没有类名）<font color = \"red\">重点！！</font>\n\n1. 定义在方法中 / 代码块中，并且没有类名\n\n2. 使用如下：\n\n   ```java\n   AA aa = new AA(\"name\"){\n     @Override\n     public void A(){\n     	....\n     }\n   };\n   aa.A();\n   \n   或者\n   \n   new AA(){\n     @Override\n     public void B(){\n     	...\n     }\n   }.B();\n   ```\n\n   匿名内部类没有类名，(\"name\")这个形参列表是传给类的构造器的，当然也可以重写构造器。\n\n3. 可以访问外部类的所有成员，包含私有\n\n4. 不能添加访问修饰符，因为他的地位就是一个局部变量\n\n5. 作用域：定义它的方法或者代码块中\n\n***定义在外部类的成员位置上：***\n\n### 3. 成员内部类（没用 static 修饰）\n\n1. 直接定义在外部类的成员位置，而不在方法或代码块中，并且没有 static 修饰\n2. 可以直接访问外部类的所有成员，包括私有\n3. 可以添加任意访问修饰符（public、protected、默认、private），因为它本身就是一个成员\n4. 使用如下：\n\n    ```java\n    第一种方式\n    main{\n      Outside outside = new Outside();\n      Outdise.memberInsideClass memberinsideclass = outside.new memberInsideClass();\n    }\n    \n    第二种方式\n    main{\n      Outside.MemberInsideClass menberInsideClass = new Outside().getMenberInsideClass();\n      memberInsideClass.方法();\n    }\n    Outside{\n      public MemberInsideClass getMenberInsideClass() {\n        return new MemberInsideClass();\n      }\n    }  \n    ```\n\n### 4. 静态内部类（使用 static 修饰）\n\n1. 成员内部类添加 static 修饰符\n2. 可以访问外部类所有静态成员，但不能访问非静态\n3. 可以添加任意访问修饰符（public、protected、默认、private），因为它本身就是一个成员\n\n---\n\n## 🖇️枚举和注解 - annotate\n\n### 1 自定义枚举类\n\n1. 构造器**私有化**：防止被直接 new\n2. 去掉 set 方法：防止属性被修改\n3. 在外部类直接创建固定的对象 `public static final 类名 对象名 = new 类名();`\n\n### 2. Enum 修饰的枚举类\n\n1. 使用 enum 关键字 替代 class，默认继承 Enum 类，而且是一个 final 类\n2. 将 `public static final 类名 对象名 = new 类名();` 简化成 `对象名();` 形式\n3. 如果有多个对象使用，使用**逗号**间隔，最后有一个**分号**结尾，如： `SPRING(\"春天\",\"温暖\"),WINTER(\"冬天\",\"寒冷\");`\n4. 枚举对象必须放在枚举类的行首\n5. 如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略\n\n#### 2.1 Enum 方法\n\n1. 返回该枚举对象的对象名\n\n   ```java\n   name()\n   ```\n\n2. 返回该枚举对象的次序\n\n   ```java\n   ordinal()\n   ```\n\n3. 返回当前枚举类中的所有常量\n\n   ```java\n   values()\n   ```\n\n4. 将字符串转换为枚举对象，要求字符串必须为已有常量名\n\n   ```java\n   valueOf()\n   ```\n\n5. 比较两个枚举常量，比较的是 `ordinal()`\n\n   ```java\n   compareTo()\n   ```\n\n\n#### 2.2 Enum 实现接口\n\n1. 使用 enum 关键字后，就不能继承其他类了，因为已经继承了 enum 类，而 java 是单继承机制。\n2. 但是可以实现接口\n\n### 3. 注解\n\n1. 注解也被称之为元数据，用于修饰解释（包、类、方法、属性、构造器、局部变量）等数据信息\n2. 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息\n3. @Target 是修饰注解的注解，称为元注解\n\n#### 3.1 三个基本的 Annotation：\n\n1. @Override：限定某个方法，是重写父类方法\n2. @Deprecated：用于表示某个程序元素（类，方法）已过时\n3. @SuppressWarnings：抑制编辑器警告\n\n#### 3.2 常用的注解\n\n1. **@Data** ： 注在类上，提供类的get、set、equals、hashCode、canEqual、toString方法\n2. **@AllArgsConstructor** ： 注在类上，提供类的**全参构造**\n3. **@NoArgsConstructor** ： 注在类上，提供类的无参构造\n4. @Setter ： 注在属性上，提供 set 方法\n5. @Getter ： 注在属性上，提供 get 方法\n6. @EqualsAndHashCode ： 注在类上，提供对应的 equals 和 hashCode 方法\n7. @Log4j/@Slf4j ： 注在类上，提供对的 Logger 对象，变量名为 log\n\n---\n\n## 🖇️异常 - Exception\n\n### 1. 异常的概念\n\n```java\nint a = 10;\nint b = 0;\nint c = a / b;\n```\n\n如上代码，如果执行到第三行程序就会报错（ArithmeticException），导致整个程序的中断，这显然是不合理的，所以需要**异常处理机制**来解决该问题，如下。\n\n```java\ntry{\n  int c = num1 /num2;\n}catch (Exception e){\n  e.printStackTrace();\n}\n```\n\n**程序执行过程中所发生的异常事件可分为两大类：**\n\n1. Error（错误）：Java 虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError[栈溢出] 和 OOM(out of memory)，Error是严重错误，程序会崩溃\n2. Exceptio：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等，Exception分为两大类：**运行时异常**和**编译时异常**。（如上述例子 ArithmeticException 就属于运行时异常，写代码时编译器不会报错）\n\n### 2. 常见的异常\n\n1. NullPointerException：空指针异常\n2. ArithmeticException：数学运算异常\n3. ArrayIndexOutOfBoundsException：数组下标越界异常\n4. ClassCastException：类型转换异常\n5. NumberFormatException：数字格式不正确异常\n\n### 3. 异常处理❗\n\n#### 3.1 异常处理方式\n\n1. **try-catch-finally**：程序员在代码中捕获发生的异常，自行处理\n\n   ```java\n   try {\n     //代码可能有异常\n   } catch (Exception e) {\n     // 捕获到异常\n     // 1. 当异常发生时\n     // 2. 系统将异常封装成Exception对象e, 传递给catch\n     // 3 得到异常对象后，程序员，自己处理\n     // 4 注意，如果没有发生异常catch代码块不执行\n   } finally {\n     // 1. 不管try代码块是否有异常发生，始终要执行finally\n     // 2. 所以，通常将释放资源的代码，放在finally\n   }\n   ```\n\n   可以有**多个 catch 语句**，捕获不同的异常（进行不同的业务处理），要求**父类异常在后，子类异常在前。**比如（Exception 在后，NullPointerException 在前），如果发生异常，只会匹配前面的 catch，如下。\n\n   ```java\n   try {\n     //代码\n   } catch (NullPointerException e) {\n   } catch (Exception e) {\n   } finally {\n   }\n   ```\n\n   也可以只使用 **try-finally**，相当于没有捕获异常，无论是否发生异常 finally 都要执行，**catch 即使是return，执行完成后也不会返回，而是执行 finally 后再返回**\n\n   ```java\n   try {\n     //代码\n   } finally { //总是执行\n     //代码\n   }\n   ```\n\n   **<font color = \"red\">注意：如果 catch 中有 return，finally 没有 return，则将 catch 的返回值保存在临时变量中，并不会受到 finally 的影响</font>**\n\n2. **throws**：将发生的异常抛出，交给调查者（方法）来处理，最顶级的处理者就是JVM\n\n   ![[assets/Java/throws机制处理图.png]]\n\n   如下代码，将错误抛给 Exception 处理，或者也可以用一个异常列表代替 `FileNotFoundException,NullPointerException,ArithmeticException`\n\n   ```java\n   public void f1() throws Exception{\n     FileInputStream fis = new FileInputStream(\"d://a.txt\");\n   }\n   ```\n\n\n**<font color = \"red\">注意：</font>**\n\n**<font color = \"red\">1. 对于编译时异常，程序必须处理，比如：try-catch 和 throws </font>**\n\n**<font color = \"red\">2. 对于运行时异常，程序中如果没有处理，默认就是 throws </font>**\n\n**<font color = \"red\">3. 子类重写父类方法时，对抛出的异常有所规定：子类重写的方法，抛出的异常要么和父类保持一致，要么为父类抛出异常的子类型 </font>**\n\n**<font color = \"red\">4. 如果有 try-catch 就不用 throws </font>**\n\n### 4. 自定义异常\n\n自定义异常的步骤：\n\n1. 定义类：自定义异常类名（程序员自己写）继承 Exception 或 RuntimeException\n\n2. 如果继承 Exception，属于编译异常\n\n3. 如果继承 RuntimeException，属于运行异常（一般来说，继承 RuntimeException)\n\n```java\n//自定义异常\nclass xxxException extends RuntimeException {\n    public xxxException(String message) { //构造器\n        super(message);\n    }\n}\n//使用\npublic class Exception_ {\n    public static void main(String[] args) {\n        throw new xxxException(\"发生异常\");\n    }\n}\n```\n\n**<font color = \"red\">一般情况下，我们自定义异常是继承 RuntimeException。也就是把自定义异常做成运行时异常，可以使用默认的处理机制，比较方便 </font>**\n\n### 5. throw 和 throws 的对比\n\n|        | 意义                     | 位置       | 后面跟的的东西 |\n| ------ | ------------------------ | ---------- | -------------- |\n| throws | 异常处理的一种方式       | 方法声明处 | 异常类型       |\n| throw  | 手动生成异常对象的关键字 | 方法体中   | 异常对象       |\n\n### 6. 异常体系图❗\n\n![异常体系图](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE-69c.png)\n\n---\n\n## 🖇️包装类（Wrapper）\n\n### 1. 包装类的分类\n\n1. 针对八种基本数据类型相应的引用类型一包装类\n2. **有了类的特点，就可以调用类中的方法**\n\n| 基本数据类型 |   包装类    |\n| :----------: | :---------: |\n|   boolean    |   Boolean   |\n|     char     |  Character  |\n|     byte     |  ==Byte==   |\n|    short     |  ==Short==  |\n|     int      | ==Integer== |\n|     long     |  ==Long==   |\n|    float     |  ==Float==  |\n|    double    | ==Double==  |\n\n其中标记的六个包装类的父类是 Number（继承 Object），而 Boolean 和 Character 则直接继承 Object\n\n```java\nInteger i = 200;\nInteger i2 = 200;\ni==i2 //false，不同对象\n  \nInteger i = 20;\nInteger i2 = 20;\ni==i2 //true，-128~127不会生成对象\n```\n\n### 2. 包装类和基本数据类型的转换\n\n```java\n//jdk5 之前的转换方式\nint a = 0;\nInteger integer = Integer.valueOf(a);\nint b = integer.intValue();\n\n//jdk5 之后的转换方式\nint a1 = 0;\nInteger integer1 = a1;\nint b1 = integer1;\n```\n\n**<font color = \"red\">其本质也是 jdk5 之前的方式，只不过简化了而已</font>**\n\n#### 2.1 包装类和 String 类型的相互转换\n\n1. 包装类（Integer） -> String\n\n   ```java\n   //包装类（Integer） -> String\n   Integer a = 100;\n   //方式一\n   String str1 = a + \"\";\n   //方式二\n   String str2 = a.toString();\n   //方式三\n   String str3 = String.valueOf(a);\n\n2. String -> 包装类（Integer）\n\n   ```java\n   //String -> 包装类（Integer）\n   String str4 = \"123\";\n   //方法一\n   Integer a1 = Integer.parseInt(str4); //自动装箱\n   //方法二\n   Integer a2 = new Integer(str4); //构造器\n\n### 3. 包装类方法\n\n```java\nSystem.out.printIn(Integer.MIN_VALUE);//返回最小值\nSystem.out.println(Integer.MAX_VALUI);//返回最大值\n  \nSystem.out.println(Character.isDigit(\'a\'));//判断是不是数字\nSystem.out.println(Character.isLetter(\'a\'));//判断是不是字母\nSystem.out.printIn(Character.isUpperCase(\'a\'));//判断是不是大写\nSystem.out.println(Character.isLowerCase(\'a\'));//判断是不是小写\n                   \nSystem.out.println(Character.isWhitespace(\'a\'));//判断是不是空格\nSystem.out.println(Character.toUpperCase(\'a\'));//转成大写\nSystem.out.println(Character.toLowerCase(\'A\'));//转成小写\n```\n\n### 4. int[] 和 Integer[] 的转换\n\n```java\n//int数组转Integer数组\nInteger newNums[] = Arrays.stream(nums).boxed().toArray(Integer[]::new);\n//Integer数组转int数组\nint[] num = Arrays.stream(newNums).mapToInt(Integer::valueOf).toArray();\n```\n\n\n\n---\n\n## 🖇️String 类\n\n1. String对象用于保存字符串，也就是一组字符序列\n\n2. 字符串常量对象是用双引号括起的字符序列。例如：\"你好\"、\"1297\"、\"boy\" 等\n\n3. 字符串的字符使用 Unicode 字符编码，一个字符（不区分字母还是汉字）占两个字节。\n\n   ==char 占两个字节==\n\n4. String 有属性 private final char[] **value**; 用于存放字符串内容，==其地址不可修改==\n\n5. String 类实现了接口  Serializable（String 可以串行化：可以在网络传输）\n\n6. String 类实现了接口  Comparable（String 对象可以比较大小）\n\n### 1. 两种创建 String 对象的区别\n\n1. 方式一：直接赋值 String a = \"a\";\n\n   先从常量池查看是否有 \"a\" 数据空间，如果有，直接指向；\n\n   如果没有则重新创建，然后指向；\n\n   a 最终指向的是常量池的空间地址\n\n2. 方式二：调用构造器 String b = new String(\"b\");\n\n   先在堆中创建空间，里面维护了 value 属性，指向常量池的 \"b\" 空间；\n\n   如果常量池没有 \"b\"，重新创建；\n\n   如果有，直接通过value指向。最终指向的是堆中的空间地址\n\n画出两种方式的内存分布图\n\n![String 内存分布图](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/String%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%9B%BE-4ad.png)\n\n### 2. String 对象特性❗\n\n1. String 是一个 final 类，代表不可变的字符序列\n\n   ```java\n   // 以下语句创建了几个对象\n   String s1 = \"hello\";\n   s1 = \"haha\";\n   // 答：两个\n   ```\n\n   **<font color = \"red\">一个字符串一旦被分配，其内容是不可变的，只能重新创建一个新的字符串，赋一个新的地址</font>**\n\n   ---\n\n   ```java\n   // 以下语句创建了几个对象\n   String s2 = \"hello\" + \"abc\";\n   // 答：一个\n   // 优化等价于 String s2 = \"helloabc\";\n   ```\n\n   ---\n\n   ```java\n   // 以下语句创建了几个对象\n   String a=\"hello\";\n   String b=\"abc\";\n   String c=a+b;\n   // 答：三个\n   // 1. 先创建一个 StringBuilder sb = StringBuilder()\n   // 2. 执行sb.append(\"hello\"); \n   // 3. sb.append(\"abc\");\n   // 4. String c=sb.tostring()\n   // 最后其实c是指向堆中的对象(String)value[] -> 池中 \"helloabc\"\n   ```\n\n2. String 中的 == 和 equals\n\n   == 是用来判断地址是否相同\n\n   equals 的父类是 Object，在 String 中重写，用于判断字符串内容是否相等\n\n3. String 类常见方法\n\n   ```java\n   equals //区分大小写，判断内容是否相等\n   equalslgnoreCase //忽略大小写的判断内容是否相等\n   length //获取字符的个数，字符串的长度\n   indexOf //获取字符在字符串中第1次出现的索引，索引从0开始，如果找不到，返回-1\n   lastIndexOf //获取字符在字符串中最后1次出现的索引，索引从0开始，如找不到，返回-1\n   substring //截取指定范围的子串\n   trim //去前后空格\n   charAt //获取某索引处的字符，注意不能使用Str[index]这种方式\n   replaceall //替换某处子字符串，可以使用正则表达式\n   matches //验证子字符串是否按照某种要求，使用正则表达式\n   split //分割字符串，\n   ```\n\n### 3. StringBuffer❗\n\n1. 代表可变的字符序列，可以对字符串内容进行增删\n2. StringBuffer是可变长度的。\n\n**<font color=\"red\">StringBuffer 比 String 效率更高</font>**\n\n### 4. StringBuilder❗\n\n1. 一个可变的字符序列，但不保证同步（**<font color=\"red\">不是线程安全</font>**），**用在字符串缓冲区被单个线程使用的时候**，在大多数实现中，它比 StringBuffer 要快\n2. 在 StringBuilder 上的主要操作是 append 和 insert 方法，可重载这些方法以接受任意类型的数据。\n\n```java\n//String可以通过append()方法转换成StringBuilder或StringBuffer类型\nStringBuilder a = new StringBuilder(\"123\");\n\n//StringBuilder和StringBuffer 可以通过toString()方法转换成String类型\nStringBuilder a1 = new StringBuilder(\"123\");\nString a1 = a.toString();\n```\n\n### 5. 三者比较和选择❗\n\n比较：\n\n1. StringBuilder 和 StringBuffer 非常类似，均代表可变的字符序列，而且方法也一样\n2. String：字符串常量，不可变字符序列，效率低，但是复用率高。\n3. StringBuffer：字符串变量，可变字符序列、效率较高（增删）、线程安全\n4. StringBuilder：字符串变量，可变字符序列、效率最高、线程不安全\n\n选择：\n\n1. 如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder\n2. 如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder\n3. 如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer\n4. 如果我们字符串很少修改，被多个对象引用，使用String,比如配置信息等\n\nString使用注意说明：   \nstring s:=\"a\"; //创建了一个字符串  \ns+=\"b\"; //实际上原来的\"a\"字符串对象已经丢弃了，现在又产生了一个字符串s+\"b\"(也就是\"ab\")。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。**<font color=\"red\">如果我们对String做大量修改，不要使用 String</font>**\n\n**<font color=\"red\">StringBuilder 和 StringBuffer 的使用方法是一样的</font>**\n\n---\n\n## 🖇️Math\n\n### 1. abs 绝对值\n\n### 2. pow 求幂\n\n### 3. ceil 向上取整\n\n### 4. floor 向下取整\n\n### 5. round 四舍五入\n\n### 6. sqrt 求开方\n\n### 7. random 求随机数\n\n获取一个a-b之间的一个随机整数\n\n```java\nint num = (int)(a + Math.random()*(b - a + 1));\n```\n\n### 8. max 求两个数的最大值\n\n### 9. min 求两个数的最小值\n\n## 🖇️Arrays 类\n\n### 1. toString 返回数组的字符串形式\n\n```java\nArrays.toString(arr);\n```\n\n### 2. sort 排序（自然排序和定制排序）\n\n```java\nArrays.sort(a);\n```\n\n```java\nArrays.sort(a, new Comparator() {\n  			@Override\n  			public int compare(Object o1, Object o2) {\n   			return 0;\n  			}\n		}\n);\n```\n\n### 3. binarySearch 通过二分搜索法进行查找\n\n返回对应数组下标（要求必须排好序，如果数组是无序的，则不能使用。如果数组中不存在搜索的数字，会返回与之相近的、偏大的数字的、下标数字加一的负数。如下）\n\n```java\nInteger[] a = {-5, -4, 5, 31, 79, 100};\n//查找6，但是6并不存在\nSystem.out.println(Arrays.binarySearch(a, 6));//输出-4\nSystem.out.println(Arrays.binarySearch(a, -3));//输出-3\n```\n\n### 4. copyOf 数组元素的复制\n\n### 5. fill 数组元素的填充\n\n```java\nArrays.fill(arr,1);//将数组元素全部用1替换\n```\n\n### 6. equals 比较两个数组元素内容是否完全一致\n\n### 7. asList 将一组值，转换成list\n\n---\n\n## 🖇️System 类\n\n### 1. exit 退出当前程序\n\n### 2. arraycopy 复制数组元素\n\n```java\nSystem.arraycopy(arr1, 0, arr2, 0, 3);\n//源数组\n//源数组的第几个位置\n//目标数组\n//目标数组的第几个位置\n//拷贝几个元素\n```\n\n一般不用它，一般用 Arrays.copyOf() ，它的底层就是 System.arraycopy()\n\n### 3. currenTimeMillens 返回当前时间距离 1970-1-1 的毫秒数\n\n### 4. gc 运行垃圾回收机制\n\n---\n\n## 🖇️BigInteger 和 BigDecimal 类\n\n1. 初始化的时候需要用字符串\n\n   ```java\n   BigInteger bigInteger = new BigInteger(\"123456789123456789123456789\");\n   BigDecimal bigDecimal = new BigDecimal(\"123.123456789123456789\");\n   ```\n\n**<font color=\"red\">计算的时候不能用普通的运算符（+ - * /），需要使用以下的方法</font>**\n\n2. add 加\n\n3. subtract 减\n\n4. multiply 乘\n\n5. divide 除\n\n   **<font color=\"red\">小数除法的时候有可能除不尽，然后报错，需要添加一个参数，就可以保留到分子的精度</font>**\n\n   ```java\n   bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING);\n   ```\n\n---\n\n## 🖇️Date、Calendar、LocalDate 类\n\n### 1. Date\n\n1. Date 精确到毫秒，代表特定的瞬间\n\n   ```java\n   Date date = new Date();\n   ```\n\n2. SimpleDateFormat 格式和解析日期的类。它允许进行格式化（日期->文本）解析（文本->日期）和规范化\n\n   ```java\n   //格式化日期\n   SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss E\");\n   System.out.println(dateFormat.format(date));\n   //输出：2022年09月11日 15:41:37 周日\n   ```\n\n   ```java\n   //文本转日期\n   String s = \"2022年09月11日 15:41:37 周日\";\n   Date date1 = dateFormat.parse(s);\n   System.out.println(dateFormat.format(date1));\n   //字符串转日期\n   String s = \"2022年09月11日 15:41:37 周日\";\n   Date date1 = dateFormat.parse(s);\n   System.out.println(dateFormat.format(date1));\n   ```\n\n### 2. Calendar\n\n```java\n//创建日历类对象\nCalendar c = Calendar..getlnstance(); \n\n//获取日历对象的某个日历字段\nSystem.out.printIn(\"年:\" + c.get(Calendar.YEAR));\nSystem.out.println(\"月:\" + (c.get(Calendar.MONTH) + 1));\nSystem.out.println(\"日:\" + c.get(Calendar.DAY_OF_MONTH));\nSystem.out.println(\"小时：，\" + c.get(Calendar.HOUR));\nSystem.out.printIn(\"分钟：\" + c.get(Calendar.MINUTE);\nSystem.out.println(\"秒:\" + c.get(Calendar.SECOND));\n                   \n//Calender没有专门的格式化方法，所以需要程序员自己来组合显示\nSystem.out.println(c.get(Calendar.YEAR) + \"年\" + (c.get(Calendar.MONTH) + 1) + \"月\" + c.get(Calendar.DAY_OF_MONTH) + \"日\");\n```\n\nCalendar 中存在以下问题：\n\n1. 可变性：像日期和时间这样的类应该是不可变的。\n2. 偏移性：Date中的年份是从1900开始的，而月份都从0开始。\n3. 格式化：格式化只对Date有用，Calendar则不行。\n4. 此外，它们也不是线程安全的；不能处理闰秒等（每隔2天，多出1s)。\n\n### 3. LocalDate - 第三代日期\n\n1. LocalDate（日期/年月日）\n\n2. LocalTime（时间/时分秒）\n\n3. LocalDateTime（日期+时间）\n\n   ```java\n   LocalDateTime ldt = LocalDateTime.now();\n                     getYear(); //年      \n                     getMonth();  //月    \n                     getMonthValue(); //月 \n                     getDayofMonth(); //日\n                     getHour(); //时     \n                     getMinute(); //分   \n                     getSecond(); //秒\n   //使用now()返回表示当前日期时间的对象\n   LocalDate now=LocalDate.now();//可以获取当前年月日\n   LocalTime now2=LocalTime.now();//获取到当前时分秒\n   ```\n\n4. DateTimeFormatter 日期格式化\n\n   ```java\n   DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd hh:mm:ss\");\n   LocalDateTime localDateTime = LocalDateTime.now();\n   String format = dateTimeFormatter.format(localDateTime);\n   ```\n\n5. Instant 时间戳\n\n   ```java\n   //通过静态方法now()获取表示当前时间戳的对象\n   Instant instant = Instant.now();\n   //通过from可以把Instant转成Date\n   Date date = Date.from(instant);\n   //通过date的toInstant()可以把date转成instant \n   ```\n\n\n---\n\n## 🖇️集合\n\n### 1. 集合框架体系\n\n数组的不足之处： \n1. 长度开始时必须指定，不能更改\n2. 保存的数据为同一种类型\n3. 使用数组增加/删除元素的时候比较麻烦\n\n集合的好处： \n1. 可以动态保存任意多个对象\n2. 提供了一系列方便的操作对象的方法\n3. 使用集合添加/删除元素比较方便\n\n### 2. Collection - 单列集合\n\n1. collection.实现子类可以存放多个元素，每个元素可以是Object\n\n2. 有些Collection的实现类，可以存放重复的元素，有些不可以\n\n3. 有些Collection的实现类，有些是有序的(List),有些不是有序(Set)\n\n4. Collection接口没有直接的实现子类，是通过它的子接口Set和List来\n   实现的\n\n   ```java\n   add:添加单个元素\n   remove:删除指定元素\n   contains:查找元素是否存在\n   size:获取元素个数\n   isEmpty:判断是香为空\n   clear:清空\n   addALl:添加多个元素\n   containsAll:查找多个元素是否都存在\n   removeAll:删除多个元素\n   ```\n\n#### List\n\nList集合类中元素有序（即添加顺序和取出顺序一致）、且可重复\n\nList集合中的每个元素都有其对应的顺序索引，即支持索引\n\nList容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。\n\n1. 迭代器\n\n   ```java\n   ArrayList arrayList = new ArrayList();\n   //新建一个迭代器对象，并重置迭代器\n   Iterator iterator = arrayList.iterator();\n   //迭代元素\n   while (iterator.hasNext()) {\n     Object next = iterator.next();\n     System.out.println(next);\n   }\n   ```\n\n2. 增强 for 循环\n\n   ```java\n   for (Object obj : arrayList) {\n   	System.out.println(obj);\n   }\n   ```\n\n**<font color=\"red\">增强for循环在普通数组中也能使用。</font>**\n\n**<font color=\"red\">增强for循环其实是简化版的迭代器，底层仍然是hasNext()</font>**\n\n##### ArrayList❗\n\n1. ArrayList是由数组来实现数据存储的\n2. ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高）。在多线程情况下，不建议使用ArrayList\n3. ArrayListr中维护了一个Object类型的数组elementData.  \n   `transient Object[] elementData;`  \n   transient 表示瞬间，短暂的，表示该属性不会被序列化 ^9da737\n4. 当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容elementData为10，如需要再次扩容，则扩容elementData为1.5倍。\n5. 如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍。\n\n##### Vector❗\n\n1. Vector底层也是一个对象数组，`protected Object[] elementData;`\n2. Vector 是线程同步的，也就是线程安全\n\n##### Vector 和 ArrayList 的比较\n\n|           | 底层结构 | 版本   | 线程安全       | 扩容倍数                                                     |\n| --------- | -------- | ------ | -------------- | ------------------------------------------------------------ |\n| ArrayList | 可变数组 | jdk1.2 | 不安全，效率高 | 1. 无参默认0，第一次10，之后1.5倍<br />2. 有参第一次及之后都1.5倍 |\n| Vector    | 可变数组 | jdk1.0 | 安全，效率不高 | 1. 无参默认为10，第一次及之后为2倍<br />2. 有参第一次及之后都2倍 |\n\n##### LinkedList\n\n1. LinkedList底层实现了**双向链表**和**双端队列**特点\n2. 可以添加任意元素（元素可以重复），包括null\n3. 线程不安全，没有实现同步\n4. LinkedList底层维护了一个双向链表\n5. LinkedList中维护了两个属性 first 和 last 分别指向首节点和尾节点\n6. 每个节点(Node对象)，里面又维护了prev、next、item三个属性，其中通过\n   prev指向前一个，通过next指向后一个节点。最终实现双向链表\n7. 所以LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高。\n![双向链表](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-5c3.png)\n\n##### LinkedList 和 ArrayList 的比较\n\n|            | 底层结构 | 增删的效率         | 改查的效率 |\n| ---------- | -------- | ------------------ | ---------- |\n| ArrayList  | 可变数组 | 较低，数组扩容     | 较高       |\n| LinkedList | 双向链表 | 较高，通过链表追加 | 较低       |\n\n如何选择ArrayList和LinkedList:\n\n1. 如果我们改查的操作多，选择ArrayList\n2. 如果我们增删的操作多，选择LinkedList\n3. 一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList\n4. 在一个项目中，根据业务灵活选择，也可能这样：一个模块使用的是ArrayList，另外一个模块是LinkedList\n\n#### Set\n\n1. Set 接口基本介绍\n   1. 无序（添加和取出的顺序不一致），没有索引\n   2. 不允许重复元素，所以最多包含一个null\n   3. JDK APIE中Set接口的实现类有：HashSrt、TreeSet等\n\n2. Set 遍历方式\n\n   同Collection 的遍历方式一样，因为 Set 接口是 Collection 接口的子接口\n\n   1. 可以使用迭代器\n   2. 增强 for\n   3. 不能使用索引的方式来获取\n\n##### HashSet❗\n\n1. HashSet 的底层其实就是 HashMap\n2. HashMap的底层是（数组+链表+红黑树）\n\nHashSet 添加元素底层是如何实现的：\n\n1. 添加一个元素时，**先得到 hash 值，然后转成索引值**（**<font color=\"red\">注意：不同对象 hashcode 值不一定不同，由 hashcode 转成的索引值也不一定不同。如果想要索引值相同，可以重写 hashcode() 方法</font>**）\n\n   ```java\n   static final int hash(Object key) {\n     int h;\n     return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n   }\n   ```\n\n2. 找到你想添加元素的存储数据表，看这个索引位置是否已经存放有元素\n\n3. 如果没有，直接加入。如果有，**调用 equals 比较**，如果相同就放弃添加，**如果不相同，则添加到这个索引的链表的最后**（**<font color=\"red\">注意：equals 可以重写，不再比较引用地址，而是比较内容：当对象的属性值相同时，返回相同的 hashcode 值 ，从而使得[不同对象但属性值相同的]对象，只能添加一个</font>**）\n\n4. 在 jdk8以后，如果一条链表的对象个数达到 TREEIFY_THRESHOLD（**默认是8**），并且 table 的大小达到 MIN_TREEIFY_CAPACITY （**默认是64**），就会进行**树化**（红黑树）\n\nHashSet 扩容机制：\n\n1. **第一次添加时，table 数组扩容到 16**，临界值（threshold）是16\\*加载因子（loadFactor）是0.75 = 12\n2. 如果 table 数组使用到了**临界值12**（**<font color=\"red\">注意：这里是指整个 table 数组中的对象达到12个，并非仅仅一个链表</font>**），就会扩容到 16\\*2 = 21，新的临界值就是 32\\*0.75 = 24，依次类推\n\n##### TreeSet\n\n1. TreeSet 拥有一个可以传入两个参数的构造器，一个是存入的对象，一个是比较器（Comparator）\n2. 如果没有传入比较器，就会在底层 `Comparator<? super k>k = (Comparable<?super K>)key;` 把存入的对象转成 Comparator类型 \n\n##### LinkedHashSet\n\n1. LinkedHashSet 底层是一个 LinkedHashMap，底层维护了一个 数组+双向链表\n2. LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的。\n3. LinkedHashSet 也不能添加重复元素\n\n### 3. Map - 双列集合\n\n1. 用于保存具有映射关系的数据：Key-Value（双列元素）\n\n2. Map中的key和value可以是任何引用类型的数据，会封装到HashMap:$Node对象中\n\n3. Map中的key不允许重复，原因和HashSet一样，当有相同的k，就等价于替换。\n\n4. Map 中的value是可以重复的\n\n   ```java\n   Map map = new HashMap();\n   map.put(key, value);\n   ```\n\n5. Map 体系的继承图\n\n   ![Map体系图](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/Map%E4%BD%93%E7%B3%BB%E5%9B%BE-249.png)\n\n6. Map 接口常用方法\n\n   - put:添加\n   - remove:根据键删除映射关系\n   - get:根据键获取值\n   - size获取元素个数\n   - isEmpty:判断个数是否为0\n   - clear:清除\n   - containsKey:查找键是否存在\n   - getOrDefault(a,0)：查看a是否存在，如果存在返回a的value，如果不存在就返回0\n\n#### HashMap❗\n\n1. Map接口的常用实现类：HashMap、Hashtable和Properties。\n2. HashMap是Map接口使用频率最高的实现类。\n3. HashMap是以key-val对的方式来存储数据（HashMap$Node类型）\n4. key不能重复，但是值可以重复，允许使用nul键和nul值。\n5. 如果添加相同的key，则会覆盖原来的key-val，等同于修改。(key不会替换，val会替换)\n6. 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的。（jdk8的\n   hashMap底层数组+链表+红黑树，之前是数组+链表）\n7. HashMap没有实现同步，因此是线程不安全的\n\n#### Hashtable\n\n1. Hashtable 线程安全\n\n#### LinkedHashMap\n\n#### TreeMap\n\n1. TreeSet 的底层就是 TreeMap\n\n#### Properties\n\n1. Properties 类继承自 Hashtable 类并且实现了 Map 接口，也是使用一种键值对的形式来保存数据。\n2. 他的使用特点和Hashtable类似\n3. Properties 还可以用于从 xxx.properties 文件中，加载数据到 Properties 类对像，\n   并进行读取和修改\n\n### Collections 工具类\n\n1. Collections工具类介绍\n\n   Collections是一个操作 Set、List 和 Map 等集合的工具类\n\n   Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作\n\n2. 排序操作：(均为 static 方法)\n\n   reverse(List)：反转 List 中元素的顺序\n\n   shuffle(List)：对 List 集合元素进行随机排序\n\n   sot(List)：根据元素的自然顺序对指定List集合元素按升序排序\n\n   sort(List, Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序\n\n   swap(List,int,int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换\n\n3. 查找、替换：\n\n   Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素\n\n   Object max(Collection, Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素\n\n   Object min(Collection)\n\n   Object min(Collection, Comparator)\n\n   int frequency(Collection, Object)：返回指定集合中指定元素的出现次数\n\n   void copy(List dest, List src)：将 src 中的内容复制到 dest 中\n\n   boolean replaceAll(List list, Object oldVal, Object newVal)：新值替换 List 对象的所有旧值\n\n**<font color=\"red\">自然排序是指按首字母A-Z、a-z排序</font>**\n\n### 总结-开发中如何选择集合实现类\n\n在开发中，选择什么集合实现类，主要取决于务操作特点，然后根据集合实现类特性进行\n选择，分析如下：\n\n1. 先判断存储的类型（一组对象[单列]或一组键值对[双列]）\n\n2. 一组对象：Collection接口\n\n   - 允许重复：List\n\n     增删多：LinkedList [底层维护了一个双向链表]\n\n     改查多：ArrayList [底层维护Object类型的可变数组]\n\n   - 不允许重复：Set\n\n     无序：HashSet [底层是HashMap,维护了一个哈希表，即（数组+链表+红黑树）]\n\n     排序：TreeSet\n\n     插入和取出顺序一致：LinkedHashSet，维护数组+双向链表\n\n3. 一组键值对：Map\n\n   - 键无序：HashMap [底层是：哈希表 jdk7:数组+链表，jdk8:数组+链表+红黑树]\n   - 键排序：TreeMap\n   - 键插入和取出顺序一致：LinkedHashMap\n   - 读取文件：Properties\n\n---\n\n## 🖇️泛型\n\n### 1. 泛型的理解和好处\n\n使用传统方法的问题分析\n\n1. 不能对加入到集合ArrayList中的数据类型进行约束（不安全）\n2. 遍历的时候，需要进行类型转换，如果集合中的数据量较大，对效率有影响\n\n泛型介绍\n\n1. 泛型又称参数化类型，是Jdk5.0出现的新特性，解决数据类型的安全性问题\n2. 在类声明或实例化时只要指定好需要的具体的类型即可\n3. Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生 ClassCastException 异常。同时，代码更加简洁、健壮\n4. 泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型或者是某个方法的返回值的类型，或者是参数类型\n\n### 2. 泛型基本语法\n\n1. 给泛型指向数据类型时，**要求是引用类型**，**不能是基本类型**\n2. 在给泛型指定具体类型后，可以传入**该类型或者其子类类型**\n3. 如果没有指定泛型，默认是object类型\n4. 使用泛型的数组，不能初始化\n5. 静态方法中不能使用类的泛型\n\n### 3. 自定义泛型\n\n#### 4. 泛型的继承和通配符\n\n1. 泛型不具备继承性\n2. \\<?>：支持任意泛型类型\n3. \\<? extends A>： 支持A类以及A类的子类，规定了泛型的上限\n4. \\<?super A>：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限\n\n---\n\n## 🖇️Java 绘图坐标体系\n\n下图说明了Java坐标系。坐标原点位于左上角，以像素为单位。  \n第一个是x坐标，表示当前位置为水平方向，距离坐标原点x个像素  \n第二个是y坐标，表示当前位置为垂直方向，距离坐标原点y个像素。\n\n![Java 绘图坐标体系](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/Java%20%E7%BB%98%E5%9B%BE%E5%9D%90%E6%A0%87%E4%BD%93%E7%B3%BB-870.png)\n\n绘图原理：\n\n1. paint(Graphics g)绘制组件的外观\n\n2. repaint()刷新组件的外观。\n3. 当组件第一次在屏幕显示的时候，程序会自动的调用paint()方法来绘制组件。\n4. 窗口最小化，再最大化、窗口的大小发生变化、repaint函数被调用的时候pain()将会被调用\n\n```java\n//JFrame 就是一个画框\npublic class DrawCricle extends JFrame {\n    private MyPanel mp = null;\n\n    public static void main(String[] args) {\n        DrawCricle drawCricle = new DrawCricle();\n    }\n\n    public DrawCricle() {\n        mp = new MyPanel();\n        this.add(mp);\n        this.setSize(400, 300);\n        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        this.setVisible(true);\n    }\n}\n//Mypanel 对象就是一个画板\n//Graphics g 就是一个画笔\nclass MyPanel extends JPanel {\n    @Override\n    public void paint(Graphics g) {\n        super.paint(g);\n        g.drawOval(10, 10, 100, 100);\n    }\n}\n```\n\n---\n\n## 🖇️Java 事件处理机制\n\nKeyListener 是监听器，可以监听键盘事件\n\n```java\nclass MyPanel extends JPanel implements KeyListener {\n    @Override\n    public void paint(Graphics g) {\n        super.paint(g);\n        g.fillOval(10, 10, 100, 100);\n    }\n		//有字符输出时，该方法就会触发\n    @Override\n    public void keyTyped(KeyEvent e) {\n        \n    }\n		//当某个键按下，该方法会触发\n    @Override\n    public void keyPressed(KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_DOWN) {\n            y++;\n        } else if (e.getKeyCode() == KeyEvent.VK_UP) {\n            y--;\n        } else if (e.getKeyCode() == KeyEvent.VK_LEFT) {\n            x--;\n        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {\n            x++;\n        }\n        this.repaint();\n    }\n		//当某个键释放，该方法会触发\n    @Override\n    public void keyReleased(KeyEvent e) {\n\n    }\n}\n```\n\n![Java事件处理机制](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/Java%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6-aa3.png)\n\n1. 事件源：事件源是一个产生事件的对象，比如按钮，窗口等。\n2. 事件：事件就是承载事件源状态改变时的对象，比如当键盘事件、鼠标事件、窗口事件等等，会生成一个事件对像，该对象保存着当前事件很多信息，比如KeyEvent对像有含义被按下键的Code值。java.awt.event包和javax.swing.event包中定义了各种事件类型\n\n## 🖇️线程\n\n### 1. 线程项关概念\n\n1. 进程：是指运行中的程序\n\n2. 线程：线程是由进程创建的，是进程的一个实体；一个进程可以拥有多个线程\n   - 单线程：同一个时刻，只允许执行一个线程\n   - 多线程：同一个时刻，可以执行多个线程\n   - **并发**：同一个时刻，多个任务**交替执行**，造成一种“貌似同时”的错觉，简单的说，单核cpu实现的多任务就是并发\n   - **并行**：同一时刻，多个任务**同时执行**，多核cpu可以实现并行；并发和并行可以同时存在\n\n3. 当一个类继承了 Thread 类，该类就可以当作线程使用\n\n   ```java\n   at cat = new Cat();\n   cat.start();\n   //start()方法会启动一个线程，main线程和该线程会同时进行，\n   //而单纯使用一个方法没有真正启动一个线程，而是会在方法执行完后再继续执行main方法\n   ```\n\n4. 当一个类实现了 Runnable 接口，该类就可以当作线程使用\n\n   ```java\n   class Cat implements Runnable {\n     @Override\n       public void run() {\n           while (true) {\n               System.out.println(\"miao~\");\n           }\n       }\n   }\n   ```\n\n5. 继承 Thread 和实现 Runnable 的区别\n\n   1. 从java的设计来看，通过继承Thread或者实现Runnable接口来创建线程本质上没有区别，而且Thread类本身就实现了Runnable接口\n   2. 实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了java**单继承的限制**\n\n当main线程启动一个子线程，主线程不会阻塞，会继续交替执行\n\n***start()方法调用start0()方法后，该线程并不一定会立马执行，只是将线程变成了可运行状态。具体什么时候执行，取决于CPU,，由CPU统一调度。***\n\n### 2. 线程常用方法\n\n1. setName //设置线程名称，使之与参数name相同\n\n2. getName //返回该线程的名称\n\n3. start //使该线程开始执行；Java虚拟机底层调用该线程的start0方法\n\n4. run //调用线程对像run方法；\n\n5. setPriority //更改线程的优先级\n\n6. getPriority //获取线程的优先级\n\n   优先级有三种：\n\n   * MIN_PRIORITY = 1\n   * NORM_PRIORITY = 5\n   * MAX_PRIORITY = 10\n\n7. sleep //在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）\n\n8. interrupt //中断线程，没有真正的结束线程，一般用于中断正在休眠的线程\n\n9. yield //线程的礼让。让出cpu，让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功\n\n10. join //线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务\n\n### 3. 用户线程和守护线程：\n\n1. 用户线程：也叫工作线程，当线程的任务执行完或通知方式结束\n\n2. 守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束\n\n   ```java\n   子线程对象.setDeamon(true) //将该对象设置为守护线程\n   ```\n\n   * 常见的守护线程：**垃圾回收机制**\n\n### 4. 线程的生命周期\n\n\n线程可以处于以下状态之一：\n\n1. NEW：尚未启动的线程处于此状态。\n2. RUNNABLE：在Java虚拟机中执行的线程处于此状态。\n3. BLOCKED：被阻塞等待监视器锁定的线程处于此状态。\n4. WAITING：正在等待另一个线程执行特定动作的线程处于此状态。\n5. TIMED WAITING：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。\n6. TERMINATED：己退出的线程处于此状态。\n\n**<font color=\"red\">有些文章或者资料中标注有七种状态，其实是 Runable 状态下细分出两个子状态 Ready 和 Running 状态</font>**\n\n![Java线程状态转换图](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE-778.jpg)\n\n### 5. 线程同步机制\n\n在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，***保证数据在任何同一时刻，最多有一个线程访问，以保证数据的完整性***。  \n也可以这里理解：线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，***直到该线程完成操作，其他线程才能对该内存地址进行操作***\n\n1. 同步具体方法 - **Synchronized**\n\n   * 同步代码块\n\n     ```java\n     synchronized (同一个对象){//得到对像的锁，才能操作同步代码\n     	//需要被同步代码;\n     }\n     ```\n\n   * synchronized 还可以放在方法声明中，表示整个方法-为同步方法\n\n     ```java\n     public synchronized void run(){\n     	//需要被同步的代码\n     }   \n     ```\n\n### 6. 互斥锁\n\n基本介绍：\n\n1. Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。\n\n2. 每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。\n\n3. 关键字 synchronized 来与对象的互斥锁联系。当某个对象用 synchronized 修饰时，表明该对象在任一时刻只能由一个线程访问\n\n4. 同步的局限性：导致程序的执行效率要降低\n\n5. 非静态的同步方法的锁可以是this，也可以是其他对象（要求是同一个对象）\n\n   如下，这就是一个同步方法，锁在this对象\n\n   ```java\n   public synchronized void method(){\n   	//需要被同步的代码\n   }   \n   ```\n\n   ```java\n   synchronized (this){//得到对像的锁，才能操作同步代\n   	//需要被同步代码;\n   }\n   ```\n\n6. 静态的同步方法的锁为当前类本身。\n\n   ```java\n   public synchronized static void method(){\n   	//需要被同步的代码\n   }\n   ```\n\n   ```java\n   synchronized (类.class){//得到对像的锁，才能操作同步代码\n   	//需要被同步代码;\n   }\n   ```\n\n7. 注意事项：\n\n   1. 同步方法如果没有使用static修饰：默认锁对象为this\n   2. 如果方法使用static修饰，默认锁对象：当前类.class\n   3. 实现步骤：\n      * 需要先分析上锁的代码\n      * 选择==同步代码块==或同步方法\n      * 要求***多个线程的锁对象为同一个***\n\n### 7. 线程的死锁\n\n基本介绍：  \n多个线程都占用了对方的锁资源，但不肯相让，导致了死锁，在编程是一定要避免死锁的发生\n\n### 8. 释放锁\n\n1. 当前线程的同步方法、同步代码块**执行结束**\n2. 当前线程在同步代码块，同步方法中遇到**break、return**\n3. 当前线程在同步代码块、同步方法中出现了**未处理的Error或Exception**，导致异常结束\n4. 当前线程在同步代码块、同步方法中执行了线程对象的**wite()方法**，**当前线程暂停，并释放锁。**\n\n下面操作不会释放锁：\n\n1. 线程执行同步代码块或同步方法时，程序调用**Thread.sleep()、Thread.yield() 方法暂停当前线程的执行，不会释放锁**\n2. 线程执行同步代码块时，其他线程调用了该线程的 **suspend() 方法**将该线程挂起，该线程不会释放锁。\n\n---\n\n## 🖇️IO\n\n### 1. 文件\n\n1. 文件流\n\n   文件在程序中是以流的形式来操作的\n\n   ![文件流](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E6%96%87%E4%BB%B6%E6%B5%81-938.png)\n\n   流：数据在数据源（文件）和程序（内存）之间经历的路径\n\n   输入流：数据从数据源（文件）到程序（内存）的路径\n\n   输出流：数据从程序（内存）到数据源（文件）的路径\n\n2. 创建文件对象相关构造器和方法\n\n   ```java\n   File file = new File(String pathname)//根据路径构建一个File对象\n   File file = new File(File parent,String child)//根据父目录文件+子路径构建\n   File file = new File(String parent,String child)//根据父目录+子路径构建\n     \n   file.createNewFile(); //创建文件  \n   ```\n\n   * getName //获取文件名\n   * getAbsolutePath //文件绝对路径\n   * getParent //文件的父级目录\n   * length //文件内容大小（**一个字母占一个字节，一个汉字占三个字节**）\n   * exists //文件是否存在\n   * isFile //判断是否是一个文件\n   * isDirectory //判断是否是一个目录\n\n3. 目录的操作和文件删除\n\n   * mkdir() //创建一级目录\n   * mkdirs() //创建多级目录\n   * delete() //删除空目录或文件\n\n### 2. IO流原理及流的分类\n\n#### 2.1 Java IO流原理\n\n1. IO是Input/Output的缩写，I/O技术是非常实用的技术，用于处理数据传输。如读/写文件，网络通讯等。\n2. Java程序中，对于数据的输入/输出操作以”流(stream)”的方式进行。\n3. java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过方法输入或输出数据\n\n#### 2.2 流的分类\n\n* 按操作数据单位不同分为：字节流(8bt)，字符流（按字符）\n* 按数据流的流向不同分为：输入流，输出流\n* 按流的角色的不同分为：节点流，处理流/包装流\n\n| （抽象基类） | 字节流       | 字符流 |\n| ------------ | ------------ | ------ |\n| 输入流       | InputStream  | Reader |\n| 输出流       | OutputStream | Writer |\n\n### 3. 节点流和处理流\n\n#### 3.1 介绍\n\n1. 节点流可以从一个特定的数据源读写数据，如 FileReader、FileWriter\n2. 处理流（也叫包装流）是“连接”在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，如 BufferedReader、BufferedWriter\n\n![节点流和处理流](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81-636.png)\n\nBufferedReader 类中，有属性 Reader，即可以封装一个节点流，该节点流可以是任意的，只要是Reader 的子类\n\n#### 3.2 节点流和处理流的区别和联系\n\n1. 节点流是底层流/低级流，**直接跟数据源相接**。\n2. 处理流（包装流）包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出。\n3. 处理流（也叫包装流）对节点流进行包装，使用了修饰器设计模式，**不会直接与数据源相连**\n\n#### 3.3 处理流的功能主要体现在以下两个方面：\n\n1. 性能的提高：主要以增加缓冲的方式来提高输入输出的效率。\n2. 操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便\n\n#### 3.4 对象流-ObjectInputStream 和 ObjectOutputStream\n\n序列化和反序列化\n\n1. 序列化就是在保存数据时，保存**数据的值**和**数据类型**\n2. 反序列化就是在恢复数据时，**恢复数据的值**和**数据类型**\n3. 需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：\n   * Serializable //这是一个标记接口，\n   * Externalizable //该接口有方法需要实现，因此我们一般实现上面的 Serializable 接口\n4. 序列化对象时，默认将里面所有属性都进行序列化，但除了 Static 或 [transient](java#^9da737) 修饰的成员\n5. 序列化对象时，要求里面属性的类型也需要实现序列化接口\n\n```java\n//序列化\nObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(dirsrc));\nobjectOutputStream.writeObject(dog);\nobjectOutputStream.close();\n//反序列化\nObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(dirsrc1));\nDog dog1 = (Dog) objectInputStream.readObject();\nSystem.out.println(dog1);\nobjectInputStream.close();\n```\n\n![序列化和反序列化](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-484.png)\n\n**<font color=\"red\">存储对象数据的时候，要求该对象也要实现 Serializable 接口</font>** \n\n**<font color=\"red\">反序列化的顺序需要和序列化的顺序保持一致</font>** \n\n#### 3.5 标准输入输出流\n\n|                     | 类型         | 默认设备 |\n| ------------------- | ------------ | -------- |\n| System.in 标准输入  | InputStream  | 键盘     |\n| System.out 标准输出 | OutputStream | 显示器   |\n\n#### 3.6 转换流-InputStreamReader 和 OutputStreamWriter\n\n1. InputStreamReader：\n\n   Readerl的子类，可以将 InputStream(字节流)包装成Reader(字符流)\n\n2. OutputStreamWriter：\n\n   Writer的子类，实现将OutputStream(字节流)包装成Vriter(字符流)\n\n3. 当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换成字符流\n\n4. 可以在使用时指定编码格式（比如 utf-8、gbk、gb2312、ISO8859-1 等）\n\n#### 3.7 打印流-PrintStream 和 PrintWriter\n\n**<font color=\"red\">打印流只有输出流，没有输入流</font>**\n\n### 4. 输入流\n\n#### 4.1 InputStream：字节输入流\n\n1. FilelnputStream：文件输入流\n   * read()：一次读取一个字符\n   * read(byte[] b)：一次读取b长度的字符\n2. BufferedInputStream：缓冲字节输入流\n3. ObjectInputStream：对像字节输入流\n\n#### 4.2 Reader：字符输入流\n\n1. FileReader\n   * new FileReader(File/String)\n   * read：每次读取单个字符，返回该字符，如果到文件末尾返回-1\n   * read(char[])：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1\n   * new String(char[])：将char[]转换成String\n   * new String(char[],off,len)：将char[]的指定部分转换成String\n\n### 5. 输出流\n\n#### 5.1 OutputStream：字节输出流\n\n1. FileOutputStream：文件输出流\n   * wirte(byte[] b)：一次写入b长度的字符\n   * wirte(byte[] b, int off, int len)：将 b 的 len 字节从此文件的第 off 字节开始写入\n   * write(int b)：将指定的字节写入此文件输出流。\n\n#### 5.2 Writer：字符输出流\n\n1. FileWriter\n\n   * new FileWriter(File/String)：覆盖模式，相当于流的指针在首端\n   * new FileWriter(File/String,true)：追加模式，相当于流的指针在尾端\n   * write(int)：写入单个字符\n   * write(char[])：写入指定数组\n   * write(char[],off,len)：写入指定数组的指定部分\n   * write(string)：写入整个字符串\n   * write(string,off,len)：写入字符串的指定部分\n\n   **<font color=\"red\">FileWriter使用后，必须要关闭(close)或刷新(flush)，否则要写入的数据还在内存中，没有写入到指定的文件！</font>**\n\n### 6. Properties类\n\n1. 专门用于读写配置文件的集合类\n\n   配置文的格式：`键=值`\n\n2. 键值对不需要有空格，值不需要用引号一起来。默认类型是String\n\n3. Properties 的常见方法\n\n   * load：加载配置文件的键值对到 Properties 对象\n   * list：将数据显示到指定设备\n   * getProperty(key)：根据键获取值\n   * setProperty(key,value)：设置键值对到 Properties 对象\n   * store：将 Properties 中的键值对存储到配置文件，在 idea中，保存信息到配置文件，如果含有中文，会存储为 unicode 码\n\n---\n\n## 🖇️网络编程\n\n### 1. 网络相关概念\n\n网络通信\n\n1. 概念：两台设备之间通过网络实现数据传输\n2. 网络通信：将数据通过网络从一台设备传输到另一台设备\n3. java.net包下提供了一系列的类或接口，供程序员使用，完成网络通信\n\nIP地址\n\n1. 概念：用于唯一标识网络中的每台计算机/主机\n2. 查看ip地址：ipconfig\n3. ip地址的表示形式：点分十进制 xx.xx.xx.xx\n4. 每一个十进制数的范围：0~255\n5. ip 地址的组成 = 网络地址 + 主机地址，比如：192.168.16.69\n6. iIPV6是互联网工程任务组设计的用于替代IPV4的下一代IP协议，其地址数量号称可以\n   为全世界的每一粒沙子编上一个地址\n7. 由于IPV4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPV6\n   的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联\n   的障碍\n\n域名\n\n1. www.baidu.com\n2. 好处：为了方便记忆，解决记ip的困难\n3. 概念：将ip地址映射成域名\n\n端口号\n\n1. 概念：用于标识计算机上某个特定的网络程序\n2. 表示形式：以整数形式，范围0~65535\n3. 0~1024已经被占用，比如ssh22、ftp21、smtp25、http80\n4. 常见的网络程序端口号：\n   * tomcat 8080\n   * mysql:3306\n   * oracle:1521\n   * sqlserver:1433\n\nTCP 和 UDP\n\n1. TCP 协议：传输控制协议\n   1. 使用TCP协议前，须先建立TCP连接，形成传输数据通道\n   2. 传输前，采用“三次握手”方式，是**<font color=\"red\">可靠的</font>**\n   3. TCP协议进行通信的两个应用进程：客户端、服务端\n   4. 在连接中可进行大数据量的传输\n   5. 传输完毕，需释放已建立的连接，**效率低**\n2. UDP协议：\n   1. 将数据、源、目的封装成数据包，不需要建立连接\n   2. ***<font color=\"red\">每个数据报的大小限制在64K内</font>***\n   3. 因无需连接，故是**<font color=\"red\">不可靠的</font>**\n   4. 发送数据结束时无需释放资源（因为不是面向连接的），速度快\n\n### 2. InetAddress 类\n\n相关方法\n\n1. 获取本机 InetAddress对象 getLocalHost\n2. 根据指定主机名/域名获取ip地址对象getByName\n3. 获取 InetAddress对象的主机名 getHostName\n4. 获取 InetAddress 对象的地址 getHostAddress\n\n### 3. Socket\n\n基本介绍\n\n1. 套接字(Socket)开发网络应用程序被广泛采用，以至于成为事实上的标准。\n2. 通信的两端都要有Socket，是两台机器间通信的端点\n3. 网络通信其实就是Socket间的通信。\n4. Socket:允许程序把网络连接当成一个流，数据在两个 Socket 间通过IO传输。\n5. 一般主动发起通信的应用程序属客户端，等待通信请求的为服务端\n\n当我们需要通讯时（读写数据）\n\n1. socket.getOutputStream() //读取通道数据\n\n2. socket.getlnputStream() //写入通道数据\n\n   以上都是字符流，可以使用转换流转换成字节流\n\n3. socket.shutdownOutput() //写完数据后需要告知服务器，服务器才会继续执行\n\n   writer.newLine() //插入一个换行符，同样表示写入结束标记，但服务器也需要用 read.newLine() 读取\n\n### 4. TCP网络通信编程\n\n基本介绍\n\n1. 基于客户端--服务端的网络通信\n2. 底层使用的是TCP/IP协议\n3. 应用场景举例客户端发送数据，\n4. 服务端接受并显示\n5. 基于Socket的TCP编程\n\n![socket-TCP](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/socket-TCP-6d9.png)\n\n```java\n//监听9999端口\nServerSocket serverSocket =  new ServerSocket(9999);\n//如果有客户端连接，则会返回Socket对象，程序继续\nSocket socket = serverSocket.accept();\n//连接本机9999端口\nSocket socket = new Socket(InetAddress.getLocalHost(), 9999);\n//得到和socket对象关联的输出流对象\nOutputstream outputstream =  socket.getoutputstream();\n//通过输出流，写入数据到数据通道\noutputstream.write(\"hello,server\".getBytes());\n//4.关闭流对象和socket,必须关闭\noutputstream.close();\nsocket.close();\nserverSocket.close();\n```\n\n***当客户端连接到服务端后，实际上客户端也是通过一个端口和服务端进行通讯的，这个端口是TCP/IP来分配的，是不确定的，是随机的***\n\n### 5. UDP网络通信编程[了解]\n\n基本介绍\n\n1. 类 DatagramSocket[数据报套接字] 和 DatagramPacket[数据包/数据报] 实现了基于UDP协议网络程序。\n2. UDP数据报通过数据报套接字 DatagramSocket 发送和接收，***系统不保证 UDP 数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。***\n3. DatagramPacket 对象封装了 UDP 数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。\n4. UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接\n5. UDP一个数据包最大为64k\n\n基本流程\n\n1. 核心的两个类/对象 DatagramSocket 与 DatagramPacket\n2. 建立发送端，接收端（没有服务端和客户端概念）\n3. 发送数据前，建立 数据包/报DatagramPacket 对象\n4. 调用DatagramSocket的发送、接收方法\n5. 关闭DatagramSocket\n\n```java\n//监听9999端口\nDatagramSocket datagramSocket = new DatagramSocket(9999);\nbyte[] bytes = new byte[1024];\nDatagramPacket datagramPacket = new DatagramPacket(bytes, bytes.length);\n//收到的数据传给datagramPacket\ndatagramSocket.receive(datagramPacket);\n//转成char[]\nint length = datagramPacket.getLength();\nbyte[] data = datagramPacket.getData();\n//转成字符串\nString s = new String(data);\ndatagramSocket.close();\n\n//监听9998端口\nDatagramSocket datagramSocket = new DatagramSocket(9998);\nbyte[] bytes = \"你好，大傻逼\".getBytes();\nDatagramPacket datagramPacket = new DatagramPacket(bytes, bytes.length, InetAddress.getLocalHost(), 9999);\n//发送数据\ndatagramSocket.send(datagramPacket);\n```\n\n---\n\n## 🖇️反射\n\n### 1. 反射机制❗\n\n***<font color=\"red\">设计模式的 ocp 原则，也就是开闭原则：也就是不修改源码，扩容功能</font>***\n\n1. 反射机制允许程序在执行期借助于 ReflectionAPI 取得任何类的内部信息（比如成员变量，构造器，成员方法等等)，并能操作对象的属性及方法。反射在设计模式和框架底层都会用到\n2. 加载完类之后，在堆中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，形象的称之为反射\n\n![Java程序计算机有三个阶段](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/Java%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%89%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5-07e.png)\n\n#### Java 反射机制可以完成\n\n1. 在运行时判断任意一个对象所属的类\n2. 在运行时构造任意一个类的对象\n3. 在运行时得到任意一个类所具有的成员变量和方法\n4. 在运行时调用任意一个对象的成员变量和方法\n5. 生成动态代理\n\n#### 反射相关的主要类：\n\n1. java.lang.Class：代表一个类，Class对像表示某个类加载后在堆中的对象\n2. java.lang.reflect.Method：代表类的方法，Method对象表示某个类的方法\n3. java.lang.reflect.Field：代表类的成员变量，Field对像表示某个类的成员变量\n4. java.lang.reflect.Constructor：代表类的构造方法，Constructor 对象表示构造器\n\n#### 反射优点和缺点\n\n1. 优点：可以动态的创建和使用对象（也是框架底层核心），使用灵活，没有反射机制，框架技术就失去底层支撑。\n2. 缺点：使用反射基本是解释执行，对执行速度有影响\n\n#### 反射调用优化-关闭访问检查\n\n1. Method和Field、Constructor)对象都有setAccessible()方法，setAccessible作用是启动和禁用访问安全检查的开关 \n\n   ***<font color=\"red\">可以获取私有成员，不安全但能提升效率，慎用</font>***\n\n2. 参数值为true表示反射的对象在使用时取消访问检查，提高反射的效率。参数值为falsel则表示反射的对象执行访问检查\n\n### 2. Class类❗\n\n#### 基本介绍\n\n1. Class也是类，因此也继承Object类\n2. Class类对象不是new出来的，而是系统创建的\n3. 对于某个类的Cass类对象，在内存中只有一份，因为类只加载一次\n4. 每个类的实例都会记得自己是由哪个Class实例所生成\n5. 通过Class可以完整地得到一个类的完整结构，通过一系列API\n6. Classi对象是存放在堆的\n7. 类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码，变量名，方法名，访问权限等等\n\n#### 常用方法\n\n```java\nString str = \"com.hspedu.reflection.Person\";\n//获取到Class类对象，?表示不确定的java类型\nClass<?> clazz = Class.forName(str);\nSystem.out.println(clazz);//显示该clazzi对象是哪个类的Class对象\nSystem.out.printIn(clazz.getClass());//运行类型\nSystem.out.println(clazz.getPackage().getName());\nSystem.out.println(clazz.getName());\nObject obj = clazz.newlnstance();//通过反射创建对象\nField field = clazz.getField(\"name\");//通过反射获取属性\nfield.set(obj,\"hspedu\");//通过字段对象赋值\nObject obj22=field.get(obj);//获取值\nSystem.out.println(obj2);//输出\n```\n\n#### 获取Class类对象的方式\n\n1. 前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName0获取，可能抛出ClassNotFoundException,实例：Class cls1=Class.forName(\"java.lang.Cat\")\n\n   应用场景：多用于配置文件，读取类全路径，加载类。\n\n2. 前提：若已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高实例：Class cls2 = Cat.class;\n\n   应用场景：多用于参数传递，比如通过反射得到对应构造器对象\n\n3. 前提：已知某个类的实例，调用该实例的getClass0方法获取Class对像，实例：Class clazz=对象.getClass()；\n\n   应用场景：通过创建好的对象，获取Class对象\n\n4. 其他方式\n\n   ClassLoader cl = 对象.getClass().getClassLoader();\n\n   Class clazz4 = cl.loadClass(\"类的全类名\");\n\n5. 基本数据(int,char,boolean,float,double,byte,long,short)按如下方式得到Class类对象\n\n   `Class cls = 基本数据类型.class`\n\n6. 基本数据类型对应的包装类，可以通过.TYPE得到Class类对象\n\n   `Class cls = 包装类.TYPE`\n\n#### 哪些类型有Class对象\n\n1. 外部类，成损内部类，静态内部类，局部内部类，匿名内部类\n2. interface:接口\n3. 数组\n4. enum:枚举\n5. annotation:注解\n6. 基本数据类型\n7. void\n\n### 3. 类加载❗\n\n#### 1. 基本说明\n\n反射机制是java实现动态语言的关键，也就是**通过反射实现类动态加载**。\n\n1. 静态加载：编译时加载相关的类，如果没有则报错，依赖性太强\n2. 动态加载：运行时加载需要的类，如果运行时不用该类，则不报错，降低了依赖性\n\n#### 2. 类加载时机\n\n1. 当创建对象时(new)  （静态加载）\n2. 当子类被加载时（静态加载）\n3. 调用类中的静态成员时（静态加载）\n4. 通过反射（动态加载）\n\n![类加载过程图](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%9B%BE-310.png)\n\n![类加载各阶段完成任务](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%90%84%E9%98%B6%E6%AE%B5%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1-890.png)\n\n#### 3. 类加载五个阶段\n\n##### 3.1 加载阶段\n\nJVM在该阶段的主要目的是将字节码从不同的数据源（可能是class文件、也可能是jar包，甚至网络)转化为***二进制字节流加载到内存中***，并生成一个代表该类的java.lang.Class对象\n\n##### 3.2 连接阶段-验证\n\n1. 目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全\n2. 包括：文件格式验证（是否以魔数 oxcafebabe 开头）、元数据验证、字节码验证和符号引用验证\n3. 可以考虑使用-Xverify:none 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间\n\n##### 3.3 连接阶段-准备\n\nJVM会在该阶段对静态变量，分配内存并默认初始化（对应数据类型的默认初始值，如：int是0、String是null、boolean是false等)。这些变量所使用的内存都将在方法区中进行分配\n\n```java\npublic int n1 = 10;//是实例属性，不是静态变量，因此在准备阶段是不会分配内存的\npublic static int n2 = 20;//静态变量，会分配内存，但默认是0，在初始化的时候才会重新赋值为20\npublic static final int n3 = 30;//常量，和静态变量不同，一旦赋值就不会变，所以在准备阶段就赋值为30\n```\n\n##### 3.4 连接阶段-解析\n\n虚拟机将常量池内的符号引用替换为直接引用的过程。\n\n##### 3.5 初始化\n\n1. 到初始化阶段，才真正开始执行类中定义的 java 程序代码，此阶段是执行\\<clinit>() 方法的过程。\n\n2. \\<clinit>()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并进行合并。\n\n   ***<font color=\"red\">加载顺序：加载类 --> 静态变量、静态代码块(先后顺序加载) --> 成员变量、普通代码块 --> 构造方法</font>***\n\n3. 虚拟机会保证一个类的\\<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的\\<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行\\<clinit>()方法完毕\n\n### 4. 反射获取类的结构信息❗\n\n#### 1. java.lang.Class 类\n\n1. getName：获取全类名\n2. getSimpleName：获取简单类名\n3. getFields：获取所有public修饰的属性，包含本类以及父类的\n4. getDeclaredFields：获取本类中所有属性\n5. getMethods：获取所有public修饰的方法，包含本类以及父类的\n6. getDeclaredMethods：获取本类中所有方法\n7. getConstructors：获取所有public修饰的构造器，包含本类\n8. getDeclaredConstructors：获取本类中所有构造器\n9. getPackage：以Package形式返回包信息\n10. getSuperClass：以Class形式返回父类信息\n11. getInterfaces：以Class[]形式返回接口信息\n12. getAnnotations：以Annotation[]形式返回注解信息\n\n#### 2. java.lang.reflect.Field 类\n\n1. getModifiers：以int形式返回修饰符\n\n   ***说明：默认修饰符是0，public是1，private是2，protected是4，static是8，final是16***\n\n2. getType：以Class形式返回类型\n\n3. getName：返回属性名\n\n#### 3.java.lang.reflect.Method 类\n\n1. getModifiers:以int形式返回修饰符\n\n   ***说明：默认修饰符是0，public是1，private是2，protected是4，static是8，final是16***\n\n2. getReturnType：以Class形式获取返回类型\n\n3. getName：返回方法名\n\n4. getParameterTypes：以Class[]返回参数类型数组\n\n#### 4. java.lang.reflect.Constructor 类\n\n1. getModifiers：以int形式返回修饰符\n2. getName：返回构造器名（全类名）\n3. getParameterTypes：以Class[]返回参数类型数组\n\n### 5. 反射爆破\n\n#### 1. 通过反射创建实例\n\n1. 调用类中的 public 修饰的无参构造器或者有参构造器\n\n2. Class 类相关方法\n\n   * newlnstance：调用类中的无参构造器，获取对应类的对象getConstructor(Class...clazz)：根据参数列表，获取对应的 public 构造器对象\n   * getDecalaredConstructor(Class..clazz)：根据参数列表，获取对应的所有构造器对象\n\n3. Constructor 类相关方法\n\n   * setAccessible：暴破\n\n     ```java\n     setAccessible(true);\n     ```\n\n     ***<font color=\"red\">使用反射可以访问private构造器/方法/属性</font>***\n\n   * newlnstance(Object...obj)：调用构造器\n\n#### 2. 反射访问类中的属性\n\n1. 根据属性名获取Fieldi对象\n\n   ```java\n   Field f = clazz对象.getDeclaredField(\"属性名\");\n   ```\n\n2. 暴破\n\n   ```java\n   f.setAccessible(true); //f是Field\n   ```\n\n3. 访问\n\n   ```java\n   f.set(o,值); //o表示对象\n   f.get(o); \n   ```\n\n   ***注意：如果是静态属性，则set和get中的参数o，	可以写成null***\n\n#### 3. 反射访问类中的方法\n\n1. 根据方法名和参数列表获取Method方法对象\n\n   ```java\n   //得到本类指定的方法，xxx.class是指方法中的形参类型\n   Method m = clazz.getDeclaredMethod(方法名，XX.class); \n   ```\n\n2. 获取对象\n\n   ```java\n   Object o = clazz.newlnstance();\n   ```\n\n3. 暴破\n\n   ```java\n   m.setAccessible(true);\n   ```\n\n4. 访问\n\n   ```java\n   //如果方法有返回值，那么统一返回Object，Object只是编译类型，运行类型还是返回类型\n   Object returnValue = m.invoke(o,实参列表);\n   ```\n\n   ***注意：如果是静态方法，则 invokel 的参数 o ,可以写成 null!***\n\n---\n\n## 🖇️JDBC 和 连接池\n\n### 1. 基本介绍\n\n1. JDBC为访问不同的数据库提供了统一的接口，为使用者屏蔽了细节问题。\n2. Java程序员使用JDBC，可以连接任何提供了JDBC驱动程序的数据库系统，从而完成对数据库的各种操作。\n\n```java\nClass.forName(\"com.mysql.cj.jdbc.Driver\"); //可以省略，但是不建议\nConnection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/demo\", \"root\", \"lx*0+0-0\");\nStatement statement = connection.createStatement();\nString sql = \"insert into student values(006,\'lxuan\',\'男\',\'123456\')\";\nstatement.executeUpdate(sql);\nstatement.close();\nconnection.close();\n```\n\n### 2. Statement\n\n1. Statement对象用于执行静态SQL语句并返回其生成的结果的对象\n2. 在连接建立后，需要对数据库进行访问，执行命名或是SQL语句，可以通过\n   - Statement [存在SQL注入的问题]\n   - ***PreparedStatement*** [预处理]\n   - CallableStatement [存储过程]\n3. Statementi对象执行SQL语句，存在SQL注入风险\n4. SQL注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的SQL语句段或命令，恶意攻击数据库。\n5. 要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了\n\n***<font color=\"red\">为避免产生 sql 注入问题，正常程序中我们不使用 Statement，而使用 PrepareStatement</font>***\n\n[JDBC API](assets/Java/JDBC%20API.md)\n\n### 3. 事务\n\n1. JDBC程序中当一个Connection对象创建时，***默认情况下是自动提交事务***，每次执行一个SQL语句时，如果执行成功，就会向数据库自动提交，而不能回滚。\n2. JDBC程序中为了让多个SQL语句作为一个整体执行，需要使用事务\n3. 调用`Connection的setAutoCommit(false)`可以取消自动提交事务\n4. 在所有的SQL语句都成功执行后，调用 Connection 的 `commit()` 方法提交事务\n5. 在其中某个操作失败或出现异常时，调用 Connection  的 `rollback()` 方法回滚事务\n\n### 4. 批处理\n\n1. 当需要成批插，入或者更新记录时。可以采用)va的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。\n2. JDBC的批量处理语句包括下面方法：\n   - `addBatch()`：添加需要批量处理的SQL语句或参数\n   - `executeBatch()`：执行批量处理语句\n   - `clearBatch()`：清空批处理包的语句\n3. JDBC连接MySQL时，如果要使用批处理功能，请再 url 中加参数`?rewriteBatchedStatements = true`\n4. 批处理往往和 PreparedStatement 一起搭配使用，可以既减少编译次数，又减少运行次数，效率大大提高\n\n### 5. 数据库连接池\n\n#### 5.1 基本介绍\n\n1. 预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。\n2. 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序**重复使用**一个现有的数据库连接，而不是重新建立一个。\n3. 当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列\n\n![数据库连接池](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0-3ef.png)\n\n#### 5.2 数据库连接池种类\n\n1. JDBC的数据库连接池使用javax.sql.DataSource来表示，DataSource 只是一个接口，该接口通常由第三方提供实现\n2. **C3P0** 数据库连接池，速度相对较慢，稳定性不错（hibernate,spring）\n3. DBCP 数据库连接池，速度相对c3p0较快，但不稳定\n4. Proxool 数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点\n5. BoneCP 数据库连接池，速度快\n6. ***Druid***(德鲁伊)是阿里提供的数据库连接池，集DBCP、C3P0、Proxool 优点于一身的数据库连接池\n\n#### 5.3 C3P0\n\n1. 裸连\n\n    ```java\n    ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();\n    comboPooledDataSource.setDriverClass(\"com.mysql.cj.jdbc.Driver\");\n    comboPooledDataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/demo\");\n    comboPooledDataSource.setUser(\"root\");\n    comboPooledDataSource.setPassword(\"lx*0+0-0\");\n    //初始化连接数\n    comboPooledDataSource.setInitialPoolSize(10);\n    //最大连接数\n    comboPooledDataSource.setMaxPoolSize(50);\n    Connection connection = comboPooledDataSource.getConnection();\n    System.out.println(\"连接成功\");\n    connection.close();\n    ```\n\n2. c3p0-config.xml\n\n    ```c3p0-config.xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    \n    <c3p0-config>\n       <!-- 使用默认的配置读取连接池对象 -->\n       <default-config>\n          <!--  连接参数 -->\n          <property name=\"driverClass\">com.mysql.cj.jdbc.Driver</property>\n          <property name=\"jdbcUrl\">jdbc:mysql:///bd2?serverTimezone=UTC&amp;useSSL=false</property>\n          <property name=\"user\">root</property>\n          <property name=\"password\">xxxxxxx</property>\n    \n          <!-- 连接池参数 -->\n          <!--初始化申请的连接数量-->\n          <property name=\"initialPoolSize\">5</property>\n          <!--最大的连接数量(池子中最大的数量是10个)-->\n          <property name=\"maxPoolSize\">10</property>\n          <!--超时时间3000表示，如果出错，3s后报错-->\n          <property name=\"checkoutTimeout\">3000</property>\n       </default-config>\n    \n        <named-config name=\"mysql\">\n            <!-- 配置数据库用户名 -->\n            <property name=\"user\">root</property>\n            <!-- 配置数据库密码 -->\n            <property name=\"password\"></property>\n            <!-- 配置数据库链接地址 -->\n            <property name=\"jdbcUrl\">jdbc:mysql://localhost:3306/cdcol?useUnicode=true&amp;characterEncoding=UTF-8</property>\n            <!-- 配置数据库驱动 -->\n            <property name=\"driverClass\">com.mysql.jdbc.Driver</property>\n            <!-- 数据库连接池一次性向数据库要多少个连接对象 -->\n            <property name=\"acquireIncrement\">20</property>\n            <!-- 初始化连接数 -->\n            <property name=\"initialPoolSize\">10</property>\n            <!-- 最小连接数 -->\n            <property name=\"minPoolSize\">5</property>\n            <!--连接池中保留的最大连接数。Default: 15 -->\n            <property name=\"maxPoolSize\">30</property>\n            <!--JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量。但由于预缓存的statements 属于单个connection而不是整个连接池。所以设置这个参数需要考虑到多方面的因素。如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default:0 -->\n            <property name=\"maxStatements\">0</property>\n            <!--maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数。Default: 0 -->\n            <property name=\"maxStatementsPerConnection\">0</property>\n            <!--c3p0是异步操作的，缓慢的JDBC操作通过帮助进程完成。扩展这些操作可以有效的提升性能 通过多线程实现多个操作同时被执行。Default:3 -->\n            <property name=\"numHelperThreads\">3</property>\n            <!--用户修改系统配置参数执行前最多等待300秒。Default: 300 -->\n            <property name=\"propertyCycle\">3</property>\n            <!-- 获取连接超时设置 默认是一直等待单位毫秒 -->\n            <property name=\"checkoutTimeout\">1000</property>\n            <!--每多少秒检查所有连接池中的空闲连接。Default: 0 -->\n            <property name=\"idleConnectionTestPeriod\">3</property>\n            <!--最大空闲时间,多少秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 -->\n            <property name=\"maxIdleTime\">10</property>\n            <!--配置连接的生存时间，超过这个时间的连接将由连接池自动断开丢弃掉。当然正在使用的连接不会马上断开，而是等待它close再断开。配置为0的时候则不会对连接的生存时间进行限制。 -->\n            <property name=\"maxIdleTimeExcessConnections\">5</property>\n            <!--两次连接中间隔时间，单位毫秒。Default: 1000 -->\n            <property name=\"acquireRetryDelay\">1000</property>\n            <!--c3p0将建一张名为Test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数那么属性preferredTestQuery将被忽略。你不能在这张Test表上进行任何操作，它将只供c3p0测试使用。Default: null -->\n            <property name=\"automaticTestTable\">Test</property>\n            <!-- 获取connnection时测试是否有效 -->\n            <property name=\"testConnectionOnCheckin\">true</property>\n        </named-config>\n    </c3p0-config>\n    ```\n\n#### 5.4 Druid(德鲁伊)\n\n```java\nProperties properties = new Properties();\nproperties.load(new FileReader(\"src\\\\druid.properties\"));\nDataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\nConnection connection = dataSource.getConnection();\nSystem.out.println(\"Connection Success!\");\nconnection.close();\n```\n\n```druid.properties\n# druid.properties文件的配置\n#驱动加载\ndriverClassName=com.mysql.cj.jdbc.Driver\n#注册驱动\nurl=jdbc:mysql://localhost:3306/demo?characterEncoding=utf-8\n#连接数据库的用户名\nusername=root\n#连接数据库的密码\npassword=lx*0+0-0\n#属性类型的字符串，通过别名的方式配置扩展插件， 监控统计用的stat 日志用log4j 防御sql注入:wall\nfilters=stat\n#初始化时池中建立的物理连接个数。\ninitialSize=2\n#最大的可活跃的连接池数量\nmaxActive=300\n#获取连接时最大等待时间，单位毫秒，超过连接就会失效。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降， 如果需要可以通过配置useUnfairLock属性为true使用非公平锁。\nmaxWait=60000\n#连接回收器的运行周期时间，时间到了清理池中空闲的连接，testWhileIdle根据这个判断\ntimeBetweenEvictionRunsMillis=60000\nminEvictableIdleTimeMillis=300000\n#用来检测连接是否有效的sql，要求是一个查询语句。\nvalidationQuery=SELECT 1\n#建议配置为true，不影响性能，并且保证安全性。 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis， 执行validationQuery检测连接是否有效。\ntestWhileIdle=true\n#申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。设置为false\ntestOnBorrow=false\n#归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能,设置为flase\ntestOnReturn=false\n#是否缓存preparedStatement，也就是PSCache。\npoolPreparedStatements=false\n#池中能够缓冲的preparedStatements语句数量\nmaxPoolPreparedStatementPerConnectionSize=200\n```\n\n### 6. Apache-DBUtils\n\njavaBean 一定要有无参构造器，底层使用了反射\n\n1. commons-dbutils是Apache组织提供的一个开源JDBC工具类库，它是对JDBC的封装，使用dbutils能极大简化jdbc编码的工作量\n\n* DbUtils类\n  1. QueryRunner类：该类封装了SQL的执行，是线程安全的。可以实现增、删、改、查、批处理\n  2. 使用QueryRunner类实现查询\n  3. ResultSetHandler接口：该接口用于处理java.sql.ResultSet，将数据按要求转换为另一种形式\n\n```\nArrayHandler：把结果集中的第一行数据转成对象数组。\nArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。\nBeanHandler：将结果集中的第一行数据封装到一个对应的)avaBean实例中。\nBeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。\nColumnListHandler：将结果集中某一列的数据存放到List中。\nKeyedHandler(name)：将结果集中的每行数据都封装到Map里，再把这些map再存到一个map里，其key为指定的key。\nMapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。\nMapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List\n```\n\n### 7. DAO和增删改查通用方法-BasicDao\n\n#### 基本说明\n\n1. DAO：data access object 数据访问对象\n2. 这样的通用类，称为BasicDao，是专门和数据库交互的，即完成对数据库（表）的crud操作。\n3. 在BaiscDao的基础上，实现一张表对应一个Dao，更好的完成功能，比如Customer表-Customer.java(javabean)-CustomerDao.java\n\n## 🖇️正则表达式\n\n1. `\\\\d`：表示任意一个数字\n\n   ```java\n   String regstr \"(\\\\d\\\\d)(\\\\d\\\\d)\";\n   //创建模式对象[即正则表达式对象]\n   Pattern pattern = Pattern.compile(regstr);\n   //创建匹配器matcher,按照正则表达式的规则去匹配content字符串\n   Matcher matcher = pattern.matcher(content);\n   ```\n\n2. `\\\\`：元字符-转义符：在我们使用正则表达式去检索某些特殊字符的时候，需要用到转义符号，否则检索不到结果，甚至会报错的。***<font color=\"red\">在Java的正则表达式中，两个`\\\\`代表其他语言中的一个`\\`</font>***，需要用到转义符号的字符有：`.*+()$/\\？[]^{}`\n\n3. `()`：在正则表达式中表示分组，`group(0)`表示匹配到的子字符串，`group(1)`表示子字符串终点第一组的子串...依次类推\n\n4. `matcher.find()`：根据指定的规则，定位满足规则的子字符串...\n\n5. `int groups[]`：找到后将子字符串的**开始索引**和**结束索引+1**记录到matcher的属性`int groups[]`中...\n\n6. `oldLast`：同时记录oldLast的值为子字符串的`结束索引+1`的值，即下次执行find时，就从oldLast的索引开始匹配\n\n### 1. 基本介绍\n\n如果要想灵活的运用正则表达式，必须了解其中各种元字符的功能，元字符从功能上大致分为：\n\n1. 限定符：用于指定其***前面的字符或组合项***连续出现多少次\n\n   | 符号  |              解释               |    示例     |                        解释                        |\n   | :---: | :-----------------------------: | :---------: | :------------------------------------------------: |\n   |   *   | 指定字符重复0次回或n次（无要求) |   (abc)*    |         仅包含任意个abc的字符串，等效于\\w*         |\n   |   +   | 指定字符重复1次或n次（至少一次) |  m+(abc)*   |       以至少1个m开头，后接任意个abc的字符串        |\n   |   ?   | 指定字符重复0次或1次（最多一次) |   m+abc?    |         以至少1个m开头，后接ab，c可有可无          |\n   |  {n}  |         只能输入n个字符         |  [abcd]{3}  |       由abcd中字母组成的任意长度为3的字符串        |\n   | {n,}  |         指定至少n个匹配         | [abcd]{3,}  |     由abcd中字母组成的任意长度不小于3的字符串      |\n   | {n,m} |   指定至少n个但不多于m个匹配    | [abcd]{3,5} | 由abcd中字母组成的任意长度不小于3，不大于5的字符串 |\n\n   |  ?   | 当此字符紧随任何其他限定符(*、+、？、{n}、{n,}、{n,m})之后时，匹配模式是\"非贪心的。\"非贪心的\"模式匹配搜索到的、尽可能短的字符串，而默认的\"贪心的\"模式匹配搜索到的、尽可能长的字符串。例如，在字符串\"oooo\"中，\"o+?\"只匹配单个\"o”,而\"o+\"匹配所有\"o\"。 |\n   | :--: | :----------------------------------------------------------: |\n\n   ***Java 默认是贪婪匹配，{n,m}优先匹配 m 个***\n\n2. 选择匹配符\n\n   | 符号 |            解释            |  示例  |   解释   |\n   | :--: | :------------------------: | :----: | :------: |\n   |  \\|  | 匹配“\\|”之前或之后的表达式 | ab\\|cd | ad或者cd |\n\n3. 分组组合和反向引用符\n\n   | 常用分组构造形式  |                             说明                             |\n   | :---------------: | :----------------------------------------------------------: |\n   |     (pattern)     | 非命名捕获。捕获匹配的子字符串。编号为零的第一个捕获是由整个正则表达式模式匹配的文本，其它捕获结果则根据左括号的顺序从1开始自动编号。 |\n   | (?\\<name>pattern) | 命名捕获。将匹配的子字符串捕获到一个组名称或编号名称中。用于name的字符串不能包含任何标点符号，并且不能以数字开头。可以使用单引号替代尖括号，例如(?\'name\') |\n   |    (?:pattern)    | 匹配pattern但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用\"or\"字符(\\|)组合模式部件的情况很有用。<br/>例如，`industr(?:y|ies)`是比`industry|industries`更经济的表达式。 |\n   |    (?=pattern)    | 它是一个非捕获匹配。例如，`Windows(?=95|98|NT|2000)`匹配`Windows 2000`中的`Windows`，但不匹配`Windows 3.1`中的`Windows`。 |\n   |    (?!pattern)    | 该表达式匹配不处于匹配pattern的字符串的起始点的搜索字符串。它是一个非捕获匹配。例如，`Windows(?!95|98|NT|2000)`匹配`Windows 3.1`中的`Windows`，但不匹配`Windows 2000`中的`Windows`。 |\n\n3. 特殊字符\n\n4. 字符匹配符\n\n   | 符号 |                             解释                             |    示例    |                             解释                             |\n   | :--: | :----------------------------------------------------------: | :--------: | :----------------------------------------------------------: |\n   | [ ]  |                       可接收的字符列表                       |   [abcd]   |                寻找a、b、c、d中的任意一个字符                |\n   | [^]  |                       不接收的字符列表                       |  [^abcd]   |    寻找除了a、b、c、d中的任意一个字符，包括数字和特殊字符    |\n   |  -   |                            连字符                            |    A-Z     |                       任意单个大写字母                       |\n   |  .   |   匹配除 \\n 以外的任何字符，如果需要匹配.自身，需要使用\\\\.   |   a...b    |     以a开头，b结尾，中间包括3个任意字符的长度为5的字符串     |\n   |  \\d  |             匹配单个数字字符，相当于<br />[0-9]              | \\d{3}(\\d)? | 包含3个或4个数字的字符串<br />**?的意思是：?前的一个或一组符号可能有也可能没有** |\n   |  \\D  |           匹配单个非数字字符，相当于<br />[\\^0-9]            |  \\D(\\d)*   |   以单个非数字字符开头，后接任意个数字（任意个可以为0个）    |\n   |  \\w  | 匹配单个数字、大小写字母、下划线字符相当于<br />[0-9a-zA-Z]  | \\d{3}\\w{4} |         以3个数字字符开头的长度为7的数字和字母字符串         |\n   |  \\W  | 匹配单个非数字、大小写字母、下划线字符，相当于<br />\\[^0-9a-zA-Z] |  \\W+\\d{2}  | 以至少1个非数字字母字符开头，2个数字字符结尾的字符串<br />**+指的是：+号前的一个或一组符号至少存在一次** |\n   |  \\s  |              匹配任何空白字符（空格，制表符等）              |            |                                                              |\n   |  \\S  |                     匹配任何非空空白字符                     |            |                                                              |\n\n5. 定位符\n\n   | 符号 |          解释          |       示例       |                             解释                             |\n   | :--: | :--------------------: | :--------------: | :----------------------------------------------------------: |\n   |  ^   |      指定起始字符      |  \\^[0-9]+[a-z]*  |        以至少1个数字开头，后接任意个小写字母的字符串         |\n   |  \\$   |      指定结束字符      | \\^[0-9]\\\\-[a-z]+$ | 以1个数字开头后接连字符”-”，并以至少1个小写字母结尾的字符串  |\n   |  \\b  |  匹配目标字符串的边界  |     lxuan\\b      | 这里说的字符串的边界指的是子串间有空格，或者是目标字符串的结束位置 |\n   |  \\B  | 匹配目标字符串的非边界 |     lxuan\\\\B     |                      和b的含义刚刚相反                       |\n\n\n### 2. 分组、捕获、反向引用\n\n1. 分组\n\n   我们可以用圆括号组成一个比较复杂的匹配模式，那么一个圆括号的部分我们可以看作是一个子表达式/一个分组。\n\n2. 捕获\n\n   把正则表达式中子表达式/分组匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用，从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。组0代表的是整个正则式\n\n3. 反向引用\n\n   圆括号的内容被捕获后，可以在这个括号后被使用，从而写出一个比较实用的匹配模式，这个我们称为反向引用，这种引用既可以是在正则表达式内部，也可以是在正则表达式外部，内部反向引用`\\\\分组号`，外部反向引用`$分组号`\n\n   ```正则\n   1.要匹配两个连续的相同数字：(\\d)\\1\n   2.要匹配五个连续的相同数字：(\\d)\\1{4}\n   3.要匹配个位与干位相同，十位与百位相同的数5225,1551：(\\d)(\\d)\\2\\1\n   ```\n\n\n### 3. 正则表达式三个常用类\n\n1. Pattern类\n\n   pattern对象是一个正则表达式对象。Pattern类没有公共构造方法。要创建一个Pattern对象，调用其公共静态方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数，比如：Pattern r = Pattern.compile(pattern);\n\n   `Pattern.matches()`：是否为整体匹配\n\n2. Matcher类\n\n   Matcher对象是对输入字符串进行解释和匹配的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象\n\n3. PatternSyntaxException\n\n   PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误。\n\n---', 1, '', 0, 0, 1, '2022-10-11 19:25:52', '2022-10-11 19:41:18');
INSERT INTO `tb_article` VALUES (75, 1, 188, 'http://figurebed-1311634249.cos.ap-beijing.myqcloud.com/articles/9cdd0d0402007823150b1db80244cf0c.jpg', '软件项目管理', '# 1 选择题\n\n1. 下列工作中不属于项目的是\n   - [ ] A.策划一场婚礼\n   - [ ] B.开发一款软件\n   - [x] C.为人民服务\n   - [ ] D.主持一场会议\n\n2. 下列不属于项目特性的是\n   - [ ] A.一次性  \n   - [x] B.新颖性 \n   - [ ] C.目标性  \n   - [ ] D.约束性\n\n3. 项目管理的对象集中在对3P的管理，下列不属于3P的是\n   - [ ] A.人员  \n   - [ ] B.问题  \n   - [ ] C.过程  \n   - [x] D.保证\n\n4. 项目管理需要在互相间有冲突的要求中找到平衡，除了以下哪个\n   - [x] A.甲方和乙方的利益          \n   - [ ] B.范围、时间、成本、质量\n   - [ ] C.有不同项目需求和期望的项目干系人 \n   - [ ] D.明确和未明确表达的需求\n\n5. 项目管理中的三种组织结构，哪一种沟通最为复杂\n   - [ ] A.职能型  \n   - [ ] B.纯项目 \n   - [x] C.矩阵型  \n   - [ ] D.都一样\n\n6. 项目经理的职责不包括以下哪项内容\n   - [ ] A.开发计划   \n   - [ ] B.组织实施  \n   - [ ] C.项目控制  \n   - [x] D.系统支持\n\n7. 可以构建一部分系统的模型，通过用户试用提出优缺点，最好选择（）生存期模型 \n   - [ ] A.增量式模型  \n   - [x] B.原型    \n   - [ ] C.螺旋型    \n   - [ ] D.v模型\n\n8. 乙方在项目初始阶段的主要任务不包含以下哪一项\n   - [ ]   A.项目分析   \n   - [ ] B.招投标   \n   - [x] C.合同管理   \n   - [ ] D.合同签署\n\n10. 需求分析完成的标志是\n    - [ ] A.开发出初步模型   \n    - [x] B.提交一份完整的软件需求规格说明书\n    - [ ] C.提交一份工作称述  \n    - [ ] D.提交项目章程\n\n11. WBS中的每一个具体细目通常都指定唯一的\n    - [x] A.编码  \n    - [ ] B.责任人  \n    - [ ] C.功能模块  \n    - [ ] D.提交日期\n\n12. 项目计划方法中，（）是能直观的表达软件开发众多工序之间的逻辑关系与时间关系。 \n    - [ ] A.滚动计划法  \n    - [ ] B.工作结构分解 \n    - [x] C.网络计划技术 \n    - [ ] D.构造性成本法\n\n13. 代码行估算方法属于以下基本估算方法中的哪一种。（）\n    - [x] A.分解法    \n    - [ ] B.算数模型    \n    - [ ] C.专家判断   \n    - [ ] D.比例法\n\n14. 在项目估算的基本内容中，（）是软件项目量化的结果，很大程度上代表了项目范围的大小。\n\n    - [ ] A.风险估算  \n\n    - [ ] B.工作量估算 \n\n    - [x] C.规模估算  \n\n    - [ ] D.其他估算\n\n15. 下列不属于按照详细情况划分的3个等级构造性成本模型的是（）\n    - [ ] A.基本 COCOMO    \n    - [ ] B.中间 COCOMO \n    - [x] C.发展 COCOMO    \n    - [ ] D.详细 COCOMO\n\n16. 项目管理人员根据个人能力、是否有空闲时间进行项目活动人员分配时有A、P、R、S 四种类别，其中A表示（）\n    - [x] A.负责    \n    - [ ] B.参与   \n    - [ ] C.检查    \n    - [ ] D.批准\n\n17. 压缩软件项目的工期时，你应该关注（）\n    - [x] A.关键路径  \n    - [ ] B.非关键路径  \n    - [ ] C.准关键活动  \n    - [ ] D.活动缓冲期\n\n18. “软件编码完成之后，我才可以对它进行软件测试”这句话体现了项目活动之间的哪种关系\n    - [ ] A.开始-开始   \n    - [x] B.结束-开始   \n    - [ ] C.结束-结束   \n    - [ ] D.开始-结束\n\n19. 在成本管理过程中，项目经理确定的每个时间段，各个工作单元的成本是\n    - [ ] A.估算    \n    - [ ] B.预算     \n    - [x] C.直接成本   \n    - [ ] D.间接成本\n\n20. 估算文件不属于以下哪一项\n    - [x] A.功能模块  \n    - [ ] B.质量标准  \n    - [ ] C.资源及数量   \n    - [ ] D.估算成本\n\n21. 下列不属于软件评审方法的是\n    - [ ] A.同行评审   \n    - [ ] B.走查     \n    - [ ] C.会议审查    \n    - [x] D.测试\n\n22. 软件项目质量的组织保证是\n    - [ ]  A.顾客     \n    - [ ] B.用户     \n    - [ ] C.提供者     \n    - [x] D.SEPG组\n\n23. 项目质量管理的最终责任由谁来承担\n    - [ ] A.项目开发经理        \n    - [ ] B.质量经理\n    - [ ] C.采购经理          \n    - [x] D.项目经理\n\n24. “质量成本”是一个项目管理概念，它说明了下列哪项成本\n    - [x] A.额外需求的成本      \n    - [ ] B.需求变更的成本\n    - [ ] C.确保符合需求的成本    \n    - [ ] D.固定成本\n\n25. 软件项目的一个重要特点是需求变更频繁，在项目管理中缺乏有效的需求变更控制流程就极有可能引起项目风险。若按照风险来源的阶段对风险进行分类，这种项目风险属于\n    - [x] A.需求风险  \n    - [ ] B.设计风险   \n    - [ ] C.编程风险    \n    - [ ] D.维护风险\n\n26. 在风险分析过程中，确定已经识别的一个风险事件是无法避免的，也是不能减轻的，也不能投保，这是一个关键的风险事件，一旦发生可能造成项目的失败，项目经理最佳的选择是\n    - [ ] A.降低风险的级别，项目团队将找到一个克服故障的方法\n    - [x] B.特别关注，加强管理该风险事件和所有的相关事件\n    - [ ] C.让风险评估小组继续分析该风险事件，直到降低预期影响\n    - [ ] D.忽略风险评估，因为不管赋予什么值，都只是一个估算\n\n27. 风险的三个属性是\n    - [ ] A.风险发生的时间、地点、责任人 \n    - [ ] B.风险事件、时间、影响\n    - [x] C.风险事件、概率、影响 \n    - [ ] D.风险数量、风险影响程度、概率\n\n28. 下列哪项不是风险管理的过程\n    - [ ] A.风险评估  \n    - [ ] B.风险识别   \n    - [ ] C.风险规划   \n    - [x] D.风险收集\n\n29. 由于政府的一项新规定，某项目的项目经理必须变更该项目的范围。项目目标已经做了若干变更，项目经理已经对项目的技术和管理文件做了必要的修改，他下一步应该\n    - [x] A.及时通知项目干系人     \n    - [ ] B.修改公司的知识管理体系\n    - [ ] C.获取客户的正式认可    \n    - [ ] D.获得政府认可\n\n30. 小王负责一个管理信息系统项目，最近在与客户共同进行的质量审查中发现一个程序模块不符合客户的需求，进行追溯时，也未发现相应的变更请求。最终小王被迫对这一模块进行再设计并重新编程，造成此项返工的原因可解是\n    - [ ] A.未进行需求变更      \n    - [x] B.未进行范围确认 \n    - [ ] C.未进行变更管理      \n    - [ ] D.质量管理过严\n\n31. 客户已经正式接收了项目，该项目的项目经理下一步工作将是\n    - [x] A.适当的将接收文件分发给其他项目干系人\n    - [ ] B.将项目总结向项目档案库归档\n    - [ ] C.记录你与小组成员获得的经验 \n    - [ ] D.进行项目审计\n\n32. 在某个信息系统项目中，存在新老系统切换问题，在设置项目计划网络图时，新系统上线和老系统下线之间应设置成（）的关系。\n    - [ ] A.结束—开始(FS型)      \n    - [ ] B.结束—结束(FF型)\n    - [x] C.开始—结束(SF型)     \n    - [ ] D.开始一开始(ss型)\n\n33. 质量控制是\n    - [ ] A.对每个工作包增加工作时间 \n    - [x] B.项目生存期的各个阶段都要实施的\n    - [ ] C.只需要做一次         \n    - [ ] D.只有大的项目才需要\n\n34. 采用网络模型反向遍历的目的在于决定（）\n    - [ ] A.关键路径          \n    - [ ] B.最早完工日期\n    - [x] C.最迟开始日期        \n    - [ ] D.赶工日期\n\n35. 激励中的期望理论认为\n    - [ ] A.相信付出的努力很可能会产生成功的结果\n    - [ ] B.管理者不应对工人寄望过高\n    - [x] C.激励应与期望中具有价值的产出相关联\n    - [ ] D.管理者不应期望薪水高的雇员工作更努力\n\n36. 制定项目计划时，首先应该关注的是\n    - [x] A.项目范围说明书        \n    - [ ] B.工作分解结构 \n    - [ ] C.风险管理计划        \n    - [ ] D.质量计划\n\n37. 在进度可视化监控方法中，哪一种方法能简单、清除地展示项目整体进度\n    - [ ] A.延迟图  \n    - [ ] B.时间线   \n    - [x] C.甘特图   \n    - [ ] D.计划与实际对比图\n\n38. 在项目进行过程中，一个开发人员接到某个用户的电话，用户要求更改系统中存在的一个问题，这个开发人员应该\n    - [ ] A.马上改正问题   \n    - [x] B.记录问题并提交项目经理\n    - [ ] C.不予理睬     \n    - [ ] D.通过测试部经理，要求确认问题是否存在\n\n39. 下面哪一种质量改进方法最不可能产生积极结果\n    - [ ] A.持续改进   \n    - [ ] B.统计质量过程   \n    - [ ] C.客户跟踪过程   \n    - [x] D.增加检验\n\n40. 项目的项目范围已经发生变更，因此成本基线也将发生变更，项目经理需要尽快\n    - [ ] A.进行范围变更策略     \n    - [ ] B.更新预算\n    - [ ] C.记录获得经验      \n    - [x] D.执行得到批准的范围变更\n\n# 2 填空题\n\n1.  项目管理的基本内容是计划、组织和（**监控**）\n\n2. 根据项目管理方法论可以将项目管理分为阶段化管理、（**量化管理**）和优化管理，\n\n3. 影响项目可行性的因素可分为:经济可行性、技术可行性、（**风险和不确定性**）。\n\n4. 由于项目的组织结构中职能型和纯项目型的两个极端代表，为了综合它们各自的优势,（**矩阵型**）应用而生，他是职能型和纯项目型的结合体。\n\n5. 滚动计划法是一种迭代方法，它具有分而治之、（**逐步求精**）、动态规划、和谐过渡的特点。\n\n6. （**WBS 工作分解结构**）是一种将复杂问题分解为简单问题，然后再根据分解的结果进行计划的方法。\n\n7. WBs 最低层次的项目可交付成果称为（**工作包**）。\n\n8. （**德尔菲法**）是一种专家评估技术，适用于在没有或者没有足够历史数据的情况下，来评定软件采用不同的技术或新技术带来的差异，但专家的水平及对项目的理解程度是工作中的关键点。\n\n9. 里程碑事件的工期一般设置为（**零**）\n\n10. 在ADM 网络图中，有时为了表示逻辑关系，需要设置一个虚活动，虚活动是不需要时间和资源的，一般用（**虚箭线**）表示:\n\n11. （**里程碑**）定义了当前阶段完成的标准和下阶段启动的前提或条件。\n\n12. （**质量计划**）是进行项目质量管理、实现项目质量方针和目标的具体体现。\n\n13. （度量）提供了对项目进度评估、质量状况的洞察力和用于决策的有关数据。\n\n14. （**风险评审技术**）是为了适应某些有高度不确定性和风险性的决策问题而开发一种网络仿真系统。\n\n15. 外包是（**风险转移**）类型的风险处理策略。\n\n16. 涉及多个领域工作的复杂项目最好采用（**矩阵型组织**）来管理。\n\n17. 软件开发中大多数的变更都是来源于（**需求变更**）。\n\n18. （**收尾**）是项目生命周期的最后一个阶段，也是形成产品闭环的关键步骤。\n\n19. 马斯洛需求层次论把需求分为生理需求、安全需求、社会需求、尊重需求、（**自我实现需求**）。\n\n20. 良好的工作氛围概括起来就是：开放、（**真诚**）、平等、信任。\n\n# 3 判断题\n\n1. 受控环境中的项目是组织、管理和控制项目的方法，强调通过管理方法使项目环境得到控制。      （√）\n2. 软件不同于一般的传统的产品，它是对物理世界的一种抽象，是逻辑性、知识性的产物。        （√）\n3. 项目管理的核心是成本。  （×）\n4. 根据项目管理方法论可以将项目管理分为阶段化管理、量化管理和优化管理，其中量化管理是项目管理的基本方法。 （×）\n5. 项目建议书必须尽可能的详细。（×） \n6. 项目可行性分析是项目启动阶段的关键活动，旨在判断一个项目是否值得做或者是挑选许多待选项目中的最佳项目。 （√）\n7. 投资回收期分析法是经济可行性分析中最可靠的方法。（×）\n8. 极限编程的基本思想是“沟通、简单、反馈、勇气”。（√）\n9. WBS最底层的项目只能由一人负责。（√）\n10. 在软件项目管理中，计划编制是最复杂的阶段，却经常不受重视。（√）\n11. 软件项目的项目计划可以由一个人独立完成，不需要与项目干系人沟通。（×）\n12. PMBOK 将项目计划过程分为核心过程和辅助过程两个部分。（√）\n13. 软件估算的方法有许多，可以分为直接方法和间接方法，如功能点估算方法就是软件规模估算中的直接方法。（×）\n14. 软件项目的估算结果都是比较准确地。（×）\n15. 在进行软件项目估算时，可以参照其他企业的估算模型。（√）\n16. 成本估算一般情况下都可能不是非常精确，尤其是软件项目更是如此。（√）\n17. 甘特图可以显示任务的基本信息，使用甘特图能方便地查看任务的工期，开始和结束时间以及资源的信息。（√）\n18. 为了得到一个相对准确的估算结果，项目管理者应该系统的学习相关的成本（√）\n19. IT项目尤其是软件项目的成本管理一直没有一个好的口碑，但成本超支很少见。()错\n20. 成本估算不准确有很多原因，有主观原因也有客观原因。（√）\n21. PSP 指软件工程过程组，其要质量目标是编译和单元测试之前发现和修复缺陷。()错\n22. 产品的缺陷密度或者测试阶段的缺陷率是概括性指标。（√）\n23. 软件度量主要包括3部分:项目度量、产品度量和过程度量（√）\n24. 鱼骨图分析方法要完成从小刺到主刺的思维和分析过程。（×）\n25. TOP风险清单中的条目越多越好。（×）\n26. 风险识别、风险评估、风险规划、风险控制是风险管理的四个过程。（√）\n27. 当风险发生的概率极高、风险后果影响很严重时，才可以考虑采用回避风险策略。（×）\n28. 风险是损失发生的不确定性，是对潜在的、未来可能发生损害的一种度量。（√）\n29. 在当今高科技环境下，x理论和期望理论可以用来激励一个团队员工的工作士气。（×）\n30. 在项目早期和信息不足的时候，可以采用自下而上的估算方法进行成本估算。（×）\n31. 需求分析过程是确定项目如何实现的过程，并确定项目的技术方案（×）\n32. 软件项目的估算结果是比较准确的。（×）\n33. 基线产品是不能修改的。（×）\n34. 在 IT 项目中，许多专家都认为：对于成功，威胁最大的就是沟通的失败。（√）\n35. 采购是为了换行项目而从项目团队外部采购或者获取产品、服务或者结果的过程。（√）\n36. 进度和成本是关系最为老切的两个目的，几乎成了对立关系，进度的缩短一定依靠增加成本实现，而成本的降低也一定牺牲工期进度为代价的。（×）\n37. 项目早期和信息不足的时候，可以采用自下而上的估算方法进行成本估算（×）\n38. 统计需求变更请求的数量是配置审核过程。（√）\n39. 质量保证属于检查职能，而质量控制属于管理职能。（×）\n40. 采用德尔菲方法来标识风险可以减少人为的偏差，以便作出正确决定（√）\n41. 取消采用具有高风险的新技术，而采用原来热悉的技术\"是一种转移风险的规划策略（√）\n\n# 4 简答题\n\n1. **项目生命周期分为5个阶段，请简要概述（P6）**\n\n   1. 启动。项目获得授权正式被**立项，并成立项目组**，宣告项目开始。启动是一种认可过程，用来正式认可一个新项目或新阶段的存在。\n   2. 计划。**明确项目范围**，定义和评估项目目标，选择实现项目目标的最佳策略，**制订项目计划。**\n   3. 执行。调动资源，**完成项目管理计划中确定的工作**。\n   4. 控制。**监控和评估项目偏差**，必要时采取纠正行动，以**保证项目计划的执行**，**实现项目目标**。\n   5. 结束。**完成项目验收**，使其按程序结束。\n\n2. **简述 WBS 制定的原则。**\n\n   1. 某项具体的任务应该在一个工作包且只能在一个工作包中出现\n   2. WBS中某项任务的内容是其下所有WBS项的总和\n   3. 一个工作包只能由一个人负责\n   4. 任务的分解，尽量与实际执行方式保持一致。\n   5. 分解合理，具有良好的稳定性和适应性\n   6. 鼓励项目团队成员积极参与创建WBS\n   7. 所有成果需要文档化\n\n3.  **什么是质量管理，软件质量管理的保证组织有哪些?** \n\n   质量管理是指：确定质量方针、目标和职责并在质量体系中通过质量计划、质量控制、质量保证和质量改进使其实施的全部管理职能的所有活动。\n\n   1、采用技术手段和工具；2、组织正式技术平时；3、加强软件测试；4、推行软件工程规范（标准）；5、对软件的变更进行控制；6对软件质量进行度量。\n\n4. **简述应对风险的基本措施?**\n\n   1. 规避。通过变更项目计划消除风险或风险的触发条件，使目标免受影响。\n   2. 转移。不能消除风险，而是将项目风险的结果连同应对的权利转移给第三方。\n   3. 弱化。将风险时间的概率或结果降低到一个可以接受的程度，其中降低发生的概率更为有效。\n   4. 接受。不改变项目计划，而考虑发生后如何应对\n\n5. **风险监控的措施有哪些?**\n\n   1. 风险识别\n   2. 风险估计 \n   3. 风险管理策略 \n   4. 风险解决 \n   5. 风险监控\n\n6. **如何确保知识经验共享?**\n\n   1. 企业角度\n\n      要先提倡和强调重要性。\n\n      其次要确立正确而鼓舞人心的知识管理愿景和战略目标。\n\n      再次要建立指导监督团队来提供足够的推动力。\n\n      激励知识共享的贡献者。\n\n   2. 个人角度\n\n      做到无私奉献，无偿分享。\n\n      积极参与知识的分享和讨论，在讨论中不断学习、相互提高，真正实现从知识到能力的跨越。\n\n7. 什么是绩效管理？如何做好绩效管理？\n\n   所谓绩效管理就是企业为了持续发展及保持良好的发展趋势，为了提高业绩与效率，制定一定的激励方式，让员工可以按时完成任务，整体提高员工工作积极性和提高企业产能。\n\n    1、绩效管理准备工作\n\n    2、明确绩效分工流程\n\n   3、做好绩效管理方案\n\n   4、绩效管理的反馈\n\n   5、绩效管理的改进\n\n   6、绩效管理的维护及存档\n\n8. 如何在项目监控阶段，区分缺陷的优先级和重要性？\n\n​			1. 缺陷跟踪\n\n​			2. 技术检查\n\n​			3. 源代码追踪\n\n​			4. 测试\n\n9. 简述项目验收的内容\n\n​			1. 软件系统验收\n\n​			2. 质量验收\n\n​			3. 资料验收\n\n10. 在进行项目总结时，应该注意哪些问题？\n\n​			1. 项目概况，质量结果分析；\n\n​			2. 项目进展情况；\n\n​			3. 好的经验；\n\n​			4. 不足之处；\n\n​			5. 改进方案和建议。\n\n# 5 计算器\n\n一、一个软件企业现在面对两个项目的选择\n\n一个软件企业现在面对两个项目的选择。他们经过分析得得出这样的结论:如果做项目A，盈利的概率是20%，可以盈利30万元，但是同时亏损的概既率是80%，亏损4万元;如果做项目B.盈利的概率是70%，盈利6万元，但同时有两种亏损的可能，其一是10%的概率亏损2万，其二是20%的概率亏损5万。请用决策树的方法计计算出两个项目的预期收益，并判断哪个项目是比较有利的选择。\n\n（1）：该企业两个项目的决策树如下：\n\n![image-20221101235338174](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%80%83%E8%AF%95/image-20221101235338174-d92.png)\n\n---\n\n一、阅读以下说明，回答问题1至问题3。\n\n某信息系统集成企业承担了甲方的信息系统集成项目，在项目的采购过程中，某项采购合同是在甲方的授意下签订的，然而在项目进展过程中，项目经理发现该采购产品高于市场价格，而且有些性能指标也没有能够完全满足合同规定要求。当项目经理发现此类问题进行调查时，发现该供应商的资质和声誉都存在问题，并且就在不久前已经被其他公司并购，最麻烦的是合同的付款条件是提前支付相关款项，合同的大部分采购款已经支付。\n\n在项目的中期验收中，甲方发现了部分采购产品存在的问题，并要求项目组进行返工和更换相关产品。项目经理则以采购供应商是由甲方推荐为由，拒绝进行返工和更换。而甲方则认为，项目合同里面并没有规定由甲方承担采购责任，甲方只是为项目组推荐了部分供应商，而供应商已被收购，原先的公司已经不存在，原先的责任人已经离职为由，拒绝根据合同相关条款更换产品，项目经理对此束手无策。项目经理和甲方就该问题相持不下，项目处于停滞状态。\n\n1. 问题1结合案例，请指出项目组在采购合同管理中存在什么问题?\n\n   1. **合同签订有问题，不应轻易采用甲方的推荐。**\n   2. **合同支付条款不合理。**\n   3. **合同执行有问题，设备指标不满足要求时，未能及时有效的管控。**\n   4. **合同变更问题，供应商被并购以后，合同没有及时变更相应条款。**\n\n2. 问题2在采购合同中，支付方式的规定一般包括哪些方面的内容?甲方的做法是否妥当，是分散否该为此承担主要责任?\n\n   1. **支付方式的内容**\n   2. **支付货款的条件**\n   3. **结算支付的时限、方式**\n   4. **拒付货款。发包方有权部分或全部拒付货款**\n   5. **甲方的做法不妥当。不应该承担主要责任。**\n\n3. 问题3供应商是否可以以公司变更、负责人离职为由，拒绝履行公司变更前签订的协议?为什么?对此而日经那该加何外开?\n\n   **不可以。因为供应商公司变更不影响其对已经售出的货物的质量保证义务，新公司需要继续履行原供应商签订的协议。项目经理可以启动索赔程序。先进行调解，调解不成，由经济合同仲裁委员会进行调解或仲裁。**\n\n---\n\n二、在项目的中期验收中，甲方发现了部分采购产品存在的问题，并要求项目组选行返工和更换相关产 品。项目经理则以采购供应商是由甲方推荐为由，拒绝送行返工和更换。而甲方则认为，项目合同里 面并没有规定由甲方系担采购责任，甲方只是为项目组推荐了部分供应商，而供应南己枝收购，原先 的公司己经不存在，原先的责任人已经高职为由，拒绝根据合同相关条款更换产品，项目经理对此束 手无策。项目经理和甲方就该问题相持不下，项目处手停滞状态。 \n\n问题 1 结合案例，请指出项目组在采购合同管理中存在什么问题？ \n\n**1）合同签订有问题，不应经易采用甲方的推荐。2）合同支付条款不合理。3）合同执行有问题，设备 指标不满足要求时，未能及时有放的管拉。4）合同支更问题，供应商被并购以后，合同没有及时变更 相应条款。** \n\n问题 2 在采购合同中，交付方式的规定一般包括哪些方面的内容？甲方的做法是否妥当，是否该为比 承担主要贡任？ \n\n**支付方式的内容：1）支付货款的条件：2）结算支付的时限、方式：3）拒付货款。发包方存权部分或 全部柜付货款。4）平方的做法不妥当，不应该承担主要责任。**\n\n问题 3 供应商是否可以以公司变更、众责人离职为由，拒绝履行公司变更前签订的协议？为什么？对 此项目经理该如何处理？ \n\n**不可以。因为供应商公司变更不影响其对己经售出的货物的质量保证义务，新公司需要继续履行原供 应商签订的协议。 项目经理可以启动索赔程序。先进行调解，阔解不成，由经济合同仲教委员会选行调解或仲裁。**\n\n---\n\n三、软件项目需求变更\n\n1. 提出变更\n2. 评估变更\n3. 决策变更\n4. 实施变更\n5. 验证变更\n\n---\n\n四、阅读以下说明，回答问题1至问题 3。\n\n某创业型公司乙在2015年1月，凭借着报价低的优势中标承接了一个信息系统工程项目。项目建设内容主要包括建设方甲公司的北京总公司ERP信息系统建设，以及甲公司成都分公司的机房改造项目。甲乙两公司协商签订了工程额为100万元的总价合同，工期为一年。乙公司指派有过ERP项目经验的张工承担项目经理，因公司还处于创业期间，所以公司管理层非常注重成本的控制，要求项目经理严格控制成本，每周汇报项目的实际花费。为了满足\n\n低成本的要求，考虑到北京、成都两地的材料、差旅费用等问题，在征得甲公司与管理层的同意后，张工将机房改造工程外包给成都当地的丙公司，并在合同中要求丙公司必须在2015年底之前完工。\n\n项目执行期间。张工指派了一名成本控制专员，负责每周统计该项目ERP 部分所发生的费用。同时向管理层提交费用统计报告。项目进展到6月份。项目 ERP 部分实际发生的总费用为30 万元。成都赶上了梅雨季节，丙公司反馈因机房处于某大厦的低层，太潮湿，机房改造工程被迫暂停。待梅雨季节过后继续施工。\n\n项目执行到2015年底，机房改造项目已确定无法在2016年1月如期完工，ERP部分虽然基本到了后期的测试阶段，但其总费用也已经达到了 60 万元。\n\n问题1根据案例，2016年1月机房改造工程无法如期完工，请指出乙公司是否可以向丙公司索赔?如可以，请说明可以申请什么索赔?如不可以，请说明理由。\n\n**可以索赔。可以申请延长工期索赔。 (机房改造属于室内施工，雨季不是进度延期的不可抗因素)**\n\n问题2结合以上案例，请帮助张工提出成本管理及成本控制方面的改进措施。\n\n**1.根据项目实际情况，制定成本管理计划，并得到公司高层批准。2、采用科学方法对项目进行成本估算和预算。 3、按计划掌握项目实际成本支出情况(包括北京、成都两地)。4将实际成本与成本计划进行比较，掌握项目成本绩效。 5、如果实际成本不符合计划，则进行偏差分析，制定相关纠偏措施。 6、做好相关文档的记录和存档。**\n\n问题 3结合以上案例，在项目后期，请帮助项目经理张工提出一些可以弥补工期耽误的方法。\n\n**1.要求丙方采取措施进行赶工。 2.对丙方工程进度严格控制。3.与甲方进行沟通，必要时，修改进度计划。**\n\n---\n\n五、已知某信息工程项目由A到G7个活动组成，项目根据项目目标特别施工期要求，经过分析、定义及评审，给出了该项目的活动历时。活动资源及活动逻辑关系如下表所示:\n\nA:需求分析 10 2\n\nB:软件设计 10 2 A\n\nC:测试案例编写 12 3 A\n\nD:编程实现 15 4 B\n\nE:软件测试 15 3 C、D\n\nF:编写用户手册 5 1 A\n\nG:调试软件系统 3 2 E\n\n问题 1:绘制该项目活动的前导网络图问题\n\n问题2:指出该项目的关键路径和工期问题\n\n问题3:指出其他路径的项目缓冲期\n\n问题4:为了配合甲方公司成立庆典，甲方要求该项目提前10天完工，并同意支付额外费用。承建单位经过论证，同意了甲方要求并按规范执行了审批流程。为了保质保量按期完工，\n\n![image-20221102005159821](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%80%83%E8%AF%95/image-20221102005159821-33a.png)\n\n---\n\n六、\n\n项目经理小王目前正在负责—个小型的软件开发项目。—开始他觉得项目比较小，变更应该不多，流程也不需要太复杂，因此就没有制定项目变更管理计划，而是强调团队成员间的及时沟通来保证项目按照计划进行：根据项目经理小王的理解．所谓变更管理的主要目标就是<u>保证项目能够按照计划进行</u>，如果能够保证不发生超越项目进度计划、成本计划等控制范围外的偏差，就可以<u>不用指定项目变更管理计划</u>．就可以不用指定项目变更管理计划，以减少项目的工作量。而项目执行过程中对计划的微调根本<u>不需要记录和管理</u>，也<u>不需要走项目变更管理流程</u>。而且他认为如果所有<u>项目变更都必简要向相关领导请示汇报</u>，过程太复杂和麻烦，还不如由执行人员提出变更的方案，彼此讨论—直后来的更方便和快捷。\n\n但是在项目进入集成测试阶段的时候，突然多了很多莫名其妙的问题出现。如在调试过程中。由于相关设计和记录的简化和不规范，造成了调试的困难，很难定位各个问题模块的错误；由于项目执行过程中。人员的调配替换，造成了文档记录的不—敢，导致后期人员阅读和理解方面的障碍。并且由于缺乏对开发过程的配置管理和控制，导致版本混乱，很难形成有效支持各模块集成的文档。另外，面目中很多细小的改动由于没有准确的记录，或者是根本没有记录．导致集成测试发现问题时，根本没有办法更改。小王对此也没有办法，不知道因为什么原因导致目前的项目状态，项目面临返工的危险。\n\n【问题1】结合案例。请说项目经理小王对项目变更管理的认识哪些星正确的？哪些是不正确的?\n\n**1、小王对项目变更管理的认识正确的是：**\n\n**（1）变更管理的目的是保证项目按计划进行；**\n\n**（2）项目变更需要获得相关干系人认可，讨论一致。**\n\n**（每项1分，共2分）**\n\n**2、小王对项目变更管理认识不正确的是：**\n\n**（1）不用制定项目变更管理计划；**\n\n**（2）对计划的微调根本不需要记录和管理；**\n\n**（3）不需要走变更管理流程。**\n\n【问题2】根据你的理解，请说明项目变更管理在软件项目管理中的主要活动内容\n\n**变更管理在软件项目管理中的主要活动内容**\n\n**(1)识别可能发生的变更。**\n\n**(2)管理每个已识别的变更。**\n\n**(3)维持所有基线的完整性。**\n\n**(4)根据已批准的变更，更新范围、成本、预算、进度和质量要求，协调整体项目内的变更。**\n\n**(5)基于质量报告，控制项目质量使其符合标准。**\n\n**(6)维护一个及时、精确的关于项目产品及其相关文档的信息库，直至项目结束。**\n\n【问题3】针对项目的当前状态，小王应该采取说明补救措施？\n\n**1、补一个变更管理计划；**\n\n**2、建立变更管理的流程；**\n\n**3、建立变更管理委员会；**\n\n**4、加强配置管理；**\n\n**5、加强版本管控；**\n\n**6、加强变更管理，有变更走流程。**\n', 1, '', 0, 0, 1, '2022-11-02 01:44:27', '2022-11-02 12:12:06');

-- ----------------------------
-- Table structure for tb_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `tb_article_tag`;
CREATE TABLE `tb_article_tag`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `article_id` int NOT NULL COMMENT '文章id',
  `tag_id` int NOT NULL COMMENT '标签id',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `fk_article_tag_1`(`article_id`) USING BTREE,
  INDEX `fk_article_tag_2`(`tag_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1066 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_article_tag
-- ----------------------------
INSERT INTO `tb_article_tag` VALUES (867, 55, 29);
INSERT INTO `tb_article_tag` VALUES (870, 54, 29);
INSERT INTO `tb_article_tag` VALUES (874, 56, 29);
INSERT INTO `tb_article_tag` VALUES (887, 57, 30);
INSERT INTO `tb_article_tag` VALUES (888, 57, 31);
INSERT INTO `tb_article_tag` VALUES (889, 58, 32);
INSERT INTO `tb_article_tag` VALUES (890, 58, 33);
INSERT INTO `tb_article_tag` VALUES (891, 58, 34);
INSERT INTO `tb_article_tag` VALUES (902, 61, 38);
INSERT INTO `tb_article_tag` VALUES (903, 62, 38);
INSERT INTO `tb_article_tag` VALUES (906, 59, 35);
INSERT INTO `tb_article_tag` VALUES (907, 59, 36);
INSERT INTO `tb_article_tag` VALUES (908, 59, 37);
INSERT INTO `tb_article_tag` VALUES (909, 60, 38);
INSERT INTO `tb_article_tag` VALUES (939, 63, 39);
INSERT INTO `tb_article_tag` VALUES (940, 63, 41);
INSERT INTO `tb_article_tag` VALUES (999, 67, 40);
INSERT INTO `tb_article_tag` VALUES (1000, 67, 41);
INSERT INTO `tb_article_tag` VALUES (1001, 67, 42);
INSERT INTO `tb_article_tag` VALUES (1054, 72, 43);
INSERT INTO `tb_article_tag` VALUES (1055, 72, 44);
INSERT INTO `tb_article_tag` VALUES (1056, 74, 42);
INSERT INTO `tb_article_tag` VALUES (1057, 73, 42);
INSERT INTO `tb_article_tag` VALUES (1064, 75, 41);
INSERT INTO `tb_article_tag` VALUES (1065, 75, 45);

-- ----------------------------
-- Table structure for tb_category
-- ----------------------------
DROP TABLE IF EXISTS `tb_category`;
CREATE TABLE `tb_category`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `category_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '分类名',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 191 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_category
-- ----------------------------
INSERT INTO `tb_category` VALUES (187, '测试分类', '2022-01-24 23:33:56', NULL);
INSERT INTO `tb_category` VALUES (188, '学习和技术总结', '2022-04-29 22:45:47', NULL);
INSERT INTO `tb_category` VALUES (189, '公告', '2022-06-14 14:39:17', NULL);
INSERT INTO `tb_category` VALUES (190, '动漫和电影分享', '2022-06-30 22:36:45', NULL);

-- ----------------------------
-- Table structure for tb_chat_record
-- ----------------------------
DROP TABLE IF EXISTS `tb_chat_record`;
CREATE TABLE `tb_chat_record`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_id` int NULL DEFAULT NULL COMMENT '用户id',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '昵称',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '头像',
  `content` varchar(1000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '聊天内容',
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT 'ip地址',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT 'ip来源',
  `type` tinyint NOT NULL COMMENT '类型',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3061 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_chat_record
-- ----------------------------
INSERT INTO `tb_chat_record` VALUES (2990, NULL, '未知ip', 'https://static.talkxj.com/photos/0bca52afdb2b9998132355d716390c9f.png', '123', '未知ip', '', 3, '2022-04-29 21:49:14', NULL);
INSERT INTO `tb_chat_record` VALUES (2991, NULL, '未知ip', 'https://static.talkxj.com/photos/0bca52afdb2b9998132355d716390c9f.png', '<img src= \'https://static.talkxj.com/emoji/chigua.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '未知ip', '', 3, '2022-04-29 21:49:18', NULL);
INSERT INTO `tb_chat_record` VALUES (2992, NULL, '未知ip', 'https://static.talkxj.com/photos/0bca52afdb2b9998132355d716390c9f.png', '新东方', '未知ip', '', 3, '2022-04-29 21:50:06', NULL);
INSERT INTO `tb_chat_record` VALUES (2993, NULL, '未知ip', 'https://static.talkxj.com/photos/0bca52afdb2b9998132355d716390c9f.png', '憨批', '未知ip', '', 3, '2022-04-29 21:50:10', NULL);
INSERT INTO `tb_chat_record` VALUES (2994, NULL, '未知ip', 'https://static.talkxj.com/photos/0bca52afdb2b9998132355d716390c9f.png', '123', '未知ip', '', 3, '2022-04-30 15:51:32', NULL);
INSERT INTO `tb_chat_record` VALUES (2995, NULL, '未知ip', 'https://static.talkxj.com/photos/0bca52afdb2b9998132355d716390c9f.png', '呼呼呼', '未知ip', '', 3, '2022-05-02 21:13:49', NULL);
INSERT INTO `tb_chat_record` VALUES (2996, NULL, '未知ip', 'https://static.talkxj.com/photos/0bca52afdb2b9998132355d716390c9f.png', '有人咩', '未知ip', '', 3, '2022-05-02 21:13:59', NULL);
INSERT INTO `tb_chat_record` VALUES (2997, NULL, '未知ip', 'https://static.talkxj.com/photos/0bca52afdb2b9998132355d716390c9f.png', '1', '未知ip', '', 3, '2022-05-25 14:10:52', NULL);
INSERT INTO `tb_chat_record` VALUES (2998, NULL, '未知ip', 'https://static.talkxj.com/photos/0bca52afdb2b9998132355d716390c9f.png', '1', '未知ip', '', 3, '2022-05-29 02:10:43', NULL);
INSERT INTO `tb_chat_record` VALUES (2999, NULL, '未知ip', 'https://static.talkxj.com/photos/0bca52afdb2b9998132355d716390c9f.png', '<img src= \'https://static.talkxj.com/emoji/aojiao.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '未知ip', '', 3, '2022-06-01 00:07:08', NULL);
INSERT INTO `tb_chat_record` VALUES (3000, 1007, 'rm -rf /*', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0b7d537a8fce1c5d0e3e4cfcabf01ca4.jpg', '2', '未知ip', '', 3, '2022-06-01 15:00:03', NULL);
INSERT INTO `tb_chat_record` VALUES (3001, NULL, '未知ip', 'https://static.talkxj.com/photos/0bca52afdb2b9998132355d716390c9f.png', '<img src= \'https://static.talkxj.com/emoji/zaijian.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '未知ip', '', 3, '2022-06-05 23:50:47', NULL);
INSERT INTO `tb_chat_record` VALUES (3002, 1007, 'rm -rf /*', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0b7d537a8fce1c5d0e3e4cfcabf01ca4.jpg', '<img src= \'https://static.talkxj.com/emoji/zaijian.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '未知ip', '', 3, '2022-06-05 23:52:03', NULL);
INSERT INTO `tb_chat_record` VALUES (3003, NULL, '未知ip', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png', '1', '未知ip', '', 3, '2022-06-19 23:46:52', NULL);
INSERT INTO `tb_chat_record` VALUES (3004, NULL, '192.9.247.252', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png', '1', '192.9.247.252', '美国', 3, '2022-06-24 02:12:42', NULL);
INSERT INTO `tb_chat_record` VALUES (3005, NULL, '111.53.209.103', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png', '2', '111.53.209.103', '山西省太原市 移动', 3, '2022-06-24 02:13:10', NULL);
INSERT INTO `tb_chat_record` VALUES (3006, NULL, '111.53.209.103', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png', '1', '111.53.209.103', '山西省太原市 移动', 3, '2022-06-24 02:13:33', NULL);
INSERT INTO `tb_chat_record` VALUES (3007, NULL, '192.9.247.252', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png', '123', '192.9.247.252', '美国', 3, '2022-06-24 02:13:40', NULL);
INSERT INTO `tb_chat_record` VALUES (3008, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '憨批', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:47:22', NULL);
INSERT INTO `tb_chat_record` VALUES (3009, 1014, '风间九尾', 'http://thirdqq.qlogo.cn/g?b=oidb&k=qSFP2D05xY2ZETukCOrdFA&s=40&t=1655033465', '憨批', '120.208.43.37', '山西省长治市 移动', 3, '2022-06-24 16:52:09', NULL);
INSERT INTO `tb_chat_record` VALUES (3010, 1014, '风间九尾', 'http://thirdqq.qlogo.cn/g?b=oidb&k=qSFP2D05xY2ZETukCOrdFA&s=40&t=1655033465', '<img src= \'https://static.talkxj.com/emoji/oh.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '120.208.43.37', '山西省长治市 移动', 3, '2022-06-24 16:52:19', NULL);
INSERT INTO `tb_chat_record` VALUES (3011, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '憨批', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:52:35', NULL);
INSERT INTO `tb_chat_record` VALUES (3012, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '<img src= \'https://static.talkxj.com/emoji/aojiao.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:52:45', NULL);
INSERT INTO `tb_chat_record` VALUES (3013, 1014, '风间九尾', 'http://thirdqq.qlogo.cn/g?b=oidb&k=qSFP2D05xY2ZETukCOrdFA&s=40&t=1655033465', '<img src= \'https://static.talkxj.com/emoji/miaoa.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '120.208.43.37', '山西省长治市 移动', 3, '2022-06-24 16:52:47', NULL);
INSERT INTO `tb_chat_record` VALUES (3014, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '这个聊天内容下一次打开网页就没了', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:53:18', NULL);
INSERT INTO `tb_chat_record` VALUES (3015, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '不能保存', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:53:24', NULL);
INSERT INTO `tb_chat_record` VALUES (3016, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '我记得我回复你评论会有邮件提醒的', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:53:50', NULL);
INSERT INTO `tb_chat_record` VALUES (3017, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '看见了没', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:53:59', NULL);
INSERT INTO `tb_chat_record` VALUES (3018, 1014, '风间九尾', 'http://thirdqq.qlogo.cn/g?b=oidb&k=qSFP2D05xY2ZETukCOrdFA&s=40&t=1655033465', '他让我绑定**', '120.208.43.37', '山西省长治市 移动', 3, '2022-06-24 16:54:18', NULL);
INSERT INTO `tb_chat_record` VALUES (3019, 1014, '风间九尾', 'http://thirdqq.qlogo.cn/g?b=oidb&k=qSFP2D05xY2ZETukCOrdFA&s=40&t=1655033465', '<img src= \'https://static.talkxj.com/emoji/smile.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '120.208.43.37', '山西省长治市 移动', 3, '2022-06-24 16:54:31', NULL);
INSERT INTO `tb_chat_record` VALUES (3020, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '对', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:54:43', NULL);
INSERT INTO `tb_chat_record` VALUES (3021, 1014, '风间九尾', 'http://thirdqq.qlogo.cn/g?b=oidb&k=qSFP2D05xY2ZETukCOrdFA&s=40&t=1655033465', '<img src= \'https://static.talkxj.com/emoji/dacall.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '120.208.43.37', '山西省长治市 移动', 3, '2022-06-24 16:54:56', NULL);
INSERT INTO `tb_chat_record` VALUES (3022, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '或者你用**注册一个**也行', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:54:58', NULL);
INSERT INTO `tb_chat_record` VALUES (3023, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '油箱', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:55:04', NULL);
INSERT INTO `tb_chat_record` VALUES (3024, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '**', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:55:09', NULL);
INSERT INTO `tb_chat_record` VALUES (3025, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '张浩', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:55:19', NULL);
INSERT INTO `tb_chat_record` VALUES (3026, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '这个**真几把怪', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:55:32', NULL);
INSERT INTO `tb_chat_record` VALUES (3027, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '*', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:55:39', NULL);
INSERT INTO `tb_chat_record` VALUES (3028, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '几把没有**', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:55:48', NULL);
INSERT INTO `tb_chat_record` VALUES (3029, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '评比', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:55:55', NULL);
INSERT INTO `tb_chat_record` VALUES (3030, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '评比被评比了', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:56:06', NULL);
INSERT INTO `tb_chat_record` VALUES (3031, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '笑*', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:56:10', NULL);
INSERT INTO `tb_chat_record` VALUES (3032, 1014, '风间九尾', 'http://thirdqq.qlogo.cn/g?b=oidb&k=qSFP2D05xY2ZETukCOrdFA&s=40&t=1655033465', '<img src= \'https://static.talkxj.com/emoji/huaji.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '120.208.43.37', '山西省长治市 移动', 3, '2022-06-24 16:56:16', NULL);
INSERT INTO `tb_chat_record` VALUES (3033, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '毕竟是别的**的东西', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:56:34', NULL);
INSERT INTO `tb_chat_record` VALUES (3034, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '网 、站', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:56:42', NULL);
INSERT INTO `tb_chat_record` VALUES (3035, 1014, '风间九尾', 'http://thirdqq.qlogo.cn/g?b=oidb&k=qSFP2D05xY2ZETukCOrdFA&s=40&t=1655033465', '哈**', '120.208.43.37', '山西省长治市 移动', 3, '2022-06-24 16:56:46', NULL);
INSERT INTO `tb_chat_record` VALUES (3036, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '哈哈哈', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:56:53', NULL);
INSERT INTO `tb_chat_record` VALUES (3037, 1014, '风间九尾', 'http://thirdqq.qlogo.cn/g?b=oidb&k=qSFP2D05xY2ZETukCOrdFA&s=40&t=1655033465', '<img src= \'https://static.talkxj.com/emoji/oh.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>你这咋啥都不能发', '120.208.43.37', '山西省长治市 移动', 3, '2022-06-24 16:56:58', NULL);
INSERT INTO `tb_chat_record` VALUES (3038, 1014, '风间九尾', 'http://thirdqq.qlogo.cn/g?b=oidb&k=qSFP2D05xY2ZETukCOrdFA&s=40&t=1655033465', '<img src= \'https://static.talkxj.com/emoji/jianxiao.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '120.208.43.37', '山西省长治市 移动', 3, '2022-06-24 16:57:02', NULL);
INSERT INTO `tb_chat_record` VALUES (3039, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '哈麻批', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:57:03', NULL);
INSERT INTO `tb_chat_record` VALUES (3040, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '本身我就不能控制', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:57:24', NULL);
INSERT INTO `tb_chat_record` VALUES (3041, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '这是是别的网 站的', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:57:36', NULL);
INSERT INTO `tb_chat_record` VALUES (3042, 1014, '风间九尾', 'http://thirdqq.qlogo.cn/g?b=oidb&k=qSFP2D05xY2ZETukCOrdFA&s=40&t=1655033465', '<img src= \'https://static.talkxj.com/emoji/aojiao.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '120.208.43.37', '山西省长治市 移动', 3, '2022-06-24 16:57:49', NULL);
INSERT INTO `tb_chat_record` VALUES (3043, 1014, '风间九尾', 'http://thirdqq.qlogo.cn/g?b=oidb&k=qSFP2D05xY2ZETukCOrdFA&s=40&t=1655033465', '来个***', '120.208.43.37', '山西省长治市 移动', 3, '2022-06-24 16:57:58', NULL);
INSERT INTO `tb_chat_record` VALUES (3044, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '<img src= \'https://static.talkxj.com/emoji/mojing.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:58:01', NULL);
INSERT INTO `tb_chat_record` VALUES (3045, 1014, '风间九尾', 'http://thirdqq.qlogo.cn/g?b=oidb&k=qSFP2D05xY2ZETukCOrdFA&s=40&t=1655033465', '。。', '120.208.43.37', '山西省长治市 移动', 3, '2022-06-24 16:58:02', NULL);
INSERT INTO `tb_chat_record` VALUES (3046, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '你绑定油箱了吗', '111.53.209.104', '山西省太原市 移动', 3, '2022-06-24 16:59:44', NULL);
INSERT INTO `tb_chat_record` VALUES (3047, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '1', '152.69.200.243', '美国', 3, '2022-07-24 03:02:39', NULL);
INSERT INTO `tb_chat_record` VALUES (3048, NULL, '152.69.200.243', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png', '1', '152.69.200.243', '美国', 3, '2022-07-25 12:02:41', NULL);
INSERT INTO `tb_chat_record` VALUES (3049, NULL, '152.69.196.109', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png', '1', '152.69.196.109', '美国', 3, '2022-10-11 16:14:05', NULL);
INSERT INTO `tb_chat_record` VALUES (3050, NULL, '111.53.209.100', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png', '1', '111.53.209.100', '山西省太原市 移动', 3, '2022-10-11 16:53:46', NULL);
INSERT INTO `tb_chat_record` VALUES (3051, NULL, '152.69.196.109', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png', '<img src= \'https://static.talkxj.com/emoji/jingya.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '152.69.196.109', '美国', 3, '2022-10-11 19:46:47', NULL);
INSERT INTO `tb_chat_record` VALUES (3052, NULL, '111.53.209.101', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png', '1', '111.53.209.101', '山西省太原市 移动', 3, '2022-10-22 22:46:36', NULL);
INSERT INTO `tb_chat_record` VALUES (3053, NULL, '111.53.209.100', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png', '<img src= \'https://static.talkxj.com/emoji/chigua.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '111.53.209.100', '山西省太原市 移动', 3, '2022-10-22 22:51:14', NULL);
INSERT INTO `tb_chat_record` VALUES (3054, NULL, '111.53.209.100', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png', '6', '111.53.209.100', '山西省太原市 移动', 3, '2022-10-28 19:38:45', NULL);
INSERT INTO `tb_chat_record` VALUES (3055, NULL, '111.53.209.100', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png', '<img src= \'https://static.talkxj.com/emoji/fengdou.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '111.53.209.100', '山西省太原市 移动', 3, '2022-10-28 19:38:50', NULL);
INSERT INTO `tb_chat_record` VALUES (3056, NULL, '198.211.27.20', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png', '123', '198.211.27.20', '美国加利福尼亚洛杉矶', 3, '2022-11-18 20:49:13', NULL);
INSERT INTO `tb_chat_record` VALUES (3057, NULL, '198.211.27.20', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png', '<img src= \'https://static.talkxj.com/emoji/nanguo.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '198.211.27.20', '美国加利福尼亚洛杉矶', 3, '2022-11-18 20:49:36', NULL);
INSERT INTO `tb_chat_record` VALUES (3058, NULL, '120.208.43.230', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png', '<img src= \'https://static.talkxj.com/emoji/weiqu.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '120.208.43.230', '山西省长治市 移动', 3, '2022-12-10 16:51:37', NULL);
INSERT INTO `tb_chat_record` VALUES (3059, 1012, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '<img src= \'https://static.talkxj.com/emoji/baoyou.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '120.208.43.222', '山西省长治市 移动', 3, '2023-01-06 19:59:43', NULL);
INSERT INTO `tb_chat_record` VALUES (3060, NULL, '120.208.43.174', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png', '<img src= \'https://static.talkxj.com/emoji/miaoa.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/><img src= \'https://static.talkxj.com/emoji/baoyou.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>', '120.208.43.174', '山西省长治市 移动', 3, '2023-02-23 05:22:26', NULL);

-- ----------------------------
-- Table structure for tb_comment
-- ----------------------------
DROP TABLE IF EXISTS `tb_comment`;
CREATE TABLE `tb_comment`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_id` int NOT NULL COMMENT '评论用户Id',
  `topic_id` int NULL DEFAULT NULL COMMENT '评论主题id',
  `comment_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '评论内容',
  `reply_user_id` int NULL DEFAULT NULL COMMENT '回复用户id',
  `parent_id` int NULL DEFAULT NULL COMMENT '父评论id',
  `type` tinyint NOT NULL COMMENT '评论类型 1.文章 2.友链 3.说说',
  `is_delete` tinyint NOT NULL DEFAULT 0 COMMENT '是否删除  0否 1是',
  `is_review` tinyint(1) NOT NULL DEFAULT 1 COMMENT '是否审核',
  `create_time` datetime NOT NULL COMMENT '评论时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `fk_comment_user`(`user_id`) USING BTREE,
  INDEX `fk_comment_parent`(`parent_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 750 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_comment
-- ----------------------------
INSERT INTO `tb_comment` VALUES (725, 1, 54, '测试评论', NULL, NULL, 1, 0, 1, '2022-03-11 22:52:24', NULL);
INSERT INTO `tb_comment` VALUES (726, 1, 54, '测试回复', 1, 725, 1, 0, 1, '2022-03-11 22:52:32', NULL);
INSERT INTO `tb_comment` VALUES (727, 1, 49, '测试评论', NULL, NULL, 3, 0, 1, '2022-03-11 22:52:41', NULL);
INSERT INTO `tb_comment` VALUES (728, 1, 49, '测试回复', 1, 727, 3, 0, 1, '2022-03-11 22:52:46', NULL);
INSERT INTO `tb_comment` VALUES (729, 1, NULL, '测试评论', NULL, NULL, 2, 0, 1, '2022-03-11 22:52:53', NULL);
INSERT INTO `tb_comment` VALUES (730, 1, NULL, '测试回复', 1, 729, 2, 0, 1, '2022-03-11 22:52:58', NULL);
INSERT INTO `tb_comment` VALUES (733, 1006, 54, 'hh', NULL, NULL, 1, 0, 1, '2022-04-25 16:41:46', NULL);
INSERT INTO `tb_comment` VALUES (734, 1006, 55, '55', NULL, NULL, 1, 0, 1, '2022-04-25 16:41:57', NULL);
INSERT INTO `tb_comment` VALUES (735, 1006, 55, '88', 1006, 734, 1, 0, 1, '2022-04-25 16:42:04', NULL);
INSERT INTO `tb_comment` VALUES (736, 1006, 55, '123', 1006, 734, 1, 0, 1, '2022-04-25 16:42:13', NULL);
INSERT INTO `tb_comment` VALUES (737, 1006, 55, '测试\n', NULL, NULL, 1, 0, 1, '2022-04-29 15:12:57', NULL);
INSERT INTO `tb_comment` VALUES (738, 1, 56, '123', NULL, NULL, 1, 0, 1, '2022-04-29 22:13:25', NULL);
INSERT INTO `tb_comment` VALUES (739, 1, 57, '评论审核', NULL, NULL, 1, 0, 1, '2022-06-06 17:37:13', '2022-06-06 17:37:24');
INSERT INTO `tb_comment` VALUES (740, 1007, 50, 'hello world！\n', NULL, NULL, 3, 0, 1, '2022-06-07 14:53:07', NULL);
INSERT INTO `tb_comment` VALUES (741, 1, NULL, 'hello!', NULL, NULL, 2, 0, 1, '2022-06-07 15:20:20', NULL);
INSERT INTO `tb_comment` VALUES (742, 1007, NULL, 'world\n', NULL, NULL, 2, 0, 1, '2022-06-07 15:21:36', NULL);
INSERT INTO `tb_comment` VALUES (743, 1009, NULL, 'hello!', 1007, 742, 2, 0, 1, '2022-06-08 00:11:43', NULL);
INSERT INTO `tb_comment` VALUES (744, 1007, 59, '123', NULL, NULL, 1, 0, 1, '2022-06-08 15:27:30', NULL);
INSERT INTO `tb_comment` VALUES (745, 1013, 59, '吾到此一游', NULL, NULL, 1, 0, 1, '2022-06-15 10:11:26', NULL);
INSERT INTO `tb_comment` VALUES (746, 1012, 59, '憨批', 1013, 745, 1, 0, 1, '2022-06-15 10:13:21', NULL);
INSERT INTO `tb_comment` VALUES (747, 1014, 51, '测试说说测试说说轩仔是个憨批', NULL, NULL, 3, 0, 1, '2022-06-24 16:51:30', NULL);
INSERT INTO `tb_comment` VALUES (748, 1012, 51, '你才是憨批\n', 1014, 747, 3, 0, 1, '2022-06-24 16:52:23', NULL);
INSERT INTO `tb_comment` VALUES (749, 1012, 67, '写的真好，作者真帅', NULL, NULL, 1, 0, 1, '2022-06-25 00:31:06', NULL);

-- ----------------------------
-- Table structure for tb_friend_link
-- ----------------------------
DROP TABLE IF EXISTS `tb_friend_link`;
CREATE TABLE `tb_friend_link`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `link_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接名',
  `link_avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接头像',
  `link_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接地址',
  `link_intro` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接介绍',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `fk_friend_link_user`(`link_name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 30 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_friend_link
-- ----------------------------
INSERT INTO `tb_friend_link` VALUES (26, '风丶宇的个人博客', 'https://static.talkxj.com/photos/b553f564f81a80dc338695acb1b475d2.jpg', 'https://www.talkxj.com', '往事不随风', '2022-01-18 00:26:46', NULL);
INSERT INTO `tb_friend_link` VALUES (27, '苏谨生', 'https://lxiuaanng.github.io/images/whoami/avatar.jpg', 'https://lxiuaanng.github.io', 'gitee', '2022-04-25 17:36:32', '2022-04-29 21:40:08');
INSERT INTO `tb_friend_link` VALUES (28, '苏谨生', 'https://lxiuaanng.github.io/images/whoami/avatar.jpg', 'https://lxiuaanng.github.io', 'github', '2022-04-25 17:37:48', '2022-04-29 21:40:12');

-- ----------------------------
-- Table structure for tb_menu
-- ----------------------------
DROP TABLE IF EXISTS `tb_menu`;
CREATE TABLE `tb_menu`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '菜单名',
  `path` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '菜单路径',
  `component` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '组件',
  `icon` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '菜单icon',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `order_num` tinyint(1) NOT NULL COMMENT '排序',
  `parent_id` int NULL DEFAULT NULL COMMENT '父id',
  `is_hidden` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否隐藏  0否1是',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 219 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_menu
-- ----------------------------
INSERT INTO `tb_menu` VALUES (1, '首页', '/', '/home/Home.vue', 'el-icon-myshouye', '2021-01-26 17:06:51', '2021-01-26 17:06:53', 1, NULL, 0);
INSERT INTO `tb_menu` VALUES (2, '文章管理', '/article-submenu', 'Layout', 'el-icon-mywenzhang-copy', '2021-01-25 20:43:07', '2021-01-25 20:43:09', 2, NULL, 0);
INSERT INTO `tb_menu` VALUES (3, '消息管理', '/message-submenu', 'Layout', 'el-icon-myxiaoxi', '2021-01-25 20:44:17', '2021-01-25 20:44:20', 3, NULL, 0);
INSERT INTO `tb_menu` VALUES (4, '系统管理', '/system-submenu', 'Layout', 'el-icon-myshezhi', '2021-01-25 20:45:57', '2021-01-25 20:45:59', 5, NULL, 0);
INSERT INTO `tb_menu` VALUES (5, '个人中心', '/setting', '/setting/Setting.vue', 'el-icon-myuser', '2021-01-26 17:22:38', '2021-01-26 17:22:41', 7, NULL, 0);
INSERT INTO `tb_menu` VALUES (6, '发布文章', '/articles', '/article/Article.vue', 'el-icon-myfabiaowenzhang', '2021-01-26 14:30:48', '2021-01-26 14:30:51', 1, 2, 0);
INSERT INTO `tb_menu` VALUES (7, '修改文章', '/articles/*', '/article/Article.vue', 'el-icon-myfabiaowenzhang', '2021-01-26 14:31:32', '2021-01-26 14:31:34', 2, 2, 1);
INSERT INTO `tb_menu` VALUES (8, '文章列表', '/article-list', '/article/ArticleList.vue', 'el-icon-mywenzhangliebiao', '2021-01-26 14:32:13', '2021-01-26 14:32:16', 3, 2, 0);
INSERT INTO `tb_menu` VALUES (9, '分类管理', '/categories', '/category/Category.vue', 'el-icon-myfenlei', '2021-01-26 14:33:42', '2021-01-26 14:33:43', 4, 2, 0);
INSERT INTO `tb_menu` VALUES (10, '标签管理', '/tags', '/tag/Tag.vue', 'el-icon-myicontag', '2021-01-26 14:34:33', '2021-01-26 14:34:36', 5, 2, 0);
INSERT INTO `tb_menu` VALUES (11, '评论管理', '/comments', '/comment/Comment.vue', 'el-icon-mypinglunzu', '2021-01-26 14:35:31', '2021-01-26 14:35:34', 1, 3, 0);
INSERT INTO `tb_menu` VALUES (12, '留言管理', '/messages', '/message/Message.vue', 'el-icon-myliuyan', '2021-01-26 14:36:09', '2021-01-26 14:36:13', 2, 3, 0);
INSERT INTO `tb_menu` VALUES (13, '用户列表', '/users', '/user/User.vue', 'el-icon-myyonghuliebiao', '2021-01-26 14:38:09', '2021-01-26 14:38:12', 1, 202, 0);
INSERT INTO `tb_menu` VALUES (14, '角色管理', '/roles', '/role/Role.vue', 'el-icon-myjiaoseliebiao', '2021-01-26 14:39:01', '2021-01-26 14:39:03', 2, 213, 0);
INSERT INTO `tb_menu` VALUES (15, '接口管理', '/resources', '/resource/Resource.vue', 'el-icon-myjiekouguanli', '2021-01-26 14:40:14', '2021-08-07 20:00:28', 2, 213, 0);
INSERT INTO `tb_menu` VALUES (16, '菜单管理', '/menus', '/menu/Menu.vue', 'el-icon-mycaidan', '2021-01-26 14:40:54', '2021-08-07 10:18:49', 2, 213, 0);
INSERT INTO `tb_menu` VALUES (17, '友链管理', '/links', '/friendLink/FriendLink.vue', 'el-icon-mydashujukeshihuaico-', '2021-01-26 14:41:35', '2021-01-26 14:41:37', 3, 4, 0);
INSERT INTO `tb_menu` VALUES (18, '关于我', '/about', '/about/About.vue', 'el-icon-myguanyuwo', '2021-01-26 14:42:05', '2021-01-26 14:42:10', 4, 4, 0);
INSERT INTO `tb_menu` VALUES (19, '日志管理', '/log-submenu', 'Layout', 'el-icon-myguanyuwo', '2021-01-31 21:33:56', '2021-01-31 21:33:59', 6, NULL, 0);
INSERT INTO `tb_menu` VALUES (20, '操作日志', '/operation/log', '/log/Operation.vue', 'el-icon-myguanyuwo', '2021-01-31 15:53:21', '2021-01-31 15:53:25', 1, 19, 0);
INSERT INTO `tb_menu` VALUES (201, '在线用户', '/online/users', '/user/Online.vue', 'el-icon-myyonghuliebiao', '2021-02-05 14:59:51', '2021-02-05 14:59:53', 7, 202, 0);
INSERT INTO `tb_menu` VALUES (202, '用户管理', '/users-submenu', 'Layout', 'el-icon-myyonghuliebiao', '2021-02-06 23:44:59', '2021-02-06 23:45:03', 4, NULL, 0);
INSERT INTO `tb_menu` VALUES (205, '相册管理', '/album-submenu', 'Layout', 'el-icon-myimage-fill', '2021-08-03 15:10:54', '2021-08-07 20:02:06', 5, NULL, 0);
INSERT INTO `tb_menu` VALUES (206, '相册列表', '/albums', '/album/Album.vue', 'el-icon-myzhaopian', '2021-08-03 20:29:19', '2021-08-04 11:45:47', 1, 205, 0);
INSERT INTO `tb_menu` VALUES (208, '照片管理', '/albums/:albumId', '/album/Photo.vue', 'el-icon-myzhaopian', '2021-08-03 21:37:47', '2021-08-05 10:24:08', 1, 205, 1);
INSERT INTO `tb_menu` VALUES (209, '页面管理', '/pages', '/page/Page.vue', 'el-icon-myyemianpeizhi', '2021-08-04 11:36:27', '2021-08-07 20:01:26', 2, 4, 0);
INSERT INTO `tb_menu` VALUES (210, '照片回收站', '/photos/delete', '/album/Delete.vue', 'el-icon-myhuishouzhan', '2021-08-05 13:55:19', NULL, 3, 205, 1);
INSERT INTO `tb_menu` VALUES (213, '权限管理', '/permission-submenu', 'Layout', 'el-icon-mydaohanglantubiao_quanxianguanli', '2021-08-07 19:56:55', '2021-08-07 19:59:40', 4, NULL, 0);
INSERT INTO `tb_menu` VALUES (214, '网站管理', '/website', '/website/Website.vue', 'el-icon-myxitong', '2021-08-07 20:06:41', NULL, 1, 4, 0);
INSERT INTO `tb_menu` VALUES (215, '说说管理', '/talk-submenu', 'Layout', 'el-icon-mypinglun', '2022-01-23 20:17:59', '2022-01-23 20:38:06', 5, NULL, 0);
INSERT INTO `tb_menu` VALUES (216, '发布说说', '/talks', '/talk/Talk.vue', 'el-icon-myfabusekuai', '2022-01-23 20:18:43', '2022-01-23 20:38:19', 1, 215, 0);
INSERT INTO `tb_menu` VALUES (217, '说说列表', '/talk-list', '/talk/TalkList.vue', 'el-icon-myiconfontdongtaidianji', '2022-01-23 23:28:24', '2022-01-24 00:02:48', 2, 215, 0);
INSERT INTO `tb_menu` VALUES (218, '修改说说', '/talks/:talkId', '/talk/Talk.vue', 'el-icon-myshouye', '2022-01-24 00:10:44', NULL, 3, 215, 1);

-- ----------------------------
-- Table structure for tb_message
-- ----------------------------
DROP TABLE IF EXISTS `tb_message`;
CREATE TABLE `tb_message`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '昵称',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '头像',
  `message_content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '留言内容',
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户地址',
  `time` tinyint(1) NULL DEFAULT NULL COMMENT '弹幕速度',
  `is_review` tinyint NOT NULL DEFAULT 1 COMMENT '是否审核',
  `create_time` datetime NOT NULL COMMENT '发布时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3948 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_message
-- ----------------------------
INSERT INTO `tb_message` VALUES (3938, '管理员', 'https://static.talkxj.com/avatar/user.png', '测试留言', '127.0.0.1', '', 9, 1, '2022-01-24 23:34:41', NULL);
INSERT INTO `tb_message` VALUES (3939, '游客', 'https://static.talkxj.com/photos/0bca52afdb2b9998132355d716390c9f.png', '123', '111.53.209.103', '山西省太原市 移动', 7, 1, '2022-04-30 02:32:05', NULL);
INSERT INTO `tb_message` VALUES (3940, '用户1531892622852435969', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0b7d537a8fce1c5d0e3e4cfcabf01ca4.jpg', '啦啦啦', '111.53.209.103', '山西省太原市 移动', 7, 1, '2022-06-01 14:57:35', NULL);
INSERT INTO `tb_message` VALUES (3941, '游客', 'https://static.talkxj.com/photos/0bca52afdb2b9998132355d716390c9f.png', '123', '111.53.209.99', '山西省太原市 移动', 7, 1, '2022-06-07 16:55:17', NULL);
INSERT INTO `tb_message` VALUES (3942, '游客', 'https://static.talkxj.com/photos/0bca52afdb2b9998132355d716390c9f.png', '456', '111.53.209.100', '山西省太原市 移动', 7, 1, '2022-06-07 16:56:31', NULL);
INSERT INTO `tb_message` VALUES (3943, '游客', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png', 'hello world!', '111.53.209.100', '山西省太原市 移动', 7, 1, '2022-06-07 17:01:29', NULL);
INSERT INTO `tb_message` VALUES (3944, 'rm -rf /*', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0b7d537a8fce1c5d0e3e4cfcabf01ca4.jpg', '哈哈哈', '111.53.209.104', '山西省太原市 移动', 8, 1, '2022-06-08 15:56:19', NULL);
INSERT INTO `tb_message` VALUES (3945, 'rm -rf /*', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0b7d537a8fce1c5d0e3e4cfcabf01ca4.jpg', 'hello world!', '111.53.209.105', '山西省太原市 移动', 8, 1, '2022-06-08 15:57:10', NULL);
INSERT INTO `tb_message` VALUES (3946, 'rm -rf /*', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0b7d537a8fce1c5d0e3e4cfcabf01ca4.jpg', 'hello world', '111.53.209.101', '山西省太原市 移动', 7, 1, '2022-06-08 15:59:09', NULL);
INSERT INTO `tb_message` VALUES (3947, 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', '哈哈哈哈、', '120.208.43.183', '山西省长治市 移动', 7, 1, '2022-07-03 13:10:38', NULL);

-- ----------------------------
-- Table structure for tb_operation_log
-- ----------------------------
DROP TABLE IF EXISTS `tb_operation_log`;
CREATE TABLE `tb_operation_log`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `opt_module` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作模块',
  `opt_type` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作类型',
  `opt_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作url',
  `opt_method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作方法',
  `opt_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作描述',
  `request_param` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '请求参数',
  `request_method` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '请求方式',
  `response_data` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '返回数据',
  `user_id` int NOT NULL COMMENT '用户id',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户昵称',
  `ip_address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作地址',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1283 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_operation_log
-- ----------------------------
INSERT INTO `tb_operation_log` VALUES (1155, '页面模块', '新增或修改', '/admin/pages', 'com.minzheng.blog.controller.PageController.saveOrUpdatePage', '保存或更新页面', '[{\"id\":2,\"pageCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/01b23013b53294818d6cc0a569decc2e.jpg\",\"pageLabel\":\"archive\",\"pageName\":\"归档\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.105', '山西省太原市 移动', '2022-05-31 23:31:03', NULL);
INSERT INTO `tb_operation_log` VALUES (1156, '页面模块', '新增或修改', '/admin/pages', 'com.minzheng.blog.controller.PageController.saveOrUpdatePage', '保存或更新页面', '[{\"id\":3,\"pageCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/6d8a383af6be677d0714e0609edec9cf.jpg\",\"pageLabel\":\"category\",\"pageName\":\"分类\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.100', '山西省太原市 移动', '2022-05-31 23:32:42', NULL);
INSERT INTO `tb_operation_log` VALUES (1157, '页面模块', '新增或修改', '/admin/pages', 'com.minzheng.blog.controller.PageController.saveOrUpdatePage', '保存或更新页面', '[{\"id\":4,\"pageCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/57e41d1e62844fe5531ae2d257e4557c.jpg\",\"pageLabel\":\"tag\",\"pageName\":\"标签\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.103', '山西省太原市 移动', '2022-05-31 23:34:44', NULL);
INSERT INTO `tb_operation_log` VALUES (1158, '页面模块', '新增或修改', '/admin/pages', 'com.minzheng.blog.controller.PageController.saveOrUpdatePage', '保存或更新页面', '[{\"id\":5,\"pageCover\":\"https://figurebed-1311634249.file.myqcloud.com/2022/E/我的/壁纸/微信图片_20220528204052-704.png\",\"pageLabel\":\"album\",\"pageName\":\"相册\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.105', '山西省太原市 移动', '2022-05-31 23:37:28', NULL);
INSERT INTO `tb_operation_log` VALUES (1159, '页面模块', '新增或修改', '/admin/pages', 'com.minzheng.blog.controller.PageController.saveOrUpdatePage', '保存或更新页面', '[{\"id\":5,\"pageCover\":\"https://figurebed-1311634249.file.myqcloud.com/2022/E/我的/壁纸/微信图片_20220528204052-704.png\",\"pageLabel\":\"album\",\"pageName\":\"相册\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.100', '山西省太原市 移动', '2022-05-31 23:38:00', NULL);
INSERT INTO `tb_operation_log` VALUES (1160, '页面模块', '新增或修改', '/admin/pages', 'com.minzheng.blog.controller.PageController.saveOrUpdatePage', '保存或更新页面', '[{\"id\":5,\"pageCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/9cadfbea1257d74061e5703bba9c2d4d.jpg\",\"pageLabel\":\"album\",\"pageName\":\"相册\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.103', '山西省太原市 移动', '2022-05-31 23:39:15', NULL);
INSERT INTO `tb_operation_log` VALUES (1161, '页面模块', '新增或修改', '/admin/pages', 'com.minzheng.blog.controller.PageController.saveOrUpdatePage', '保存或更新页面', '[{\"id\":6,\"pageCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/9320e8374a24bdd803f2033b2b632897.png\",\"pageLabel\":\"link\",\"pageName\":\"友链\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.100', '山西省太原市 移动', '2022-05-31 23:42:49', NULL);
INSERT INTO `tb_operation_log` VALUES (1162, '页面模块', '新增或修改', '/admin/pages', 'com.minzheng.blog.controller.PageController.saveOrUpdatePage', '保存或更新页面', '[{\"id\":904,\"pageCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/7cae82bdcd6aa2baae8eda5655f0b75c.jpg\",\"pageLabel\":\"talk\",\"pageName\":\"说说\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.100', '山西省太原市 移动', '2022-05-31 23:49:38', NULL);
INSERT INTO `tb_operation_log` VALUES (1163, '页面模块', '新增或修改', '/admin/pages', 'com.minzheng.blog.controller.PageController.saveOrUpdatePage', '保存或更新页面', '[{\"id\":7,\"pageCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/36803b7104780e774571d39723b48697.jpg\",\"pageLabel\":\"about\",\"pageName\":\"关于\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.100', '山西省太原市 移动', '2022-05-31 23:52:11', NULL);
INSERT INTO `tb_operation_log` VALUES (1164, '页面模块', '新增或修改', '/admin/pages', 'com.minzheng.blog.controller.PageController.saveOrUpdatePage', '保存或更新页面', '[{\"id\":8,\"pageCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0104f602f28efd133433541d133200cf.jpg\",\"pageLabel\":\"message\",\"pageName\":\"留言\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.105', '山西省太原市 移动', '2022-05-31 23:53:10', NULL);
INSERT INTO `tb_operation_log` VALUES (1165, '页面模块', '新增或修改', '/admin/pages', 'com.minzheng.blog.controller.PageController.saveOrUpdatePage', '保存或更新页面', '[{\"id\":10,\"pageCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/319f9c19b813df3b58614bafb7ccca8d.jpg\",\"pageLabel\":\"articleList\",\"pageName\":\"文章列表\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.102', '山西省太原市 移动', '2022-06-01 00:01:50', NULL);
INSERT INTO `tb_operation_log` VALUES (1166, '页面模块', '新增或修改', '/admin/pages', 'com.minzheng.blog.controller.PageController.saveOrUpdatePage', '保存或更新页面', '[{\"id\":9,\"pageCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/ea13ebd2a81b9064fb05fe7556dc3325.jpg\",\"pageLabel\":\"user\",\"pageName\":\"个人中心\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.100', '山西省太原市 移动', '2022-06-01 00:02:32', NULL);
INSERT INTO `tb_operation_log` VALUES (1167, '友链模块', '删除', '/admin/links', 'com.minzheng.blog.controller.FriendLinkController.deleteFriendLink', '删除友链', '[[29]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.100', '山西省太原市 移动', '2022-06-01 00:03:22', NULL);
INSERT INTO `tb_operation_log` VALUES (1168, '博客信息模块', '修改', '/admin/about', 'com.minzheng.blog.controller.BlogInfoController.updateAbout', '修改关于我信息', '[{\"aboutContent\":\"鄙人姓梁，出生于山西省运城市，是一名山西工商学院的大三学生。\\n\\n性格也许并不糟糕，但是很讨厌让人烦恼的事情，口头禅是“烦死了”，可能因为眉毛天生的样子看起来让人觉得有点严肃，给人不太愿意交流的错觉，所以近几年的人际关系并不太好，逐渐养成了独立生活的习惯，但导致现在反而真的不太愿意与人交流。另外有过两次恋爱经验，从中获取到的经验就是：我这个人或许不适合恋爱。\\n\\n博客上线时间为2022年4月30日，基于[风、宇](https://github.com/X1192176811/blog)大佬的开源项目，这是大佬的博客交流群，既有丰富工作经验的老油条，也有努力学习的小白，欢迎加入！\\n![](https://lxuanblog.oss-cn-beijing.aliyuncs.com/img/2022/C/Users/12748/Desktop/博客技术交流群聊二维码-689.png)\\n\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.105', '山西省太原市 移动', '2022-06-01 00:32:06', NULL);
INSERT INTO `tb_operation_log` VALUES (1169, '博客信息模块', '修改', '/admin/about', 'com.minzheng.blog.controller.BlogInfoController.updateAbout', '修改关于我信息', '[{\"aboutContent\":\"鄙人姓梁，出生于山西省运城市，是一名山西工商学院的大三学生。\\n\\n性格也许并不糟糕，但是很讨厌让人烦恼的事情，口头禅是“烦死了”，可能因为眉毛天生的样子看起来让人觉得有点严肃，给人不太愿意交流的错觉，所以近几年的人际关系并不太好，逐渐养成了独立生活的习惯，但导致现在反而真的不太愿意与人交流。另外有过两次恋爱经验，从中获取到的经验就是：我这个人或许不适合恋爱。\\n\\n博客上线时间为2022年4月30日，基于[风、宇](https://github.com/X1192176811/blog)大佬的开源项目，这是大佬的博客交流群，既有丰富工作经验的老油条，也有努力学习的小白，欢迎各位加入！\\n![](https://lxuanblog.oss-cn-beijing.aliyuncs.com/img/2022/C/Users/12748/Desktop/博客技术交流群聊二维码-689.png)\\n\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.105', '山西省太原市 移动', '2022-06-01 00:32:48', NULL);
INSERT INTO `tb_operation_log` VALUES (1170, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 1. 删除全局配置\\n\\n```cmd\\ngit config --global --unset user.name   \\ngit config --global --unset user.email   \\n```\\n# 2. 分别配置仓库\\n```cmd\\ncd 仓库地址1\\ngit config user.name \\\"xxx\\\"\\ngit config user.email \\\"xxx@xxx.com\\\"  \\n```\\n```cmd\\ncd 仓库地址2\\ngit config user.name \\\"xxx\\\"\\ngit config user.email \\\"xxx@xxx.com\\\"   \\n```\\n```git\\n......\\n```\\n\\n# 3. 创建公钥\\n```cmd\\ncd ~/.ssh\\nssh-keygen -t rsa -C \\\"111@xxx.com\\\" id_rsa_111 \\nssh-keygen -t rsa -C \\\"222@xxx.com\\\" id_rsa_222   \\n//将.pub文件内容添加到GitHub或gitee的ssh管理库中\\n```\\n* -C 表示提供一个注释，也就是后面的 *\\\"邮件地址@youremail.com\\\"* ，可以省略。双引号里为注释的内容，所以不一定得填邮箱，可以输入任何内容，只要你自己知道这个密钥对应哪个网站的仓库就行了。\\n* 然后将.pub文件内容添加到GitHub或gitee的ssh管理库中\\n\\n# 4. 配置config文件\\n```cmd\\ncd ~/.ssh\\n```\\n新建文件config  \\n输入\\n```vim\\n# gitee\\nHost gitee.com\\nHostName gitee.com\\nPreferredAuthentications publickey\\nIdentityFile ~/.ssh/id_rsa_gitee\\n# github\\nHost 111.github.com\\nHostName github.com\\nPreferredAuthentications publickey\\nIdentityFile ~/.ssh/id_rsa_111\\n# github\\nHost 222.github.com\\nHostName github.com\\nPreferredAuthentications publickey\\nIdentityFile ~/.ssh/id_rsa_222\\n```\\n![config](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/config.png)\\n**原因：**  \\n\\n1. ssh 客户端是通过类似`git@github.com:githubUserName/repName.git`的地址来识别使用本地的哪个私钥的，地址中的 `git@github.com` 其实就是`git@(config文件中的Host值)`。\\n2. 如果所有账号的 `Host` 值都为 `github.com`，那么就只能使用一个私钥。所以要对 `Host` 进行配置，至少让每个账号使用自己的 `Host`，每个 `Host` 的域名做 `CNAME` 解析到 `github.com`，如上面配置中的`111.github.com`和`222.github.com`。\\n3. 配置了别名之后，新的地址就是`git@111.github.com:githubUserName/repName.git`（在添加远程仓库时使用）。   \\n\\n这样 ssh 在连接时就可以区别不同的账号了。\\n\\n```cmd\\nssh -T git@111.github.com\\nssh -T git@222.github.com\\n//测试ssh连接，返回“Hi xxx ...”则成功\\n```\\n![Hixxx](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/Hixxx.png)\\n\\n# 5. 查看远程分支\\n\\n```cmd\\ngit remote -v     \\n```\\n# 6. 添加远程仓库\\n```cmd\\ncd 仓库1地址\\ngit remote add origin git@111.github.com:githubUserName/repName.git\\n\\ncd 仓库2地址\\ngit remote add origin git@222.github.com:githubUserName/repName.git\\n```\\n\\n如下图，若是出现这种错误：\\n\\n![origin错误](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/origin%E9%94%99%E8%AF%AF.jpg)\\n则表示远程 origin 已经存在，只需要将远程配置删除，再输入上述命令重新添加即可\\n\\n```cmd\\ngit remote rm origin\\ngit remote add origin......\\n```\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/a5fad6cb39146011cd1ca3adf10d0ad9.jpg\",\"articleTitle\":\"Windows配置多个GitHub仓库\",\"categoryName\":\"学习和技术总结\",\"id\":57,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.100', '山西省太原市 移动', '2022-06-01 00:42:44', NULL);
INSERT INTO `tb_operation_log` VALUES (1171, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"总体分为三步，相比较其他主题需要一些繁琐的配置，icarus就简单很多\\n\\n<!--more-->\\n\\n\\n## 1. 登陆GitHub并[点此注册](https://github.com/settings/applications/new)一个新的OAuth应用\\n\\n   ![注册OAute](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/%E6%B3%A8%E5%86%8COAute.png)\\n   随后记录下Client ID与Client Secre，等下要用\\n\\n   > Client ID\\n   > xxxxxxxxxxxxxxxxxxxx\\n   > Client Secret\\n   > xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\n\\n<br />\\n\\n## 2. [进入此网页](https://github.com/gitalk/gitalk)往下拉，有这样一句命令，在博客根目录执行：\\n\\n   > npm i --save gitalk #安装gitalk插件\\n\\n<br />\\n\\n## 3. 打开根目录下的_config.icarus.yml文件，添加配置\\n   \\n   >   comment：\\n   >   type: gitalk\\n   >   owner: lxiuaunng   #你的GitHub用户名\\n   >   repo: lxiuaunng.github.io   #你的博客地址\\n   >   client_id: 0b26fddaf37d93589745\\n   >   client_secret: 1c15538585140bf3ef0b9f5dd2c01569055cf8ba\\n   >   admin: lxiuaunng   #同样是你的GitHub用户名\\n\\n<br />\\n## 4. 在博客根目录下打开git bush，先hexo clean，再hexo s->g->d\\n基本上就是这样了\\n\\n![样图](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/%E6%A0%B7%E5%9B%BE.png)\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/f336b8346cbf291881756a38b4aba123.jpg\",\"articleTitle\":\"icarus主题+gitalk评论插件的配置\",\"categoryName\":\"学习和技术总结\",\"id\":58,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.104', '山西省太原市 移动', '2022-06-01 00:43:28', NULL);
INSERT INTO `tb_operation_log` VALUES (1172, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 1. 图床是什么？\\n\\n图床是指存放图片的服务器，一般要求有公网ip，能够在浏览器中访问。\\n\\n图床也分为免费和付费，绝大多数免费图床如：[七牛云 ](https://www.qiniu.com/)、[路过图床](https://imgtu.com/)、[聚合图床](https://www.superbed.cn/)、[Loukky免费公益图床](http://imgur.loukky.com/)、[SM.MS](https://sm.ms/)等，相对于对图片存储要求不高的人完全够用，但或多或少都有些空间或者速度上的限制，况且把图片放在别人的服务器万一跑路就很尴尬了，因此云存储便是一个方便而又稳定的选择\\n\\n# 2. 腾讯云存储\\n\\n* 腾讯云是一款比较便宜的对象存储产品，对于个人而言不贵，而且还新人半年的试用期\\n* PicGo是方便图片上传和将存储后的图片转化为markdown链接的软件，有了它图片上传变得非常简单\\n* 云存储并非只可以存储图片，而是可以存储任何文件\\n\\n1. 打开[腾讯云](https://cloud.tencent.com/)，在此处购买，如果是新人请跳过此处前往2\\n\\n![image-20220430033309452](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033309452.png)\\n\\n2. 领取半年的免费额度资源包\\n\\n![image-20220430033746881](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033746881.png)\\n\\n![image-20220430033844406](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033844406.png)\\n\\n![image-20220430033941899](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033941899.png)\\n\\n![image-20220430034028895](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034028895.png)\\n\\n3. 创建存储桶\\n\\n![image-20220430034210728](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034210728.png)\\n\\n![image-20220430034521279](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034521279.png)\\n\\n![image-20220430034714595](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034714595.png)\\n\\n![image-20220430034739901](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034739901.png)\\n\\n\\n\\n\\n\\n# 3. PicGo图床管理软件\\n\\n[PicGo (molunerfinn.com)](https://molunerfinn.com/PicGo/)\\n\\n![image-20220430040244537](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430040244537.png)\\n\\n![image-20220430035809218](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430035809218.png)\\n\\n1. 前三个\\n\\n![image-20220430035951372](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430035951372.png)\\n\\n2. 后两个\\n\\n   ![image-20220430040132579](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430040132579.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/1ce48e5ebd61b7fae155b02a92ca278d.jpg\",\"articleTitle\":\"图床\",\"categoryName\":\"学习和技术总结\",\"id\":59,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.101', '山西省太原市 移动', '2022-06-01 00:44:09', NULL);
INSERT INTO `tb_operation_log` VALUES (1173, '评论模块', '修改', '/admin/comments/review', 'com.minzheng.blog.controller.CommentController.updateCommentsReview', '审核评论', '[{\"idList\":[739],\"isReview\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.102', '山西省太原市 移动', '2022-06-06 17:37:24', NULL);
INSERT INTO `tb_operation_log` VALUES (1174, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 1. 图床是什么？\\n\\n图床是指存放图片的服务器，一般要求有公网ip，能够在浏览器中访问。\\n\\n图床也分为免费和付费，绝大多数免费图床如：[七牛云 ](https://www.qiniu.com/)、[路过图床](https://imgtu.com/)、[聚合图床](https://www.superbed.cn/)、[Loukky免费公益图床](http://imgur.loukky.com/)、[SM.MS](https://sm.ms/)等，相对于对图片存储要求不高的人完全够用，但或多或少都有些空间或者速度上的限制，况且把图片放在别人的服务器万一跑路就很尴尬了，因此云存储便是一个方便而又稳定的选择\\n\\n# 2. 腾讯云存储\\n\\n* 腾讯云是一款比较便宜的对象存储产品，对于个人而言不贵，而且还新人半年的试用期\\n* PicGo是方便图片上传和将存储后的图片转化为markdown链接的软件，有了它图片上传变得非常简单\\n* 云存储并非只可以存储图片，而是可以存储任何文件\\n\\n1. 打开[腾讯云](https://cloud.tencent.com/)，在此处购买，如果是新人请跳过此处前往2\\n\\n![image-20220430033309452](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033309452.png)\\n\\n2. 领取半年的免费额度资源包\\n\\n![image-20220430033746881](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033746881.png)\\n\\n![image-20220430033844406](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033844406.png)\\n\\n![image-20220430033941899](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033941899.png)\\n\\n![image-20220430034028895](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034028895.png)\\n\\n3. 创建存储桶\\n\\n![image-20220430034210728](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034210728.png)\\n\\n![image-20220430034521279](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034521279.png)\\n\\n![image-20220430034714595](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034714595.png)\\n\\n![image-20220430034739901](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034739901.png)\\n\\n\\n\\n\\n\\n# 3. PicGo图床管理软件\\n\\n[PicGo (molunerfinn.com)](https://molunerfinn.com/PicGo/)\\n\\n![image-20220430040244537](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430040244537.png)\\n\\n![image-20220430035809218](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430035809218.png)\\n\\n1. 前三个\\n\\n![image-20220430035951372](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430035951372.png)\\n\\n2. 后两个\\n\\n   ![image-20220430040132579](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430040132579.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/1ce48e5ebd61b7fae155b02a92ca278d.jpg\",\"articleTitle\":\"图床\",\"categoryName\":\"学习和技术总结\",\"id\":59,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.102', '山西省太原市 移动', '2022-06-07 15:11:39', NULL);
INSERT INTO `tb_operation_log` VALUES (1175, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 1. 图床是什么？\\n\\n图床是指存放图片的服务器，一般要求有公网ip，能够在浏览器中访问。\\n\\n图床也分为免费和付费，绝大多数免费图床如：[七牛云 ](https://www.qiniu.com/)、[路过图床](https://imgtu.com/)、[聚合图床](https://www.superbed.cn/)、[Loukky免费公益图床](http://imgur.loukky.com/)、[SM.MS](https://sm.ms/)等，相对于对图片存储要求不高的人完全够用，但或多或少都有些空间或者速度上的限制，况且把图片放在别人的服务器万一跑路就很尴尬了，因此云存储便是一个方便而又稳定的选择\\n\\n# 2. 腾讯云存储\\n\\n* 腾讯云是一款比较便宜的对象存储产品，对于个人而言不贵，而且还新人半年的试用期\\n* PicGo是方便图片上传和将存储后的图片转化为markdown链接的软件，有了它图片上传变得非常简单\\n* 云存储并非只可以存储图片，而是可以存储任何文件\\n\\n1. 打开[腾讯云](https://cloud.tencent.com/)，在此处购买，如果是新人请跳过此处前往2\\n\\n![image-20220430033309452](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033309452.png)\\n\\n2. 领取半年的免费额度资源包\\n\\n![image-20220430033746881](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033746881.png)\\n\\n![image-20220430033844406](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033844406.png)\\n\\n![image-20220430033941899](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033941899.png)\\n\\n![image-20220430034028895](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034028895.png)\\n\\n3. 创建存储桶\\n\\n![image-20220430034210728](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034210728.png)\\n\\n![image-20220430034521279](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034521279.png)\\n\\n![image-20220430034714595](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034714595.png)\\n\\n![image-20220430034739901](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034739901.png)\\n\\n\\n\\n\\n\\n# 3. PicGo图床管理软件\\n\\n[PicGo (molunerfinn.com)](https://molunerfinn.com/PicGo/)\\n\\n![image-20220430040244537](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430040244537.png)\\n\\n![image-20220430035809218](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430035809218.png)\\n\\n1. 前三个\\n\\n![image-20220430035951372](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430035951372.png)\\n\\n2. 后两个\\n\\n   ![image-20220430040132579](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430040132579.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/1ce48e5ebd61b7fae155b02a92ca278d.jpg\",\"articleTitle\":\"图床\",\"categoryName\":\"学习和技术总结\",\"id\":59,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.104', '山西省太原市 移动', '2022-06-08 16:03:28', NULL);
INSERT INTO `tb_operation_log` VALUES (1176, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"2022/6/14 此项目登录功能已完美上线，欢迎各位来访！\\n\\n2022/6/13 此项目完善程度基本上已达95%，微博登录功能已申请通过，QQ互联还需要一段时间。\",\"articleCover\":\"\",\"articleTitle\":\"公告记录\",\"categoryName\":\"公告\",\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.104', '山西省太原市 移动', '2022-06-14 14:30:56', NULL);
INSERT INTO `tb_operation_log` VALUES (1177, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"2022/6/14 此项目登录功能已完美上线，欢迎各位来访！\\n\\n2022/6/13 此项目完善程度基本上已达95%，微博登录功能已申请通过，QQ互联还需要一段时间。\",\"articleCover\":\"\",\"articleTitle\":\"公告记录\",\"categoryName\":\"公告\",\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[\"公告\"],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.104', '山西省太原市 移动', '2022-06-14 14:30:56', NULL);
INSERT INTO `tb_operation_log` VALUES (1178, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"2022/6/14 此项目登录功能已完美上线，欢迎各位来访！\\n\\n2022/6/13 此项目完善程度基本上已达95%，微博登录功能已申请通过，QQ互联还需要一段时间。\",\"articleCover\":\"\",\"articleTitle\":\"公告记录\",\"categoryName\":\"公告\",\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.100', '山西省太原市 移动', '2022-06-14 14:30:57', NULL);
INSERT INTO `tb_operation_log` VALUES (1179, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"2022/6/14 此项目登录功能已完美上线，欢迎各位来访！\\n\\n2022/6/13 此项目完善程度基本上已达95%，微博登录功能已申请通过，QQ互联还需要一段时间。\",\"articleCover\":\"\",\"articleTitle\":\"公告记录\",\"id\":60,\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.104', '山西省太原市 移动', '2022-06-14 14:33:35', NULL);
INSERT INTO `tb_operation_log` VALUES (1180, '文章模块', '修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[62,61],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.104', '山西省太原市 移动', '2022-06-14 14:33:43', NULL);
INSERT INTO `tb_operation_log` VALUES (1181, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"2022/6/14 此项目登录功能已完美上线，欢迎各位来访！\\n\\n2022/6/13 此项目完善程度基本上已达95%，微博登录功能已申请通过，QQ互联还需要一段时间。\",\"articleCover\":\"\",\"articleTitle\":\"公告记录\",\"id\":60,\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.105', '山西省太原市 移动', '2022-06-14 14:34:41', NULL);
INSERT INTO `tb_operation_log` VALUES (1182, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 1. 图床是什么？\\n\\n图床是指存放图片的服务器，一般要求有公网ip，能够在浏览器中访问。\\n\\n图床也分为免费和付费，绝大多数免费图床如：[七牛云 ](https://www.qiniu.com/)、[路过图床](https://imgtu.com/)、[聚合图床](https://www.superbed.cn/)、[Loukky免费公益图床](http://imgur.loukky.com/)、[SM.MS](https://sm.ms/)等，相对于对图片存储要求不高的人完全够用，但或多或少都有些空间或者速度上的限制，况且把图片放在别人的服务器万一跑路就很尴尬了，因此云存储便是一个方便而又稳定的选择\\n\\n# 2. 腾讯云存储\\n\\n* 腾讯云是一款比较便宜的对象存储产品，对于个人而言不贵，而且还新人半年的试用期\\n* PicGo是方便图片上传和将存储后的图片转化为markdown链接的软件，有了它图片上传变得非常简单\\n* 云存储并非只可以存储图片，而是可以存储任何文件\\n\\n1. 打开[腾讯云](https://cloud.tencent.com/)，在此处购买，如果是新人请跳过此处前往2\\n\\n![image-20220430033309452](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033309452.png)\\n\\n2. 领取半年的免费额度资源包\\n\\n![image-20220430033746881](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033746881.png)\\n\\n![image-20220430033844406](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033844406.png)\\n\\n![image-20220430033941899](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430033941899.png)\\n\\n![image-20220430034028895](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034028895.png)\\n\\n3. 创建存储桶\\n\\n![image-20220430034210728](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034210728.png)\\n\\n![image-20220430034521279](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034521279.png)\\n\\n![image-20220430034714595](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034714595.png)\\n\\n![image-20220430034739901](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430034739901.png)\\n\\n\\n\\n\\n\\n# 3. PicGo图床管理软件\\n\\n[PicGo (molunerfinn.com)](https://molunerfinn.com/PicGo/)\\n\\n![image-20220430040244537](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430040244537.png)\\n\\n![image-20220430035809218](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430035809218.png)\\n\\n1. 前三个\\n\\n![image-20220430035951372](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430035951372.png)\\n\\n2. 后两个\\n\\n   ![image-20220430040132579](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/image-20220430040132579.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/1ce48e5ebd61b7fae155b02a92ca278d.jpg\",\"articleTitle\":\"图床\",\"categoryName\":\"学习和技术总结\",\"id\":59,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.102', '山西省太原市 移动', '2022-06-14 14:35:09', NULL);
INSERT INTO `tb_operation_log` VALUES (1183, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"2022/6/14 此项目登录功能已完美上线，欢迎各位来访！\\n\\n2022/6/13 此项目完善程度基本上已达95%，微博登录功能已申请通过，QQ互联还需要一段时间。\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/500759f158a03e9b10d359c1e939aab4.png\",\"articleTitle\":\"公告记录\",\"categoryName\":\"公告\",\"id\":60,\"isTop\":0,\"originalUrl\":\"\",\"status\":2,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.103', '山西省太原市 移动', '2022-06-14 14:39:17', NULL);
INSERT INTO `tb_operation_log` VALUES (1184, '博客信息模块', '修改', '/admin/about', 'com.minzheng.blog.controller.BlogInfoController.updateAbout', '修改关于我信息', '[{\"aboutContent\":\"2022/6/14 鄙人是一名大三学生，课余时间学学springboot框架，mysql数据库之类的，不过水平有限，写不出什么厉害的程序。此博客项目基于[风、宇](https://www.talkxj.com/)大佬的模板，这是大佬的GitHub地址[https://github.com/X1192176811/blog](https://github.com/X1192176811/blog)，详解都非常清楚，有兴趣的自己搭建一下，这是大佬的博客交流群，有很多上班族、应届生和小白，有什么疑问的话可以让群友们帮忙解答。\\n![](https://lxuanblog.oss-cn-beijing.aliyuncs.com/img/2022/C/Users/12748/Desktop/%E5%8D%9A%E5%AE%A2%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81%E7%BE%A4%E8%81%8A%E4%BA%8C%E7%BB%B4%E7%A0%81-689.png)\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '111.53.209.105', '山西省太原市 移动', '2022-06-14 15:11:56', NULL);
INSERT INTO `tb_operation_log` VALUES (1185, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n# 算法设计基础\\n\\n## 1. 算法的基本概念\\n\\n1. 算法的含义：\\n\\n   算法是为了解决某一问题而采用的方法与步骤\\n\\n2. 算法的5个特征：\\n\\n   * 确定性\\n   * 可行性\\n   * 有限性\\n   * 输入性\\n   * 输出型\\n\\n3. 算法的设计目标：\\n\\n   * 正确性\\n   * 可使用性\\n   * 可读性\\n   * 健壮性\\n   * 高效率与低存储量\\n\\n4. 算法的分析：\\n\\n   * 时间复杂度：\\n\\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，ni傲视问题的规模\\n\\n     * *O(1)*：没有循环，每个语句只执行一遍\\n\\n     * *O(n)*：一层循环，循环n次，循环里面的语句执行n次\\n\\n     * *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\\n\\n       ```c++\\n       int i = 0;\\n       int sum = 0;\\n       while {\\n         sum = sum + i; /*执行log (2)n次*/\\n         i = i * 2;     /*执行log (2)n次*/\\n       }\\n       ```\\n\\n     * *O(n<sup>2</sup>)*：双重循环，*n\\\\*n* 或者*n\\\\*m*\\n\\n       ```c++\\n       int sum = 0;\\n       for (int i = 0; i < n; i ++){\\n         for (int j = 0; j < m; i ++){\\n           sum = sum + i * j;      /*执行n*m次*/\\n         }\\n       }\\n       ```\\n\\n     * *O(2<sup>n</sup>)*：斐波那契数列的递归算法\\n\\n     * *O(n!)*：旅行商问题\\n\\n     **上述算法中，*O(2<sup>n</sup>)*和*O(n!)*是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法**\\n\\n## 2. 蛮力法\\n\\n1. 基本思想：\\n\\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\\n\\n2. 蛮力法的要点：\\n\\n   循环、选择\\n\\n3. 蛮力法的应用：\\n\\n   * 顺序查找(*O(n)*)：从 1 查到 n\\n\\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\\n\\n     ```c++\\n     for (int i = 0; i < n - 1; i ++){\\n       for (int j = 0; j = n - i - 1; j++){\\n         if (a[j] > a[j+1]){\\n           temp = a[j];\\n           a[j] = a[j+1];\\n           a[j+1] = a[j];\\n         }\\n       }\\n     }\\n     ```\\n\\n   * 直接选择排序：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\\n\\n     ```c++\\n     int i,j,min;\\n     int temp;\\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\\n       min = i;   //用min记录无序区中最小元素的位置\\n       for(j = i + 1; j < n; j++){\\n         if (a[j] < a[min])\\n     \\t\\tmin=j;\\n       }\\n     \\tif (min! = i){ //若a[i]不是最小元素\\n     \\t \\ttemp=a[i];//将a[min]与a[i]交换\\n       \\ta[i]=a[min];\\n       \\ta[min]=temp;\\n     \\t}\\n     }\\n     ```\\n\\n   * 直接插入排序：\\n\\n     \",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg\",\"articleTitle\":\"算法设计基础\",\"categoryName\":\"学习和技术总结\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"算法\"],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.101', '山西省太原市 移动', '2022-06-22 01:58:55', NULL);
INSERT INTO `tb_operation_log` VALUES (1186, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n# 算法设计基础\\n\\n## 1. 算法的基本概念\\n\\n1. 算法的含义：\\n\\n   算法是为了解决某一问题而采用的方法与步骤\\n\\n2. 算法的5个特征：\\n\\n   * 确定性\\n   * 可行性\\n   * 有限性\\n   * 输入性\\n   * 输出型\\n\\n3. 算法的设计目标：\\n\\n   * 正确性\\n   * 可使用性\\n   * 可读性\\n   * 健壮性\\n   * 高效率与低存储量\\n\\n4. 算法的分析：\\n\\n   * 时间复杂度：\\n\\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，ni傲视问题的规模\\n\\n     * *O(1)*：没有循环，每个语句只执行一遍\\n\\n     * *O(n)*：一层循环，循环n次，循环里面的语句执行n次\\n\\n     * *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\\n\\n       ```c++\\n       int i = 0;\\n       int sum = 0;\\n       while {\\n         sum = sum + i; /*执行log (2)n次*/\\n         i = i * 2;     /*执行log (2)n次*/\\n       }\\n       ```\\n\\n     * *O(n<sup>2</sup>)*：双重循环，*n\\\\*n* 或者*n\\\\*m*\\n\\n       ```c++\\n       int sum = 0;\\n       for (int i = 0; i < n; i ++){\\n         for (int j = 0; j < m; i ++){\\n           sum = sum + i * j;      /*执行n*m次*/\\n         }\\n       }\\n       ```\\n\\n     * *O(2<sup>n</sup>)*：斐波那契数列的递归算法\\n\\n     * *O(n!)*：旅行商问题\\n\\n     ** 上述算法中，*O(2<sup>n</sup>)*和*O(n!)*是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法 **\\n\\n## 2. 蛮力法\\n\\n1. 基本思想：\\n\\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\\n\\n2. 蛮力法的要点：\\n\\n   循环、选择\\n\\n3. 蛮力法的应用：\\n\\n   * 顺序查找(*O(n)*)：从 1 查到 n\\n\\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\\n\\n     ```c++\\n     for (int i = 0; i < n - 1; i ++){\\n       for (int j = 0; j = n - i - 1; j++){\\n         if (a[j] > a[j+1]){\\n           temp = a[j];\\n           a[j] = a[j+1];\\n           a[j+1] = a[j];\\n         }\\n       }\\n     }\\n     ```\\n\\n   * 直接选择排序：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\\n\\n     ```c++\\n     int i,j,min;\\n     int temp;\\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\\n       min = i;   //用min记录无序区中最小元素的位置\\n       for(j = i + 1; j < n; j++){\\n         if (a[j] < a[min])\\n     \\t\\tmin=j;\\n       }\\n     \\tif (min! = i){ //若a[i]不是最小元素\\n     \\t \\ttemp=a[i];//将a[min]与a[i]交换\\n       \\ta[i]=a[min];\\n       \\ta[min]=temp;\\n     \\t}\\n     }\\n     ```\\n\\n   * 直接插入排序：\\n\\n     \",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg\",\"articleTitle\":\"算法设计基础\",\"categoryName\":\"学习和技术总结\",\"id\":63,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.104', '山西省太原市 移动', '2022-06-22 02:00:34', NULL);
INSERT INTO `tb_operation_log` VALUES (1187, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n# 算法设计基础\\n\\n## 1. 算法的基本概念\\n\\n1. 算法的含义：\\n\\n   算法是为了解决某一问题而采用的方法与步骤\\n\\n2. 算法的5个特征：\\n\\n   * 确定性\\n   * 可行性\\n   * 有限性\\n   * 输入性\\n   * 输出型\\n\\n3. 算法的设计目标：\\n\\n   * 正确性\\n   * 可使用性\\n   * 可读性\\n   * 健壮性\\n   * 高效率与低存储量\\n\\n4. 算法的分析：\\n\\n   * 时间复杂度：\\n\\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，ni傲视问题的规模\\n\\n     * *O(1)*：没有循环，每个语句只执行一遍\\n\\n     * *O(n)*：一层循环，循环n次，循环里面的语句执行n次\\n\\n     * *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\\n\\n       ```c++\\n       int i = 0;\\n       int sum = 0;\\n       while {\\n         sum = sum + i; /*执行log (2)n次*/\\n         i = i * 2;     /*执行log (2)n次*/\\n       }\\n       ```\\n\\n     * *O(n<sup>2</sup>)*：双重循环，*n\\\\*n* 或者*n\\\\*m*\\n\\n       ```c++\\n       int sum = 0;\\n       for (int i = 0; i < n; i ++){\\n         for (int j = 0; j < m; i ++){\\n           sum = sum + i * j;      /*执行n*m次*/\\n         }\\n       }\\n       ```\\n\\n     * *O(2<sup>n</sup>)*：斐波那契数列的递归算法\\n\\n     * *O(n!)*：旅行商问题\\n\\n     **上述算法中，*O(2<sup>n</sup>)* 和 *O(n!)* 是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法**\\n\\n## 2. 蛮力法\\n\\n1. 基本思想：\\n\\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\\n\\n2. 蛮力法的要点：\\n\\n   循环、选择\\n\\n3. 蛮力法的应用：\\n\\n   * 顺序查找(*O(n)*)：从 1 查到 n\\n\\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\\n\\n     ```c++\\n     for (int i = 0; i < n - 1; i ++){\\n       for (int j = 0; j = n - i - 1; j++){\\n         if (a[j] > a[j+1]){\\n           temp = a[j];\\n           a[j] = a[j+1];\\n           a[j+1] = a[j];\\n         }\\n       }\\n     }\\n     ```\\n\\n   * 直接选择排序：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\\n\\n     ```c++\\n     int i,j,min;\\n     int temp;\\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\\n       min = i;   //用min记录无序区中最小元素的位置\\n       for(j = i + 1; j < n; j++){\\n         if (a[j] < a[min])\\n     \\t\\tmin=j;\\n       }\\n     \\tif (min! = i){ //若a[i]不是最小元素\\n     \\t \\ttemp=a[i];//将a[min]与a[i]交换\\n       \\ta[i]=a[min];\\n       \\ta[min]=temp;\\n     \\t}\\n     }\\n     ```\\n\\n   * 直接插入排序：\\n\\n     \",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg\",\"articleTitle\":\"算法设计基础\",\"categoryName\":\"学习和技术总结\",\"id\":63,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.101', '山西省太原市 移动', '2022-06-22 02:04:28', NULL);
INSERT INTO `tb_operation_log` VALUES (1188, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n# 算法设计基础\\n\\n## 1. 算法的基本概念\\n\\n1. 算法的含义：\\n\\n   算法是为了解决某一问题而采用的方法与步骤\\n\\n2. 算法的5个特征：\\n\\n   确定性、可行性、有限性、输入性、输出型\\n\\n3. 算法的设计目标：\\n\\n   * 正确性\\n   * 可使用性\\n   * 可读性\\n   * 健壮性\\n   * 高效率与低存储量\\n\\n4. 算法的分析：\\n\\n   * 时间复杂度：\\n\\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，ni傲视问题的规模\\n\\n     * *O(1)*：没有循环，每个语句只执行一遍\\n\\n     * *O(n)*：一层循环，循环n次，循环里面的语句执行n次\\n\\n     * *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\\n\\n       ```c++\\n       int i = 0;\\n       int sum = 0;\\n       while {\\n         sum = sum + i; /*执行log (2)n次*/\\n         i = i * 2;     /*执行log (2)n次*/\\n       }\\n       ```\\n\\n     * *O(n<sup>2</sup>)*：双重循环，*n\\\\*n* 或者*n\\\\*m*\\n\\n       ```c++\\n       int sum = 0;\\n       for (int i = 0; i < n; i ++){\\n         for (int j = 0; j < m; i ++){\\n           sum = sum + i * j;      /*执行n*m次*/\\n         }\\n       }\\n       ```\\n\\n     * *O(2<sup>n</sup>)*：斐波那契数列的递归算法\\n\\n     * *O(n!)*：旅行商问题\\n\\n     **上述算法中，*O(2<sup>n</sup>)* 和 *O(n!)* 是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法**\\n\\n## 2. 蛮力法\\n\\n1. 基本思想：\\n\\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\\n\\n2. 蛮力法的要点：\\n\\n   循环、选择\\n\\n3. 蛮力法的应用：\\n\\n   * 顺序查找(*O(n)*)：从 1 查到 n\\n\\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\\n\\n     ```c++\\n     for (int i = 0; i < n - 1; i ++){\\n       for (int j = 0; j = n - i - 1; j++){\\n         if (a[j] > a[j+1]){\\n           temp = a[j];\\n           a[j] = a[j+1];\\n           a[j+1] = a[j];\\n         }\\n       }\\n     }\\n     ```\\n\\n   * 直接选择排序：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\\n\\n     ```c++\\n     int i,j,min;\\n     int temp;\\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\\n       min = i;   //用min记录无序区中最小元素的位置\\n       for(j = i + 1; j < n; j++){\\n         if (a[j] < a[min])\\n     \\t\\tmin=j;\\n       }\\n     \\tif (min! = i){ //若a[i]不是最小元素\\n     \\t \\ttemp=a[i];//将a[min]与a[i]交换\\n       \\ta[i]=a[min];\\n       \\ta[min]=temp;\\n     \\t}\\n     }\\n     ```\\n\\n   * 直接插入排序：\\n\\n     \",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg\",\"articleTitle\":\"算法设计基础\",\"categoryName\":\"学习和技术总结\",\"id\":63,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-22 10:46:05', NULL);
INSERT INTO `tb_operation_log` VALUES (1189, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n# 算法设计基础\\n\\n## 1. 算法的基本概念\\n\\n1. 算法的含义：\\n\\n   算法是为了解决某一问题而采用的方法与步骤\\n\\n2. 算法的5个特征：\\n\\n   确定性、可行性、有限性、输入性、输出型\\n\\n3. 算法的设计目标：\\n\\n   正确性、可使用性、可读性、健壮性、高效率与低存储量\\n\\n4. 算法的分析：\\n\\n   * 时间复杂度：\\n\\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，ni傲视问题的规模\\n\\n     *O(1)*：没有循环，每个语句只执行一遍\\n\\n     * *O(n)*：一层循环，循环n次，循环里面的语句执行n次\\n\\n     * *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\\n\\n       ```c++\\n       int i = 0;\\n       int sum = 0;\\n       while {\\n         sum = sum + i; /*执行log (2)n次*/\\n         i = i * 2;     /*执行log (2)n次*/\\n       }\\n       ```\\n\\n     * *O(n<sup>2</sup>)*：双重循环，*n\\\\*n* 或者*n\\\\*m*\\n\\n       ```c++\\n       int sum = 0;\\n       for (int i = 0; i < n; i ++){\\n         for (int j = 0; j < m; i ++){\\n           sum = sum + i * j;      /*执行n*m次*/\\n         }\\n       }\\n       ```\\n\\n     * *O(2<sup>n</sup>)*：斐波那契数列的递归算法\\n\\n     * *O(n!)*：旅行商问题\\n\\n     **上述算法中，*O(2<sup>n</sup>)* 和 *O(n!)* 是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法**\\n\\n## 2. 蛮力法\\n\\n1. 基本思想：\\n\\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\\n\\n2. 蛮力法的要点：\\n\\n   循环、选择\\n\\n3. 蛮力法的应用：\\n\\n   * 顺序查找(*O(n)*)：从 1 查到 n\\n\\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\\n\\n     ```c++\\n     for (int i = 0; i < n - 1; i ++){\\n       for (int j = 0; j = n - i - 1; j++){\\n         if (a[j] > a[j+1]){\\n           temp = a[j];\\n           a[j] = a[j+1];\\n           a[j+1] = a[j];\\n         }\\n       }\\n     }\\n     ```\\n\\n   * 直接选择排序：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\\n\\n     ```c++\\n     int i,j,min;\\n     int temp;\\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\\n       min = i;   //用min记录无序区中最小元素的位置\\n       for(j = i + 1; j < n; j++){\\n         if (a[j] < a[min])\\n     \\t\\tmin=j;\\n       }\\n     \\tif (min! = i){ //若a[i]不是最小元素\\n     \\t \\ttemp=a[i];//将a[min]与a[i]交换\\n       \\ta[i]=a[min];\\n       \\ta[min]=temp;\\n     \\t}\\n     }\\n     ```\\n\\n   * 直接插入排序：\\n\\n     \",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg\",\"articleTitle\":\"算法设计基础\",\"categoryName\":\"学习和技术总结\",\"id\":63,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-22 10:47:24', NULL);
INSERT INTO `tb_operation_log` VALUES (1190, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n# 算法设计基础\\n\\n## 1. 算法的基本概念\\n\\n1. 算法的含义：\\n\\n   算法是为了解决某一问题而采用的方法与步骤\\n\\n2. 算法的5个特征：\\n\\n   确定性、可行性、有限性、输入性、输出型\\n\\n3. 算法的设计目标：\\n\\n   正确性、可使用性、可读性、健壮性、高效率与低存储量\\n\\n4. 算法的分析：\\n\\n   * 时间复杂度：\\n\\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，ni傲视问题的规模\\n\\n       * *O(1)*：没有循环，每个语句只执行一遍\\n\\n     * *O(n)*：一层循环，循环n次，循环里面的语句执行n次\\n\\n     * *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\\n\\n       ```c++\\n       int i = 0;\\n       int sum = 0;\\n       while {\\n         sum = sum + i; /*执行log (2)n次*/\\n         i = i * 2;     /*执行log (2)n次*/\\n       }\\n       ```\\n\\n     * *O(n<sup>2</sup>)*：双重循环，*n\\\\*n* 或者*n\\\\*m*\\n\\n       ```c++\\n       int sum = 0;\\n       for (int i = 0; i < n; i ++){\\n         for (int j = 0; j < m; i ++){\\n           sum = sum + i * j;      /*执行n*m次*/\\n         }\\n       }\\n       ```\\n\\n     * *O(2<sup>n</sup>)*：斐波那契数列的递归算法\\n\\n     * *O(n!)*：旅行商问题\\n\\n     **上述算法中，*O(2<sup>n</sup>)* 和 *O(n!)* 是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法**\\n\\n## 2. 蛮力法\\n\\n1. 基本思想：\\n\\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\\n\\n2. 蛮力法的要点：\\n\\n   循环、选择\\n\\n3. 蛮力法的应用：\\n\\n   * 顺序查找(*O(n)*)：从 1 查到 n\\n\\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\\n\\n     ```c++\\n     for (int i = 0; i < n - 1; i ++){\\n       for (int j = 0; j = n - i - 1; j++){\\n         if (a[j] > a[j+1]){\\n           temp = a[j];\\n           a[j] = a[j+1];\\n           a[j+1] = a[j];\\n         }\\n       }\\n     }\\n     ```\\n\\n   * 直接选择排序：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\\n\\n     ```c++\\n     int i,j,min;\\n     int temp;\\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\\n       min = i;   //用min记录无序区中最小元素的位置\\n       for(j = i + 1; j < n; j++){\\n         if (a[j] < a[min])\\n     \\t\\tmin=j;\\n       }\\n     \\tif (min! = i){ //若a[i]不是最小元素\\n     \\t \\ttemp=a[i];//将a[min]与a[i]交换\\n       \\ta[i]=a[min];\\n       \\ta[min]=temp;\\n     \\t}\\n     }\\n     ```\\n\\n   * 直接插入排序：\\n\\n     \",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg\",\"articleTitle\":\"算法设计基础\",\"categoryName\":\"学习和技术总结\",\"id\":63,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-22 10:47:59', NULL);
INSERT INTO `tb_operation_log` VALUES (1191, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n# 算法设计基础\\n\\n## 1. 算法的基本概念\\n\\n1. 算法的含义：\\n\\n   算法是为了解决某一问题而采用的方法与步骤\\n\\n2. 算法的5个特征：\\n\\n   确定性、可行性、有限性、输入性、输出型\\n\\n3. 算法的设计目标：\\n\\n   正确性、可使用性、可读性、健壮性、高效率与低存储量\\n\\n4. 算法的分析：\\n\\n   * 时间复杂度：\\n\\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，ni傲视问题的规模\\n     * *O(1)*：没有循环，每个语句只执行一遍\\n     * *O(n)*：一层循环，循环n次，循环里面的语句执行n次\\n     * *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\\n\\n       ```c++\\n       int i = 0;\\n       int sum = 0;\\n       while {\\n         sum = sum + i; /*执行log (2)n次*/\\n         i = i * 2;     /*执行log (2)n次*/\\n       }\\n       ```\\n\\n     * *O(n<sup>2</sup>)*：双重循环，*n\\\\*n* 或者*n\\\\*m*\\n\\n       ```c++\\n       int sum = 0;\\n       for (int i = 0; i < n; i ++){\\n         for (int j = 0; j < m; i ++){\\n           sum = sum + i * j;      /*执行n*m次*/\\n         }\\n       }\\n       ```\\n\\n     * *O(2<sup>n</sup>)*：斐波那契数列的递归算法\\n\\n     * *O(n!)*：旅行商问题\\n\\n     **上述算法中，*O(2<sup>n</sup>)* 和 *O(n!)* 是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法**\\n\\n## 2. 蛮力法\\n\\n1. 基本思想：\\n\\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\\n\\n2. 蛮力法的要点：\\n\\n   循环、选择\\n\\n3. 蛮力法的应用：\\n\\n   * 顺序查找(*O(n)*)：从 1 查到 n\\n\\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\\n\\n     ```c++\\n     for (int i = 0; i < n - 1; i ++){\\n       for (int j = 0; j = n - i - 1; j++){\\n         if (a[j] > a[j+1]){\\n           temp = a[j];\\n           a[j] = a[j+1];\\n           a[j+1] = a[j];\\n         }\\n       }\\n     }\\n     ```\\n\\n   * 直接选择排序：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\\n\\n     ```c++\\n     int i,j,min;\\n     int temp;\\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\\n       min = i;   //用min记录无序区中最小元素的位置\\n       for(j = i + 1; j < n; j++){\\n         if (a[j] < a[min])\\n     \\t\\tmin=j;\\n       }\\n     \\tif (min! = i){ //若a[i]不是最小元素\\n     \\t \\ttemp=a[i];//将a[min]与a[i]交换\\n       \\ta[i]=a[min];\\n       \\ta[min]=temp;\\n     \\t}\\n     }\\n     ```\\n\\n   * 直接插入排序：\\n\\n     \",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg\",\"articleTitle\":\"算法设计基础\",\"categoryName\":\"学习和技术总结\",\"id\":63,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-22 10:48:47', NULL);
INSERT INTO `tb_operation_log` VALUES (1192, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n# 算法设计基础\\n\\n## 1. 算法的基本概念\\n\\n1. 算法的含义：\\n\\n   算法是为了解决某一问题而采用的方法与步骤\\n\\n2. 算法的5个特征：\\n\\n   确定性、可行性、有限性、输入性、输出型\\n\\n3. 算法的设计目标：\\n\\n   正确性、可使用性、可读性、健壮性、高效率与低存储量\\n\\n4. 算法的分析：\\n\\n   * 时间复杂度：\\n\\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，ni傲视问题的规模\\n     *O(1)*：没有循环，每个语句只执行一遍\\n\\n     *O(n)*：一层循环，循环n次，循环里面的语句执行n次\\n\\n     *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\\n\\n       ```c++\\n       int i = 0;\\n       int sum = 0;\\n       while {\\n         sum = sum + i; /*执行log (2)n次*/\\n         i = i * 2;     /*执行log (2)n次*/\\n       }\\n       ```\\n\\n     - *O(n<sup>2</sup>)*：双重循环，*n\\\\*n* 或者*n\\\\*m*\\n\\n       ```c++\\n       int sum = 0;\\n       for (int i = 0; i < n; i ++){\\n         for (int j = 0; j < m; i ++){\\n           sum = sum + i * j;      /*执行n*m次*/\\n         }\\n       }\\n       ```\\n\\n     * *O(2<sup>n</sup>)*：斐波那契数列的递归算法\\n\\n     * *O(n!)*：旅行商问题\\n\\n     **上述算法中，*O(2<sup>n</sup>)* 和 *O(n!)* 是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法**\\n\\n## 2. 蛮力法\\n\\n1. 基本思想：\\n\\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\\n\\n2. 蛮力法的要点：\\n\\n   循环、选择\\n\\n3. 蛮力法的应用：\\n\\n   * 顺序查找(*O(n)*)：从 1 查到 n\\n\\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\\n\\n     ```c++\\n     for (int i = 0; i < n - 1; i ++){\\n       for (int j = 0; j = n - i - 1; j++){\\n         if (a[j] > a[j+1]){\\n           temp = a[j];\\n           a[j] = a[j+1];\\n           a[j+1] = a[j];\\n         }\\n       }\\n     }\\n     ```\\n\\n   * 直接选择排序：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\\n\\n     ```c++\\n     int i,j,min;\\n     int temp;\\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\\n       min = i;   //用min记录无序区中最小元素的位置\\n       for(j = i + 1; j < n; j++){\\n         if (a[j] < a[min])\\n     \\t\\tmin=j;\\n       }\\n     \\tif (min! = i){ //若a[i]不是最小元素\\n     \\t \\ttemp=a[i];//将a[min]与a[i]交换\\n       \\ta[i]=a[min];\\n       \\ta[min]=temp;\\n     \\t}\\n     }\\n     ```\\n\\n   * 直接插入排序：\\n\\n     \",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg\",\"articleTitle\":\"算法设计基础\",\"categoryName\":\"学习和技术总结\",\"id\":63,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-22 10:49:45', NULL);
INSERT INTO `tb_operation_log` VALUES (1193, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n# 算法设计基础\\n\\n## 1. 算法的基本概念\\n\\n1. 算法的含义：\\n\\n   算法是为了解决某一问题而采用的方法与步骤\\n\\n2. 算法的5个特征：\\n\\n   确定性、可行性、有限性、输入性、输出型\\n\\n3. 算法的设计目标：\\n\\n   正确性、可使用性、可读性、健壮性、高效率与低存储量\\n\\n4. 算法的分析：\\n\\n   * 时间复杂度：\\n\\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，ni傲视问题的规模\\n     1. *O(1)*：没有循环，每个语句只执行一遍\\n\\n     2. *O(n)*：一层循环，循环n次，循环里面的语句执行n次\\n\\n     *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\\n\\n       ```c++\\n       int i = 0;\\n       int sum = 0;\\n       while {\\n         sum = sum + i; /*执行log (2)n次*/\\n         i = i * 2;     /*执行log (2)n次*/\\n       }\\n       ```\\n\\n     *O(n<sup>2</sup>)*：双重循环，*n\\\\*n* 或者*n\\\\*m*\\n\\n       ```c++\\n       int sum = 0;\\n       for (int i = 0; i < n; i ++){\\n         for (int j = 0; j < m; i ++){\\n           sum = sum + i * j;      /*执行n*m次*/\\n         }\\n       }\\n       ```\\n\\n     *O(2<sup>n</sup>)*：斐波那契数列的递归算法\\n\\n     *O(n!)*：旅行商问题\\n\\n**上述算法中，*O(2<sup>n</sup>)* 和 *O(n!)* 是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法**\\n\\n## 2. 蛮力法\\n\\n1. 基本思想：\\n\\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\\n\\n2. 蛮力法的要点：\\n\\n   循环、选择\\n\\n3. 蛮力法的应用：\\n\\n   * 顺序查找(*O(n)*)：从 1 查到 n\\n\\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\\n\\n     ```c++\\n     for (int i = 0; i < n - 1; i ++){\\n       for (int j = 0; j = n - i - 1; j++){\\n         if (a[j] > a[j+1]){\\n           temp = a[j];\\n           a[j] = a[j+1];\\n           a[j+1] = a[j];\\n         }\\n       }\\n     }\\n     ```\\n\\n   * 直接选择排序：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\\n\\n     ```c++\\n     int i,j,min;\\n     int temp;\\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\\n       min = i;   //用min记录无序区中最小元素的位置\\n       for(j = i + 1; j < n; j++){\\n         if (a[j] < a[min])\\n     \\t\\tmin=j;\\n       }\\n     \\tif (min! = i){ //若a[i]不是最小元素\\n     \\t \\ttemp=a[i];//将a[min]与a[i]交换\\n       \\ta[i]=a[min];\\n       \\ta[min]=temp;\\n     \\t}\\n     }\\n     ```\\n\\n   * 直接插入排序：\\n\\n     \",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg\",\"articleTitle\":\"算法设计基础\",\"categoryName\":\"学习和技术总结\",\"id\":63,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.102', '山西省太原市 移动', '2022-06-22 10:51:59', NULL);
INSERT INTO `tb_operation_log` VALUES (1194, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n# 算法设计基础\\n\\n## 1. 算法的基本概念\\n\\n1. 算法的含义：\\n\\n   算法是为了解决某一问题而采用的方法与步骤\\n\\n2. 算法的5个特征：\\n\\n   确定性、可行性、有限性、输入性、输出型\\n\\n3. 算法的设计目标：\\n\\n   正确性、可使用性、可读性、健壮性、高效率与低存储量\\n\\n4. 算法的分析：\\n\\n   * 时间复杂度：\\n\\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，ni傲视问题的规模\\n     \\n     - *O(1)*：没有循环，每个语句只执行一遍\\n\\n     2. *O(n)*：一层循环，循环n次，循环里面的语句执行n次\\n\\n     *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\\n\\n       ```c++\\n       int i = 0;\\n       int sum = 0;\\n       while {\\n         sum = sum + i; /*执行log (2)n次*/\\n         i = i * 2;     /*执行log (2)n次*/\\n       }\\n       ```\\n\\n     *O(n<sup>2</sup>)*：双重循环，*n\\\\*n* 或者*n\\\\*m*\\n\\n       ```c++\\n       int sum = 0;\\n       for (int i = 0; i < n; i ++){\\n         for (int j = 0; j < m; i ++){\\n           sum = sum + i * j;      /*执行n*m次*/\\n         }\\n       }\\n       ```\\n\\n     *O(2<sup>n</sup>)*：斐波那契数列的递归算法\\n\\n     *O(n!)*：旅行商问题\\n\\n**上述算法中，*O(2<sup>n</sup>)* 和 *O(n!)* 是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法**\\n\\n## 2. 蛮力法\\n\\n1. 基本思想：\\n\\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\\n\\n2. 蛮力法的要点：\\n\\n   循环、选择\\n\\n3. 蛮力法的应用：\\n\\n   * 顺序查找(*O(n)*)：从 1 查到 n\\n\\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\\n\\n     ```c++\\n     for (int i = 0; i < n - 1; i ++){\\n       for (int j = 0; j = n - i - 1; j++){\\n         if (a[j] > a[j+1]){\\n           temp = a[j];\\n           a[j] = a[j+1];\\n           a[j+1] = a[j];\\n         }\\n       }\\n     }\\n     ```\\n\\n   * 直接选择排序：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\\n\\n     ```c++\\n     int i,j,min;\\n     int temp;\\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\\n       min = i;   //用min记录无序区中最小元素的位置\\n       for(j = i + 1; j < n; j++){\\n         if (a[j] < a[min])\\n     \\t\\tmin=j;\\n       }\\n     \\tif (min! = i){ //若a[i]不是最小元素\\n     \\t \\ttemp=a[i];//将a[min]与a[i]交换\\n       \\ta[i]=a[min];\\n       \\ta[min]=temp;\\n     \\t}\\n     }\\n     ```\\n\\n   * 直接插入排序：\\n\\n     \",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg\",\"articleTitle\":\"算法设计基础\",\"categoryName\":\"学习和技术总结\",\"id\":63,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.102', '山西省太原市 移动', '2022-06-22 10:53:05', NULL);
INSERT INTO `tb_operation_log` VALUES (1195, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n# 算法设计基础\\n\\n## 1. 算法的基本概念\\n\\n1. 算法的含义：\\n\\n   算法是为了解决某一问题而采用的方法与步骤\\n\\n2. 算法的5个特征：\\n\\n   确定性、可行性、有限性、输入性、输出型\\n\\n3. 算法的设计目标：\\n\\n   正确性、可使用性、可读性、健壮性、高效率与低存储量\\n\\n4. 算法的分析：\\n\\n   * 时间复杂度：\\n\\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，ni傲视问题的规模\\n     \\n     1. *O(1)*：没有循环，每个语句只执行一遍\\n\\n     2. *O(n)*：一层循环，循环n次，循环里面的语句执行n次\\n\\n     3. *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\\n\\n       ```c++\\n       int i = 0;\\n       int sum = 0;\\n       while {\\n         sum = sum + i; /*执行log (2)n次*/\\n         i = i * 2;     /*执行log (2)n次*/\\n       }\\n       ```\\n\\n     4. *O(n<sup>2</sup>)*：双重循环，*n\\\\*n* 或者*n\\\\*m*\\n\\n       ```c++\\n       int sum = 0;\\n       for (int i = 0; i < n; i ++){\\n         for (int j = 0; j < m; i ++){\\n           sum = sum + i * j;      /*执行n*m次*/\\n         }\\n       }\\n       ```\\n\\n     5. *O(2<sup>n</sup>)*：斐波那契数列的递归算法\\n\\n     6. *O(n!)*：旅行商问题\\n\\n**上述算法中，*O(2<sup>n</sup>)* 和 *O(n!)* 是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法**\\n\\n## 2. 蛮力法\\n\\n1. 基本思想：\\n\\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\\n\\n2. 蛮力法的要点：\\n\\n   循环、选择\\n\\n3. 蛮力法的应用：\\n\\n   * 顺序查找(*O(n)*)：从 1 查到 n\\n\\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\\n\\n     ```c++\\n     for (int i = 0; i < n - 1; i ++){\\n       for (int j = 0; j = n - i - 1; j++){\\n         if (a[j] > a[j+1]){\\n           temp = a[j];\\n           a[j] = a[j+1];\\n           a[j+1] = a[j];\\n         }\\n       }\\n     }\\n     ```\\n\\n   * 直接选择排序：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\\n\\n     ```c++\\n     int i,j,min;\\n     int temp;\\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\\n       min = i;   //用min记录无序区中最小元素的位置\\n       for(j = i + 1; j < n; j++){\\n         if (a[j] < a[min])\\n     \\t\\tmin=j;\\n       }\\n     \\tif (min! = i){ //若a[i]不是最小元素\\n     \\t \\ttemp=a[i];//将a[min]与a[i]交换\\n       \\ta[i]=a[min];\\n       \\ta[min]=temp;\\n     \\t}\\n     }\\n     ```\\n\\n   * 直接插入排序：\\n\\n     \",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg\",\"articleTitle\":\"算法设计基础\",\"categoryName\":\"学习和技术总结\",\"id\":63,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.102', '山西省太原市 移动', '2022-06-22 10:53:55', NULL);
INSERT INTO `tb_operation_log` VALUES (1196, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"[TOC]\\n\\n# 算法设计基础\\n\\n## 1. 算法的基本概念\\n\\n1. 算法的含义：\\n\\n   算法是为了解决某一问题而采用的方法与步骤\\n\\n2. 算法的5个特征：\\n\\n   * 确定性\\n   * 可行性\\n   * 有限性\\n   * 输入性\\n   * 输出型\\n\\n3. 算法的设计目标：\\n\\n   * 正确性\\n   * 可使用性\\n   * 可读性\\n   * 健壮性\\n   * 高效率与低存储量\\n\\n4. 算法的分析：\\n\\n   * 时间复杂度：\\n\\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，ni傲视问题的规模\\n\\n     1. *O(1)*：没有循环，每个语句只执行一遍\\n\\n     2. *O(n)*：一层循环，循环n次，循环里面的语句执行n次\\n\\n     3. *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\\n\\n     ```c++\\n     int i = 0;\\n     int sum = 0;\\n     while {\\n       sum = sum + i; /*执行log (2)n次*/\\n       i = i * 2;     /*执行log (2)n次*/\\n     }\\n     ```\\n\\n     4. *O(n<sup>2</sup>)*：双重循环，*n\\\\*n* 或者*n\\\\*m*\\n\\n     ```c++\\n     int sum = 0;\\n     for (int i = 0; i < n; i ++){\\n       for (int j = 0; j < m; i ++){\\n         sum = sum + i * j;      /*执行n*m次*/\\n       }\\n     }\\n     ```\\n\\n     5. *O(2<sup>n</sup>)*：斐波那契数列的递归算法\\n\\n     6. *O(n!)*：旅行商问题\\n\\n**上述算法中，*O(2<sup>n</sup>)* 和 *O(n!)* 是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法**\\n     \\n\\n## 2. 蛮力法\\n\\n1. 基本思想：\\n\\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\\n\\n2. 蛮力法的要点：\\n\\n   循环、选择\\n\\n3. 蛮力法的应用：\\n\\n   * 顺序查找(*O(n)*)：从 1 查到 n\\n\\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\\n\\n     ```c++\\n     for (int i = 0; i < n - 1; i ++){\\n       for (int j = 0; j = n - i - 1; j++){\\n         if (a[j] > a[j+1]){\\n           temp = a[j];\\n           a[j] = a[j+1];\\n           a[j+1] = a[j];\\n         }\\n       }\\n     }\\n     ```\\n\\n   * 直接选择排序*O(n<sup>2</sup>)*：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\\n\\n     ```c++\\n     int i,j,min;\\n     int temp;\\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\\n       min = i;   //用min记录无序区中最小元素的位置\\n       for(j = i + 1; j < n; j++){\\n         if (a[j] < a[min])\\n     \\t\\tmin=j;\\n       }\\n     \\tif (min! = i){ //若a[i]不是最小元素\\n     \\t \\ttemp=a[i];//将a[min]与a[i]交换\\n       \\ta[i]=a[min];\\n       \\ta[min]=temp;\\n     \\t}\\n     }\\n     ```\\n\\n   * 直接插入排序*O(n<sup>2</sup>)*：分为有序区和无序区，每一趟排序都将无序区中的第一个元素插入有序区中（插入过程蛮力法），让插入的元素和有序区的最后一个元素比较。\\n\\n     ```c++\\n     int i, j;\\n     int t;\\n     for (i = 0; i < n - 1; i++){\\n       t = a[i+1];\\n       j = i;\\n       while (t < a[j] && j >= 0){\\n         a[j+1] = a[j];\\n         j--;\\n       }\\n       a[j+1] = t;\\n     }\\n     ```\\n\\n## 2. 分治法\\n\\n1. 基本思想：\\n\\n   把一个复杂的问题分解成多个相同或相似的子问题，然后直接或间接地调用自己\\n\\n2. 递归实施步骤：\\n\\n   1. 根据实际构建递归关系（递归式）\\n   2. 确定递归边界（递归出口）\\n   3. 编写递归函数\\n   4. 设计主函数调用递归函数\\n\\n3. 汉诺塔的时间复杂度分析：\\n\\n   设盘子个数为 *n* 时，需要 *T(n)* 步，把 *A* 柱子 *n-1* 个盘子移到 *B* 柱子，需要 *T(n-1)* 步， *A* 柱子最后一个盘子移到 *C* 柱子一步，*B* 柱子上 *n-1* 个盘子移到 *C* 柱子上 *T(n-1)* 步。得递推公式 *T(n) = 2T(n-1) + 1*\\n   所以汉诺塔问题的时间复杂度为 *O(2<sup>n</sup>)*\\n\\n## 3. 贪心法\\n\\n1. 基本思想：\\n\\n   把复杂问题分解成若干个简单问题，每一步都做出在当前看最好的选择（局部最优）\\n\\n2. 算法应用：\\n\\n   哈夫曼树是带权路径最小的二叉树\\n\\n3. 最近顶点策略 Prim 算法：\\n\\n4. 最短边策略 Kruskal 算法：\\n\\n## 4. 动态规划算法\\n\\n1. 基本思想：\\n\\n   将待求解的问题按阶段分解成若干个子问题，其中各个子问题的解都是当前状态下所得的最优解（全局最优）\\n\\n2. 算法工具：\\n\\n   最优决策表：行代表问题的阶段，列代表问题的状态\\n\\n3. 最长公共子序列：\\n\\n   > 求序列 {34,52,18,6,76,322,145,57} 和 {2,18,54,6,78,145,57,9} 的最长公共子序列\\n   >\\n   > |      | 34   | 52   | 18                               | 6                                | 76   | 322  | 145                              | 57                               |\\n   > | :--- | :--- | ---- | -------------------------------- | -------------------------------- | ---- | ---- | -------------------------------- | -------------------------------- |\\n   > | 2    | 0    | 0    | 0                                | 0                                | 0    | 0    | 0                                | 0                                |\\n   > | 18   | 0    | 0    | ==<font color = \\\"red\\\">1</font>== | 1                                | 1    | 1    | 1                                | 1                                |\\n   > | 54   | 0    | 0    | 1                                | 1                                | 1    | 1    | 1                                | 1                                |\\n   > | 6    | 0    | 0    | 1                                | ==<font color = \\\"red\\\">2</font>== | 2    | 2    | 2                                | 2                                |\\n   > | 78   | 0    | 0    | 1                                | 2                                | 2    | 2    | 2                                | 2                                |\\n   > | 145  | 0    | 0    | 1                                | 2                                | 2    | 2    | ==<font color = \\\"red\\\">3</font>== | 3                                |\\n   > | 57   | 0    | 0    | 1                                | 2                                | 2    | 2    | 3                                | ==<font color = \\\"red\\\">4</font>== |\\n   > | 9    | 0    | 0    | 1                                | 2                                | 2    | 2    | 3                                | 4                                |\\n   >\\n   > 最长公共子序列：{18，6，145，5}\\n\\n4. 排队购票：\\n\\n## 5. 回溯法\\n\\n\\n\\n## 6. 分支限界法\\n\\n1. 分支限界法和回溯法的区别：\\n\\n   回溯法一深度优先策略搜索解空间树，分支限界法则以广度优先策略搜索解空间树\\n\\n \",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg\",\"articleTitle\":\"算法设计基础\",\"categoryName\":\"学习和技术总结\",\"id\":63,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.104', '山西省太原市 移动', '2022-06-22 14:47:46', NULL);
INSERT INTO `tb_operation_log` VALUES (1197, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n# 算法设计基础\\n\\n## 1. 算法的基本概念\\n\\n1. 算法的含义：\\n\\n   算法是为了解决某一问题而采用的方法与步骤\\n\\n2. 算法的5个特征：\\n\\n   确定性、可行性、有限性、输入性、输出型\\n\\n3. 算法的设计目标：\\n\\n   正确性、可使用性、可读性、健壮性、高效率与低存储量\\n   \\n4. 算法的分析：\\n\\n   * 时间复杂度：\\n\\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，ni傲视问题的规模\\n\\n     1. *O(1)*：没有循环，每个语句只执行一遍\\n\\n     2. *O(n)*：一层循环，循环n次，循环里面的语句执行n次\\n\\n     3. *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\\n\\n     ```c++\\n     int i = 0;\\n     int sum = 0;\\n     while {\\n       sum = sum + i; /*执行log (2)n次*/\\n       i = i * 2;     /*执行log (2)n次*/\\n     }\\n     ```\\n\\n     4. *O(n<sup>2</sup>)*：双重循环，*n\\\\*n* 或者*n\\\\*m*\\n\\n     ```c++\\n     int sum = 0;\\n     for (int i = 0; i < n; i ++){\\n       for (int j = 0; j < m; i ++){\\n         sum = sum + i * j;      /*执行n*m次*/\\n       }\\n     }\\n     ```\\n\\n     5. *O(2<sup>n</sup>)*：斐波那契数列的递归算法\\n\\n     6. *O(n!)*：旅行商问题\\n\\n**上述算法中，*O(2<sup>n</sup>)* 和 *O(n!)* 是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法**\\n     \\n\\n## 2. 蛮力法\\n\\n1. 基本思想：\\n\\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\\n\\n2. 蛮力法的要点：\\n\\n   循环、选择\\n\\n3. 蛮力法的应用：\\n\\n   * 顺序查找(*O(n)*)：从 1 查到 n\\n\\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\\n\\n     ```c++\\n     for (int i = 0; i < n - 1; i ++){\\n       for (int j = 0; j = n - i - 1; j++){\\n         if (a[j] > a[j+1]){\\n           temp = a[j];\\n           a[j] = a[j+1];\\n           a[j+1] = a[j];\\n         }\\n       }\\n     }\\n     ```\\n\\n   * 直接选择排序*O(n<sup>2</sup>)*：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\\n\\n     ```c++\\n     int i,j,min;\\n     int temp;\\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\\n       min = i;   //用min记录无序区中最小元素的位置\\n       for(j = i + 1; j < n; j++){\\n         if (a[j] < a[min])\\n     \\t\\tmin=j;\\n       }\\n     \\tif (min! = i){ //若a[i]不是最小元素\\n     \\t \\ttemp=a[i];//将a[min]与a[i]交换\\n       \\ta[i]=a[min];\\n       \\ta[min]=temp;\\n     \\t}\\n     }\\n     ```\\n\\n   * 直接插入排序*O(n<sup>2</sup>)*：分为有序区和无序区，每一趟排序都将无序区中的第一个元素插入有序区中（插入过程蛮力法），让插入的元素和有序区的最后一个元素比较。\\n\\n     ```c++\\n     int i, j;\\n     int t;\\n     for (i = 0; i < n - 1; i++){\\n       t = a[i+1];\\n       j = i;\\n       while (t < a[j] && j >= 0){\\n         a[j+1] = a[j];\\n         j--;\\n       }\\n       a[j+1] = t;\\n     }\\n     ```\\n\\n## 2. 分治法\\n\\n1. 基本思想：\\n\\n   把一个复杂的问题分解成多个相同或相似的子问题，然后直接或间接地调用自己\\n\\n2. 递归实施步骤：\\n\\n   1. 根据实际构建递归关系（递归式）\\n   2. 确定递归边界（递归出口）\\n   3. 编写递归函数\\n   4. 设计主函数调用递归函数\\n\\n3. 汉诺塔的时间复杂度分析：\\n\\n   设盘子个数为 *n* 时，需要 *T(n)* 步，把 *A* 柱子 *n-1* 个盘子移到 *B* 柱子，需要 *T(n-1)* 步， *A* 柱子最后一个盘子移到 *C* 柱子一步，*B* 柱子上 *n-1* 个盘子移到 *C* 柱子上 *T(n-1)* 步。得递推公式 *T(n) = 2T(n-1) + 1*\\n   所以汉诺塔问题的时间复杂度为 *O(2<sup>n</sup>)*\\n\\n## 3. 贪心法\\n\\n1. 基本思想：\\n\\n   把复杂问题分解成若干个简单问题，每一步都做出在当前看最好的选择（局部最优）\\n\\n2. 算法应用：\\n\\n   哈夫曼树是带权路径最小的二叉树\\n\\n3. 最近顶点策略 Prim 算法：\\n\\n4. 最短边策略 Kruskal 算法：\\n\\n## 4. 动态规划算法\\n\\n1. 基本思想：\\n\\n   将待求解的问题按阶段分解成若干个子问题，其中各个子问题的解都是当前状态下所得的最优解（全局最优）\\n\\n2. 算法工具：\\n\\n   最优决策表：行代表问题的阶段，列代表问题的状态\\n\\n3. 最长公共子序列：\\n\\n   > 求序列 {34,52,18,6,76,322,145,57} 和 {2,18,54,6,78,145,57,9} 的最长公共子序列\\n   >\\n   > |      | 34   | 52   | 18                               | 6                                | 76   | 322  | 145                              | 57                               |\\n   > | :--- | :--- | ---- | -------------------------------- | -------------------------------- | ---- | ---- | -------------------------------- | -------------------------------- |\\n   > | 2    | 0    | 0    | 0                                | 0                                | 0    | 0    | 0                                | 0                                |\\n   > | 18   | 0    | 0    | ==<font color = \\\"red\\\">1</font>== | 1                                | 1    | 1    | 1                                | 1                                |\\n   > | 54   | 0    | 0    | 1                                | 1                                | 1    | 1    | 1                                | 1                                |\\n   > | 6    | 0    | 0    | 1                                | ==<font color = \\\"red\\\">2</font>== | 2    | 2    | 2                                | 2                                |\\n   > | 78   | 0    | 0    | 1                                | 2                                | 2    | 2    | 2                                | 2                                |\\n   > | 145  | 0    | 0    | 1                                | 2                                | 2    | 2    | ==<font color = \\\"red\\\">3</font>== | 3                                |\\n   > | 57   | 0    | 0    | 1                                | 2                                | 2    | 2    | 3                                | ==<font color = \\\"red\\\">4</font>== |\\n   > | 9    | 0    | 0    | 1                                | 2                                | 2    | 2    | 3                                | 4                                |\\n   >\\n   > 最长公共子序列：{18，6，145，5}\\n\\n4. 排队购票：\\n\\n## 5. 回溯法\\n\\n\\n\\n## 6. 分支限界法\\n\\n1. 分支限界法和回溯法的区别：\\n\\n   回溯法一深度优先策略搜索解空间树，分支限界法则以广度优先策略搜索解空间树\\n\\n \",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg\",\"articleTitle\":\"算法设计基础\",\"categoryName\":\"学习和技术总结\",\"id\":63,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.105', '山西省太原市 移动', '2022-06-22 14:49:35', NULL);
INSERT INTO `tb_operation_log` VALUES (1198, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n# 算法设计基础\\n\\n## 1. 算法的基本概念\\n\\n1. 算法的含义：\\n\\n   算法是为了解决某一问题而采用的方法与步骤\\n\\n2. 算法的5个特征：\\n\\n   确定性、可行性、有限性、输入性、输出型\\n\\n3. 算法的设计目标：\\n\\n   正确性、可使用性、可读性、健壮性、高效率与低存储量\\n   \\n4. 算法的分析：\\n\\n   * 时间复杂度：\\n\\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，n 表示问题的规模\\n\\n     1. *O(1)*：没有循环，每个语句只执行一遍\\n\\n     2. *O(n)*：一层循环，循环n次，循环里面的语句执行n次\\n\\n     3. *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\\n\\n     ```c++\\n     int i = 0;\\n     int sum = 0;\\n     while {\\n       sum = sum + i; /*执行log (2)n次*/\\n       i = i * 2;     /*执行log (2)n次*/\\n     }\\n     ```\\n\\n     4. *O(n<sup>2</sup>)*：双重循环，*n\\\\*n* 或者*n\\\\*m*\\n\\n     ```c++\\n     int sum = 0;\\n     for (int i = 0; i < n; i ++){\\n       for (int j = 0; j < m; i ++){\\n         sum = sum + i * j;      /*执行n*m次*/\\n       }\\n     }\\n     ```\\n\\n     5. *O(2<sup>n</sup>)*：斐波那契数列的递归算法\\n\\n     6. *O(n!)*：旅行商问题\\n\\n**上述算法中，*O(2<sup>n</sup>)* 和 *O(n!)* 是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法**\\n     \\n\\n## 2. 蛮力法\\n\\n1. 基本思想：\\n\\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\\n\\n2. 蛮力法的要点：\\n\\n   循环、选择\\n\\n3. 蛮力法的应用：\\n\\n   * 顺序查找(*O(n)*)：从 1 查到 n\\n\\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\\n\\n     ```c++\\n     for (int i = 0; i < n - 1; i ++){\\n       for (int j = 0; j = n - i - 1; j++){\\n         if (a[j] > a[j+1]){\\n           temp = a[j];\\n           a[j] = a[j+1];\\n           a[j+1] = a[j];\\n         }\\n       }\\n     }\\n     ```\\n\\n   * 直接选择排序*O(n<sup>2</sup>)*：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\\n\\n     ```c++\\n     int i,j,min;\\n     int temp;\\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\\n       min = i;   //用min记录无序区中最小元素的位置\\n       for(j = i + 1; j < n; j++){\\n         if (a[j] < a[min])\\n     \\t\\tmin=j;\\n       }\\n     \\tif (min! = i){ //若a[i]不是最小元素\\n     \\t \\ttemp=a[i];//将a[min]与a[i]交换\\n       \\ta[i]=a[min];\\n       \\ta[min]=temp;\\n     \\t}\\n     }\\n     ```\\n\\n   * 直接插入排序*O(n<sup>2</sup>)*：分为有序区和无序区，每一趟排序都将无序区中的第一个元素插入有序区中（插入过程蛮力法），让插入的元素和有序区的最后一个元素比较。\\n\\n     ```c++\\n     int i, j;\\n     int t;\\n     for (i = 0; i < n - 1; i++){\\n       t = a[i+1];\\n       j = i;\\n       while (t < a[j] && j >= 0){\\n         a[j+1] = a[j];\\n         j--;\\n       }\\n       a[j+1] = t;\\n     }\\n     ```\\n\\n## 2. 分治法\\n\\n1. 基本思想：\\n\\n   把一个复杂的问题分解成多个相同或相似的子问题，然后直接或间接地调用自己\\n\\n2. 递归实施步骤：\\n\\n   1. 根据实际构建递归关系（递归式）\\n   2. 确定递归边界（递归出口）\\n   3. 编写递归函数\\n   4. 设计主函数调用递归函数\\n\\n3. 汉诺塔的时间复杂度分析：\\n\\n   设盘子个数为 *n* 时，需要 *T(n)* 步，把 *A* 柱子 *n-1* 个盘子移到 *B* 柱子，需要 *T(n-1)* 步， *A* 柱子最后一个盘子移到 *C* 柱子一步，*B* 柱子上 *n-1* 个盘子移到 *C* 柱子上 *T(n-1)* 步。得递推公式 *T(n) = 2T(n-1) + 1*\\n   所以汉诺塔问题的时间复杂度为 *O(2<sup>n</sup>)*\\n\\n## 3. 贪心法\\n\\n1. 基本思想：\\n\\n   把复杂问题分解成若干个简单问题，每一步都做出在当前看最好的选择（局部最优）\\n\\n2. 算法应用：\\n\\n   哈夫曼树是带权路径最小的二叉树\\n\\n3. 最近顶点策略 Prim 算法：\\n\\n4. 最短边策略 Kruskal 算法：\\n\\n## 4. 动态规划算法\\n\\n1. 基本思想：\\n\\n   将待求解的问题按阶段分解成若干个子问题，其中各个子问题的解都是当前状态下所得的最优解（全局最优）\\n\\n2. 算法工具：\\n\\n   最优决策表：行代表问题的阶段，列代表问题的状态\\n\\n3. 最长公共子序列：\\n\\n   > 求序列 {34,52,18,6,76,322,145,57} 和 {2,18,54,6,78,145,57,9} 的最长公共子序列\\n   >\\n   > |      | 34   | 52   | 18                               | 6                                | 76   | 322  | 145                              | 57                               |\\n   > | :--- | :--- | ---- | -------------------------------- | -------------------------------- | ---- | ---- | -------------------------------- | -------------------------------- |\\n   > | 2    | 0    | 0    | 0                                | 0                                | 0    | 0    | 0                                | 0                                |\\n   > | 18   | 0    | 0    | ==<font color = \\\"red\\\">1</font>== | 1                                | 1    | 1    | 1                                | 1                                |\\n   > | 54   | 0    | 0    | 1                                | 1                                | 1    | 1    | 1                                | 1                                |\\n   > | 6    | 0    | 0    | 1                                | ==<font color = \\\"red\\\">2</font>== | 2    | 2    | 2                                | 2                                |\\n   > | 78   | 0    | 0    | 1                                | 2                                | 2    | 2    | 2                                | 2                                |\\n   > | 145  | 0    | 0    | 1                                | 2                                | 2    | 2    | ==<font color = \\\"red\\\">3</font>== | 3                                |\\n   > | 57   | 0    | 0    | 1                                | 2                                | 2    | 2    | 3                                | ==<font color = \\\"red\\\">4</font>== |\\n   > | 9    | 0    | 0    | 1                                | 2                                | 2    | 2    | 3                                | 4                                |\\n   >\\n   > 最长公共子序列：{18，6，145，5}\\n\\n4. 排队购票：\\n\\n## 5. 回溯法\\n\\n\\n\\n## 6. 分支限界法\\n\\n1. 分支限界法和回溯法的区别：\\n\\n   回溯法一深度优先策略搜索解空间树，分支限界法则以广度优先策略搜索解空间树\\n\\n \",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg\",\"articleTitle\":\"算法设计基础\",\"categoryName\":\"学习和技术总结\",\"id\":63,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.101', '山西省太原市 移动', '2022-06-22 15:11:20', NULL);
INSERT INTO `tb_operation_log` VALUES (1199, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n# 算法设计基础\\n\\n## 1. 算法的基本概念\\n\\n1. 算法的含义：\\n\\n   算法是为了解决某一问题而采用的方法与步骤\\n\\n2. 算法的5个特征：\\n\\n   确定性、可行性、有限性、输入性、输出型\\n\\n3. 算法的设计目标：\\n\\n   正确性、可使用性、可读性、健壮性、高效率与低存储量\\n   \\n4. 算法的分析：\\n\\n   * 时间复杂度：\\n\\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，n 表示问题的规模\\n\\n     1. *O(1)*：没有循环，每个语句只执行一遍\\n\\n     2. *O(n)*：一层循环，循环n次，循环里面的语句执行n次\\n\\n     3. *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\\n\\n     ```c++\\n     int i = 0;\\n     int sum = 0;\\n     while {\\n       sum = sum + i; /*执行log (2)n次*/\\n       i = i * 2;     /*执行log (2)n次*/\\n     }\\n     ```\\n\\n     4. *O(n<sup>2</sup>)*：双重循环，*n\\\\*n* 或者*n\\\\*m*\\n\\n     ```c++\\n     int sum = 0;\\n     for (int i = 0; i < n; i ++){\\n       for (int j = 0; j < m; i ++){\\n         sum = sum + i * j;      /*执行n*m次*/\\n       }\\n     }\\n     ```\\n\\n     5. *O(2<sup>n</sup>)*：斐波那契数列的递归算法\\n\\n     6. *O(n!)*：旅行商问题\\n\\n**上述算法中，*O(2<sup>n</sup>)* 和 *O(n!)* 是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法**\\n     \\n\\n## 2. 蛮力法\\n\\n1. 基本思想：\\n\\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\\n\\n2. 蛮力法的要点：\\n\\n   循环、选择\\n\\n3. 蛮力法的应用：\\n\\n   * 顺序查找(*O(n)*)：从 1 查到 n\\n\\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\\n\\n     ```c++\\n     for (int i = 0; i < n - 1; i ++){\\n       for (int j = 0; j = n - i - 1; j++){\\n         if (a[j] > a[j+1]){\\n           temp = a[j];\\n           a[j] = a[j+1];\\n           a[j+1] = a[j];\\n         }\\n       }\\n     }\\n     ```\\n\\n   * 直接选择排序*O(n<sup>2</sup>)*：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\\n\\n     ```c++\\n     int i,j,min;\\n     int temp;\\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\\n       min = i;   //用min记录无序区中最小元素的位置\\n       for(j = i + 1; j < n; j++){\\n         if (a[j] < a[min])\\n     \\t\\tmin=j;\\n       }\\n     \\tif (min! = i){ //若a[i]不是最小元素\\n     \\t \\ttemp=a[i];//将a[min]与a[i]交换\\n       \\ta[i]=a[min];\\n       \\ta[min]=temp;\\n     \\t}\\n     }\\n     ```\\n\\n   * 直接插入排序*O(n<sup>2</sup>)*：分为有序区和无序区，每一趟排序都将无序区中的第一个元素插入有序区中（插入过程蛮力法），让插入的元素和有序区的最后一个元素比较。\\n\\n     ```c++\\n     int i, j;\\n     int t;\\n     for (i = 0; i < n - 1; i++){\\n       t = a[i+1];\\n       j = i;\\n       while (t < a[j] && j >= 0){\\n         a[j+1] = a[j];\\n         j--;\\n       }\\n       a[j+1] = t;\\n     }\\n     ```\\n\\n## 2. 分治法\\n\\n1. 基本思想：\\n\\n   把一个复杂的问题分解成多个相同或相似的子问题，然后直接或间接地调用自己\\n\\n2. 递归实施步骤：\\n\\n   1. 根据实际构建递归关系（递归式）\\n   2. 确定递归边界（递归出口）\\n   3. 编写递归函数\\n   4. 设计主函数调用递归函数\\n\\n3. 汉诺塔的时间复杂度分析：\\n\\n   设盘子个数为 *n* 时，需要 *T(n)* 步，把 *A* 柱子 *n-1* 个盘子移到 *B* 柱子，需要 *T(n-1)* 步， *A* 柱子最后一个盘子移到 *C* 柱子一步，*B* 柱子上 *n-1* 个盘子移到 *C* 柱子上 *T(n-1)* 步。得递推公式 *T(n) = 2T(n-1) + 1*\\n   所以汉诺塔问题的时间复杂度为 *O(2<sup>n</sup>)*\\n\\n## 3. 贪心法\\n\\n1. 基本思想：\\n\\n   把复杂问题分解成若干个简单问题，每一步都做出在当前看最好的选择（局部最优）\\n\\n2. 算法应用：\\n\\n   哈夫曼树是带权路径最小的二叉树\\n\\n3. 最近顶点策略 Prim 算法：\\n\\n4. 最短边策略 Kruskal 算法：\\n\\n## 4. 动态规划算法\\n\\n1. 基本思想：\\n\\n   将待求解的问题按阶段分解成若干个子问题，其中各个子问题的解都是当前状态下所得的最优解（全局最优）\\n\\n2. 算法工具：\\n\\n   最优决策表：行代表问题的阶段，列代表问题的状态\\n\\n3. 最长公共子序列：\\n\\n   > 求序列 {34,52,18,6,76,322,145,57} 和 {2,18,54,6,78,145,57,9} 的最长公共子序列\\n   >\\n   > |      | 34   | 52   | 18                               | 6                                | 76   | 322  | 145                              | 57                               |\\n   > | :--- | :--- | ---- | -------------------------------- | -------------------------------- | ---- | ---- | -------------------------------- | -------------------------------- |\\n   > | 2    | 0    | 0    | 0                                | 0                                | 0    | 0    | 0                                | 0                                |\\n   > | 18   | 0    | 0    | ==1== | 1                                | 1    | 1    | 1                                | 1                                |\\n   > | 54   | 0    | 0    | 1                                | 1                                | 1    | 1    | 1                                | 1                                |\\n   > | 6    | 0    | 0    | 1                                | ==<font color = \\\"red\\\">2</font>== | 2    | 2    | 2                                | 2                                |\\n   > | 78   | 0    | 0    | 1                                | 2                                | 2    | 2    | 2                                | 2                                |\\n   > | 145  | 0    | 0    | 1                                | 2                                | 2    | 2    | ==<font color = \\\"red\\\">3</font>== | 3                                |\\n   > | 57   | 0    | 0    | 1                                | 2                                | 2    | 2    | 3                                | ==<font color = \\\"red\\\">4</font>== |\\n   > | 9    | 0    | 0    | 1                                | 2                                | 2    | 2    | 3                                | 4                                |\\n   >\\n   > 最长公共子序列：{18，6，145，5}\\n\\n4. 排队购票：\\n\\n## 5. 回溯法\\n\\n\\n\\n## 6. 分支限界法\\n\\n1. 分支限界法和回溯法的区别：\\n\\n   回溯法一深度优先策略搜索解空间树，分支限界法则以广度优先策略搜索解空间树\\n\\n \",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg\",\"articleTitle\":\"算法设计基础\",\"categoryName\":\"学习和技术总结\",\"id\":63,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-23 23:55:26', NULL);
INSERT INTO `tb_operation_log` VALUES (1200, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n# 算法设计基础\\n\\n## 1. 算法的基本概念\\n\\n1. 算法的含义：\\n\\n   算法是为了解决某一问题而采用的方法与步骤\\n\\n2. 算法的5个特征：\\n\\n   确定性、可行性、有限性、输入性、输出型\\n\\n3. 算法的设计目标：\\n\\n   正确性、可使用性、可读性、健壮性、高效率与低存储量\\n   \\n4. 算法的分析：\\n\\n   * 时间复杂度：\\n\\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，n 表示问题的规模\\n\\n     1. *O(1)*：没有循环，每个语句只执行一遍\\n\\n     2. *O(n)*：一层循环，循环n次，循环里面的语句执行n次\\n\\n     3. *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\\n\\n     ```c++\\n     int i = 0;\\n     int sum = 0;\\n     while {\\n       sum = sum + i; /*执行log (2)n次*/\\n       i = i * 2;     /*执行log (2)n次*/\\n     }\\n     ```\\n\\n     4. *O(n<sup>2</sup>)*：双重循环，*n\\\\*n* 或者*n\\\\*m*\\n\\n     ```c++\\n     int sum = 0;\\n     for (int i = 0; i < n; i ++){\\n       for (int j = 0; j < m; i ++){\\n         sum = sum + i * j;      /*执行n*m次*/\\n       }\\n     }\\n     ```\\n\\n     5. *O(2<sup>n</sup>)*：斐波那契数列的递归算法\\n\\n     6. *O(n!)*：旅行商问题\\n\\n**上述算法中，*O(2<sup>n</sup>)* 和 *O(n!)* 是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法**\\n     \\n\\n## 2. 蛮力法\\n\\n1. 基本思想：\\n\\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\\n\\n2. 蛮力法的要点：\\n\\n   循环、选择\\n\\n3. 蛮力法的应用：\\n\\n   * 顺序查找(*O(n)*)：从 1 查到 n\\n\\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\\n\\n     ```c++\\n     for (int i = 0; i < n - 1; i ++){\\n       for (int j = 0; j = n - i - 1; j++){\\n         if (a[j] > a[j+1]){\\n           temp = a[j];\\n           a[j] = a[j+1];\\n           a[j+1] = a[j];\\n         }\\n       }\\n     }\\n     ```\\n\\n   * 直接选择排序*O(n<sup>2</sup>)*：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\\n\\n     ```c++\\n     int i,j,min;\\n     int temp;\\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\\n       min = i;   //用min记录无序区中最小元素的位置\\n       for(j = i + 1; j < n; j++){\\n         if (a[j] < a[min])\\n     \\t\\tmin=j;\\n       }\\n     \\tif (min! = i){ //若a[i]不是最小元素\\n     \\t \\ttemp=a[i];//将a[min]与a[i]交换\\n       \\ta[i]=a[min];\\n       \\ta[min]=temp;\\n     \\t}\\n     }\\n     ```\\n\\n   * 直接插入排序*O(n<sup>2</sup>)*：分为有序区和无序区，每一趟排序都将无序区中的第一个元素插入有序区中（插入过程蛮力法），让插入的元素和有序区的最后一个元素比较。\\n\\n     ```c++\\n     int i, j;\\n     int t;\\n     for (i = 0; i < n - 1; i++){\\n       t = a[i+1];\\n       j = i;\\n       while (t < a[j] && j >= 0){\\n         a[j+1] = a[j];\\n         j--;\\n       }\\n       a[j+1] = t;\\n     }\\n     ```\\n\\n## 2. 分治法\\n\\n1. 基本思想：\\n\\n   把一个复杂的问题分解成多个相同或相似的子问题，然后直接或间接地调用自己\\n\\n2. 递归实施步骤：\\n\\n   1. 根据实际构建递归关系（递归式）\\n   2. 确定递归边界（递归出口）\\n   3. 编写递归函数\\n   4. 设计主函数调用递归函数\\n\\n3. 汉诺塔的时间复杂度分析：\\n\\n   设盘子个数为 *n* 时，需要 *T(n)* 步，把 *A* 柱子 *n-1* 个盘子移到 *B* 柱子，需要 *T(n-1)* 步， *A* 柱子最后一个盘子移到 *C* 柱子一步，*B* 柱子上 *n-1* 个盘子移到 *C* 柱子上 *T(n-1)* 步。得递推公式 *T(n) = 2T(n-1) + 1*\\n   所以汉诺塔问题的时间复杂度为 *O(2<sup>n</sup>)*\\n\\n## 3. 贪心法\\n\\n1. 基本思想：\\n\\n   把复杂问题分解成若干个简单问题，每一步都做出在当前看最好的选择（局部最优）\\n\\n2. 算法应用：\\n\\n   哈夫曼树是带权路径最小的二叉树\\n\\n3. 最近顶点策略 Prim 算法：\\n\\n4. 最短边策略 Kruskal 算法：\\n\\n## 4. 动态规划算法\\n\\n1. 基本思想：\\n\\n   将待求解的问题按阶段分解成若干个子问题，其中各个子问题的解都是当前状态下所得的最优解（全局最优）\\n\\n2. 算法工具：\\n\\n   最优决策表：行代表问题的阶段，列代表问题的状态\\n\\n3. 最长公共子序列：\\n\\n   > 求序列 {34,52,18,6,76,322,145,57} 和 {2,18,54,6,78,145,57,9} 的最长公共子序列\\n   >\\n   > |      | 34   | 52   | 18                               | 6                                | 76   | 322  | 145                              | 57                               |\\n   > | :--- | :--- | ---- | -------------------------------- | -------------------------------- | ---- | ---- | -------------------------------- | -------------------------------- |\\n   > | 2    | 0    | 0    | 0                                | 0                                | 0    | 0    | 0                                | 0                                |\\n   > | 18   | 0    | 0    | == 1 == | 1                                | 1    | 1    | 1                                | 1                                |\\n   > | 54   | 0    | 0    | 1                                | 1                                | 1    | 1    | 1                                | 1                                |\\n   > | 6    | 0    | 0    | 1                                | ==<font color = \\\"red\\\">2</font>== | 2    | 2    | 2                                | 2                                |\\n   > | 78   | 0    | 0    | 1                                | 2                                | 2    | 2    | 2                                | 2                                |\\n   > | 145  | 0    | 0    | 1                                | 2                                | 2    | 2    | ==<font color = \\\"red\\\">3</font>== | 3                                |\\n   > | 57   | 0    | 0    | 1                                | 2                                | 2    | 2    | 3                                | ==<font color = \\\"red\\\">4</font>== |\\n   > | 9    | 0    | 0    | 1                                | 2                                | 2    | 2    | 3                                | 4                                |\\n   >\\n   > 最长公共子序列：{18，6，145，5}\\n\\n4. 排队购票：\\n\\n## 5. 回溯法\\n\\n\\n\\n## 6. 分支限界法\\n\\n1. 分支限界法和回溯法的区别：\\n\\n   回溯法一深度优先策略搜索解空间树，分支限界法则以广度优先策略搜索解空间树\\n\\n \",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg\",\"articleTitle\":\"算法设计基础\",\"categoryName\":\"学习和技术总结\",\"id\":63,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-23 23:55:51', NULL);
INSERT INTO `tb_operation_log` VALUES (1201, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n# 算法设计基础\\n\\n## 1. 算法的基本概念\\n\\n1. 算法的含义：\\n\\n   算法是为了解决某一问题而采用的方法与步骤\\n\\n2. 算法的5个特征：\\n\\n   确定性、可行性、有限性、输入性、输出型\\n\\n3. 算法的设计目标：\\n\\n   正确性、可使用性、可读性、健壮性、高效率与低存储量\\n   \\n4. 算法的分析：\\n\\n   * 时间复杂度：\\n\\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，n 表示问题的规模\\n\\n     1. *O(1)*：没有循环，每个语句只执行一遍\\n\\n     2. *O(n)*：一层循环，循环n次，循环里面的语句执行n次\\n\\n     3. *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\\n\\n     ```c++\\n     int i = 0;\\n     int sum = 0;\\n     while {\\n       sum = sum + i; /*执行log (2)n次*/\\n       i = i * 2;     /*执行log (2)n次*/\\n     }\\n     ```\\n\\n     4. *O(n<sup>2</sup>)*：双重循环，*n\\\\*n* 或者*n\\\\*m*\\n\\n     ```c++\\n     int sum = 0;\\n     for (int i = 0; i < n; i ++){\\n       for (int j = 0; j < m; i ++){\\n         sum = sum + i * j;      /*执行n*m次*/\\n       }\\n     }\\n     ```\\n\\n     5. *O(2<sup>n</sup>)*：斐波那契数列的递归算法\\n\\n     6. *O(n!)*：旅行商问题\\n\\n**上述算法中，*O(2<sup>n</sup>)* 和 *O(n!)* 是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法**\\n     \\n\\n## 2. 蛮力法\\n\\n1. 基本思想：\\n\\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\\n\\n2. 蛮力法的要点：\\n\\n   循环、选择\\n\\n3. 蛮力法的应用：\\n\\n   * 顺序查找(*O(n)*)：从 1 查到 n\\n\\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\\n\\n     ```c++\\n     for (int i = 0; i < n - 1; i ++){\\n       for (int j = 0; j = n - i - 1; j++){\\n         if (a[j] > a[j+1]){\\n           temp = a[j];\\n           a[j] = a[j+1];\\n           a[j+1] = a[j];\\n         }\\n       }\\n     }\\n     ```\\n\\n   * 直接选择排序*O(n<sup>2</sup>)*：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\\n\\n     ```c++\\n     int i,j,min;\\n     int temp;\\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\\n       min = i;   //用min记录无序区中最小元素的位置\\n       for(j = i + 1; j < n; j++){\\n         if (a[j] < a[min])\\n     \\t\\tmin=j;\\n       }\\n     \\tif (min! = i){ //若a[i]不是最小元素\\n     \\t \\ttemp=a[i];//将a[min]与a[i]交换\\n       \\ta[i]=a[min];\\n       \\ta[min]=temp;\\n     \\t}\\n     }\\n     ```\\n\\n   * 直接插入排序*O(n<sup>2</sup>)*：分为有序区和无序区，每一趟排序都将无序区中的第一个元素插入有序区中（插入过程蛮力法），让插入的元素和有序区的最后一个元素比较。\\n\\n     ```c++\\n     int i, j;\\n     int t;\\n     for (i = 0; i < n - 1; i++){\\n       t = a[i+1];\\n       j = i;\\n       while (t < a[j] && j >= 0){\\n         a[j+1] = a[j];\\n         j--;\\n       }\\n       a[j+1] = t;\\n     }\\n     ```\\n\\n## 2. 分治法\\n\\n1. 基本思想：\\n\\n   把一个复杂的问题分解成多个相同或相似的子问题，然后直接或间接地调用自己\\n\\n2. 递归实施步骤：\\n\\n   1. 根据实际构建递归关系（递归式）\\n   2. 确定递归边界（递归出口）\\n   3. 编写递归函数\\n   4. 设计主函数调用递归函数\\n\\n3. 汉诺塔的时间复杂度分析：\\n\\n   设盘子个数为 *n* 时，需要 *T(n)* 步，把 *A* 柱子 *n-1* 个盘子移到 *B* 柱子，需要 *T(n-1)* 步， *A* 柱子最后一个盘子移到 *C* 柱子一步，*B* 柱子上 *n-1* 个盘子移到 *C* 柱子上 *T(n-1)* 步。得递推公式 *T(n) = 2T(n-1) + 1*\\n   所以汉诺塔问题的时间复杂度为 *O(2<sup>n</sup>)*\\n\\n## 3. 贪心法\\n\\n1. 基本思想：\\n\\n   把复杂问题分解成若干个简单问题，每一步都做出在当前看最好的选择（局部最优）\\n\\n2. 算法应用：\\n\\n   哈夫曼树是带权路径最小的二叉树\\n\\n3. 最近顶点策略 Prim 算法：\\n\\n4. 最短边策略 Kruskal 算法：\\n\\n## 4. 动态规划算法\\n\\n1. 基本思想：\\n\\n   将待求解的问题按阶段分解成若干个子问题，其中各个子问题的解都是当前状态下所得的最优解（全局最优）\\n\\n2. 算法工具：\\n\\n   最优决策表：行代表问题的阶段，列代表问题的状态\\n\\n3. 最长公共子序列：\\n\\n   > 求序列 {34,52,18,6,76,322,145,57} 和 {2,18,54,6,78,145,57,9} 的最长公共子序列\\n   >\\n   > |      | 34   | 52   | 18                               | 6                                | 76   | 322  | 145                              | 57                               |\\n   > | :--- | :--- | ---- | -------------------------------- | -------------------------------- | ---- | ---- | -------------------------------- | -------------------------------- |\\n   > | 2    | 0    | 0    | 0                                | 0                                | 0    | 0    | 0                                | 0                                |\\n   > | 18   | 0    | 0    | ==<font color = \\\"red\\\">1</font>== | 1                                | 1    | 1    | 1                                | 1                                |\\n   > | 54   | 0    | 0    | 1                                | 1                                | 1    | 1    | 1                                | 1                                |\\n   > | 6    | 0    | 0    | 1                                | ==<font color = \\\"red\\\">2</font>== | 2    | 2    | 2                                | 2                                |\\n   > | 78   | 0    | 0    | 1                                | 2                                | 2    | 2    | 2                                | 2                                |\\n   > | 145  | 0    | 0    | 1                                | 2                                | 2    | 2    | ==<font color = \\\"red\\\">3</font>== | 3                                |\\n   > | 57   | 0    | 0    | 1                                | 2                                | 2    | 2    | 3                                | ==<font color = \\\"red\\\">4</font>== |\\n   > | 9    | 0    | 0    | 1                                | 2                                | 2    | 2    | 3                                | 4                                |\\n   >\\n   > 最长公共子序列：{18，6，145，5}\\n\\n4. 排队购票：\\n\\n## 5. 回溯法\\n\\n\\n\\n## 6. 分支限界法\\n\\n1. 分支限界法和回溯法的区别：\\n\\n   回溯法一深度优先策略搜索解空间树，分支限界法则以广度优先策略搜索解空间树\\n\\n \",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg\",\"articleTitle\":\"算法设计基础\",\"categoryName\":\"学习和技术总结\",\"id\":63,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.105', '山西省太原市 移动', '2022-06-23 23:58:18', NULL);
INSERT INTO `tb_operation_log` VALUES (1202, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的==开发周期==\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（-->）\\n\\n      关联关系（—）\\n\\n      聚合关系（—◇）\\n\\n      组合关系（—◆）\\n\\n      泛化关系（—▷）\\n\\n      实现关系（--▷）\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   3. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   2. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 应用场景：\\n\\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"设计模式\",\"课程\"],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.100', '山西省太原市 移动', '2022-06-24 01:54:45', NULL);
INSERT INTO `tb_operation_log` VALUES (1203, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的 ==开发周期== \\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（-->）\\n\\n      关联关系（—）\\n\\n      聚合关系（—◇）\\n\\n      组合关系（—◆）\\n\\n      泛化关系（—▷）\\n\\n      实现关系（--▷）\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   3. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   2. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 应用场景：\\n\\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.104', '山西省太原市 移动', '2022-06-24 01:55:12', NULL);
INSERT INTO `tb_operation_log` VALUES (1204, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（-->）\\n\\n      关联关系（—）\\n\\n      聚合关系（—◇）\\n\\n      组合关系（—◆）\\n\\n      泛化关系（—▷）\\n\\n      实现关系（--▷）\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   3. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   2. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 应用场景：\\n\\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.100', '山西省太原市 移动', '2022-06-24 01:55:38', NULL);
INSERT INTO `tb_operation_log` VALUES (1205, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（---->）\\n\\n      关联关系（——）\\n\\n      聚合关系（——◇）\\n\\n      组合关系（——◆）\\n\\n      泛化关系（——▷）\\n\\n      实现关系（----▷）\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   3. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   2. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 应用场景：\\n\\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-24 01:57:33', NULL);
INSERT INTO `tb_operation_log` VALUES (1206, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（-->）\\n\\n      关联关系（—）\\n\\n      聚合关系（—◇）\\n\\n      组合关系（—◆）\\n\\n      泛化关系（—▷）\\n\\n      实现关系（--▷）\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   3. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   2. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 应用场景：\\n\\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":66,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-24 01:58:03', NULL);
INSERT INTO `tb_operation_log` VALUES (1207, '文章模块', '修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[64],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-24 01:58:11', NULL);
INSERT INTO `tb_operation_log` VALUES (1208, '文章模块', '修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[65],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-24 01:58:13', NULL);
INSERT INTO `tb_operation_log` VALUES (1209, '文章模块', '修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[66],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-24 01:58:16', NULL);
INSERT INTO `tb_operation_log` VALUES (1210, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（---->）\\n\\n      关联关系（——）\\n\\n      聚合关系（——◇）\\n\\n      组合关系（——◆）\\n\\n      泛化关系（——▷）\\n\\n      实现关系（----▷）\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   3. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   2. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 应用场景：\\n\\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-24 02:03:46', NULL);
INSERT INTO `tb_operation_log` VALUES (1211, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n# 算法设计基础\\n\\n## 1. 算法的基本概念\\n\\n1. 算法的含义：\\n\\n   算法是为了解决某一问题而采用的方法与步骤\\n\\n2. 算法的5个特征：\\n\\n   确定性、可行性、有限性、输入性、输出型\\n\\n3. 算法的设计目标：\\n\\n   正确性、可使用性、可读性、健壮性、高效率与低存储量\\n   \\n4. 算法的分析：\\n\\n   * 时间复杂度：\\n\\n     符号通常用大 *O* 表示：*T(n)=O(f(n))*，n 表示问题的规模\\n\\n     1. *O(1)*：没有循环，每个语句只执行一遍\\n\\n     2. *O(n)*：一层循环，循环n次，循环里面的语句执行n次\\n\\n     3. *O(log<sub>2</sub>n)*：一层循环，循环语句中的语句执行log<sub>2</sub>n次。如：二分查找\\n\\n     ```c++\\n     int i = 0;\\n     int sum = 0;\\n     while {\\n       sum = sum + i; /*执行log (2)n次*/\\n       i = i * 2;     /*执行log (2)n次*/\\n     }\\n     ```\\n\\n     4. *O(n<sup>2</sup>)*：双重循环，*n\\\\*n* 或者*n\\\\*m*\\n\\n     ```c++\\n     int sum = 0;\\n     for (int i = 0; i < n; i ++){\\n       for (int j = 0; j < m; i ++){\\n         sum = sum + i * j;      /*执行n*m次*/\\n       }\\n     }\\n     ```\\n\\n     5. *O(2<sup>n</sup>)*：斐波那契数列的递归算法\\n\\n     6. *O(n!)*：旅行商问题\\n\\n**上述算法中，*O(2<sup>n</sup>)* 和 *O(n!)* 是不切实际的时间复杂度，理论上可行，但实际上不可行，在解决问题时应当尽量避免使用此类算法**\\n     \\n\\n## 2. 蛮力法\\n\\n1. 基本思想：\\n\\n   对问题所有可能的解或状态逐一进行测试，直至找到可行解，或者将所有可能的状态都测试完毕\\n\\n2. 蛮力法的要点：\\n\\n   循环、选择\\n\\n3. 蛮力法的应用：\\n\\n   * 顺序查找(*O(n)*)：从 1 查到 n\\n\\n   * 冒泡排序(*O(n<sup>2</sup>),O(1)*)：\\n\\n     ```c++\\n     for (int i = 0; i < n - 1; i ++){\\n       for (int j = 0; j = n - i - 1; j++){\\n         if (a[j] > a[j+1]){\\n           temp = a[j];\\n           a[j] = a[j+1];\\n           a[j+1] = a[j];\\n         }\\n       }\\n     }\\n     ```\\n\\n   * 直接选择排序*O(n<sup>2</sup>)*：分为有序区和无序区，每一趟排序从无序区查找最小的元素放入有序区的最后面（挑选过程使用蛮力法）。用 min 记录无序区中最小元素的下标，然后逐一和无序区比较，如果 min 改变了，就交换a[min]和a[i]。\\n\\n     ```c++\\n     int i,j,min;\\n     int temp;\\n     for (i = 0;i < n - 1;i++){ //进行n-1趟排序\\n       min = i;   //用min记录无序区中最小元素的位置\\n       for(j = i + 1; j < n; j++){\\n         if (a[j] < a[min])\\n     \\t\\tmin=j;\\n       }\\n     \\tif (min! = i){ //若a[i]不是最小元素\\n     \\t \\ttemp=a[i];//将a[min]与a[i]交换\\n       \\ta[i]=a[min];\\n       \\ta[min]=temp;\\n     \\t}\\n     }\\n     ```\\n\\n   * 直接插入排序*O(n<sup>2</sup>)*：分为有序区和无序区，每一趟排序都将无序区中的第一个元素插入有序区中（插入过程蛮力法），让插入的元素和有序区的最后一个元素比较。\\n\\n     ```c++\\n     int i, j;\\n     int t;\\n     for (i = 0; i < n - 1; i++){\\n       t = a[i+1];\\n       j = i;\\n       while (t < a[j] && j >= 0){\\n         a[j+1] = a[j];\\n         j--;\\n       }\\n       a[j+1] = t;\\n     }\\n     ```\\n\\n## 2. 分治法\\n\\n1. 基本思想：\\n\\n   把一个复杂的问题分解成多个相同或相似的子问题，然后直接或间接地调用自己\\n\\n2. 递归实施步骤：\\n\\n   1. 根据实际构建递归关系（递归式）\\n   2. 确定递归边界（递归出口）\\n   3. 编写递归函数\\n   4. 设计主函数调用递归函数\\n\\n3. 汉诺塔的时间复杂度分析：\\n\\n   设盘子个数为 *n* 时，需要 *T(n)* 步，把 *A* 柱子 *n-1* 个盘子移到 *B* 柱子，需要 *T(n-1)* 步， *A* 柱子最后一个盘子移到 *C* 柱子一步，*B* 柱子上 *n-1* 个盘子移到 *C* 柱子上 *T(n-1)* 步。得递推公式 *T(n) = 2T(n-1) + 1*\\n   所以汉诺塔问题的时间复杂度为 *O(2<sup>n</sup>)*\\n\\n## 3. 贪心法\\n\\n1. 基本思想：\\n\\n   把复杂问题分解成若干个简单问题，每一步都做出在当前看最好的选择（局部最优）\\n\\n2. 算法应用：\\n\\n   哈夫曼树是带权路径最小的二叉树\\n\\n3. 最近顶点策略 Prim 算法：\\n\\n4. 最短边策略 Kruskal 算法：\\n\\n## 4. 动态规划算法\\n\\n1. 基本思想：\\n\\n   将待求解的问题按阶段分解成若干个子问题，其中各个子问题的解都是当前状态下所得的最优解（全局最优）\\n\\n2. 算法工具：\\n\\n   最优决策表：行代表问题的阶段，列代表问题的状态\\n\\n3. 最长公共子序列：\\n\\n   > 求序列 {34,52,18,6,76,322,145,57} 和 {2,18,54,6,78,145,57,9} 的最长公共子序列\\n   >\\n   > |      | 34   | 52   | 18                               | 6                                | 76   | 322  | 145                              | 57                               |\\n   > | :--- | :--- | ---- | -------------------------------- | -------------------------------- | ---- | ---- | -------------------------------- | -------------------------------- |\\n   > | 2    | 0    | 0    | 0                                | 0                                | 0    | 0    | 0                                | 0                                |\\n   > | 18   | 0    | 0    | ==<font color = \\\"red\\\">1</font>== | 1                                | 1    | 1    | 1                                | 1                                |\\n   > | 54   | 0    | 0    | 1                                | 1                                | 1    | 1    | 1                                | 1                                |\\n   > | 6    | 0    | 0    | 1                                | ==<font color = \\\"red\\\">2</font>== | 2    | 2    | 2                                | 2                                |\\n   > | 78   | 0    | 0    | 1                                | 2                                | 2    | 2    | 2                                | 2                                |\\n   > | 145  | 0    | 0    | 1                                | 2                                | 2    | 2    | ==<font color = \\\"red\\\">3</font>== | 3                                |\\n   > | 57   | 0    | 0    | 1                                | 2                                | 2    | 2    | 3                                | ==<font color = \\\"red\\\">4</font>== |\\n   > | 9    | 0    | 0    | 1                                | 2                                | 2    | 2    | 3                                | 4                                |\\n   >\\n   > 最长公共子序列：{18，6，145，5}\\n\\n4. 排队购票：\\n\\n## 5. 回溯法\\n\\n\\n\\n## 6. 分支限界法\\n\\n1. 分支限界法和回溯法的区别：\\n\\n   回溯法一深度优先策略搜索解空间树，分支限界法则以广度优先策略搜索解空间树\\n\\n \",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/d45e353f7c72f4ee5ecf091aa81d5cb2.jpg\",\"articleTitle\":\"算法设计基础\",\"categoryName\":\"学习和技术总结\",\"id\":63,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-24 02:05:08', NULL);
INSERT INTO `tb_operation_log` VALUES (1212, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（---->）\\n\\n      关联关系（——）\\n\\n      聚合关系（——◇）\\n\\n      组合关系（——◆）\\n\\n      泛化关系（——▷）\\n\\n      实现关系（----▷）\\n\\n4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n   2. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n      - [x] 意图\\n      - [x] 解决方案\\n      - [x] 参与者和协作者\\n\\n   3. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n      - [x] 对象组合\\n      - [ ] 使用抽象类\\n      - [ ] 使用实现类\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   3. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   2. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n      - [x] 创建型模式关注的是对象的创建\\n      - [ ] 创建型模式关注的是功能的实现\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n      - [ ] 创建型模式关注的是对象间的协作\\n   2. 在（）适合使用单例模式\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      - [ ] 根据需要创建开销很大的对象\\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 应用场景：\\n\\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n   3. 单选题：\\n   \\n      1. 以下意图（）可用来描述策略\\n         - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n         - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n         - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n         - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      2. 以下（）不适合使用策略模式\\n         - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这\\n           些对象是紧密耦合的\\n         - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个\\n           类的方法\\n         - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的\\n           算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n         - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.104', '山西省太原市 移动', '2022-06-24 16:33:51', NULL);
INSERT INTO `tb_operation_log` VALUES (1213, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n      * 123\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（---->）\\n\\n      关联关系（——）\\n\\n      聚合关系（——◇）\\n\\n      组合关系（——◆）\\n\\n      泛化关系（——▷）\\n\\n      实现关系（----▷）\\n\\n4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n   2. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n      - [x] 意图\\n      - [x] 解决方案\\n      - [x] 参与者和协作者\\n\\n   3. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n      - [x] 对象组合\\n      - [ ] 使用抽象类\\n      - [ ] 使用实现类\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   3. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   2. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n      - [x] 创建型模式关注的是对象的创建\\n      - [ ] 创建型模式关注的是功能的实现\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n      - [ ] 创建型模式关注的是对象间的协作\\n   2. 在（）适合使用单例模式\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      - [ ] 根据需要创建开销很大的对象\\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 应用场景：\\n\\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n   3. 单选题：\\n   \\n      1. 以下意图（）可用来描述策略\\n         - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n         - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n         - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n         - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      2. 以下（）不适合使用策略模式\\n         - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这\\n           些对象是紧密耦合的\\n         - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个\\n           类的方法\\n         - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的\\n           算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n         - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.104', '山西省太原市 移动', '2022-06-24 16:34:40', NULL);
INSERT INTO `tb_operation_log` VALUES (1214, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   - 123\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（---->）\\n\\n      关联关系（——）\\n\\n      聚合关系（——◇）\\n\\n      组合关系（——◆）\\n\\n      泛化关系（——▷）\\n\\n      实现关系（----▷）\\n\\n4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n   2. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n      - [x] 意图\\n      - [x] 解决方案\\n      - [x] 参与者和协作者\\n\\n   3. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n      - [x] 对象组合\\n      - [ ] 使用抽象类\\n      - [ ] 使用实现类\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   3. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   2. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n      - [x] 创建型模式关注的是对象的创建\\n      - [ ] 创建型模式关注的是功能的实现\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n      - [ ] 创建型模式关注的是对象间的协作\\n   2. 在（）适合使用单例模式\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      - [ ] 根据需要创建开销很大的对象\\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 应用场景：\\n\\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n   3. 单选题：\\n   \\n      1. 以下意图（）可用来描述策略\\n         - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n         - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n         - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n         - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      2. 以下（）不适合使用策略模式\\n         - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这\\n           些对象是紧密耦合的\\n         - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个\\n           类的方法\\n         - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的\\n           算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n         - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.104', '山西省太原市 移动', '2022-06-24 16:35:44', NULL);
INSERT INTO `tb_operation_log` VALUES (1215, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   ==标记==- 123\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（---->）\\n\\n      关联关系（——）\\n\\n      聚合关系（——◇）\\n\\n      组合关系（——◆）\\n\\n      泛化关系（——▷）\\n\\n      实现关系（----▷）\\n\\n4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n   2. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n      - [x] 意图\\n      - [x] 解决方案\\n      - [x] 参与者和协作者\\n\\n   3. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n      - [x] 对象组合\\n      - [ ] 使用抽象类\\n      - [ ] 使用实现类\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   3. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   2. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n      - [x] 创建型模式关注的是对象的创建\\n      - [ ] 创建型模式关注的是功能的实现\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n      - [ ] 创建型模式关注的是对象间的协作\\n   2. 在（）适合使用单例模式\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      - [ ] 根据需要创建开销很大的对象\\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 应用场景：\\n\\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n   3. 单选题：\\n   \\n      1. 以下意图（）可用来描述策略\\n         - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n         - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n         - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n         - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      2. 以下（）不适合使用策略模式\\n         - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这\\n           些对象是紧密耦合的\\n         - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个\\n           类的方法\\n         - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的\\n           算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n         - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.104', '山西省太原市 移动', '2022-06-24 16:36:25', NULL);
INSERT INTO `tb_operation_log` VALUES (1216, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n      - 123\\n        - 123 \\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（---->）\\n\\n      关联关系（——）\\n\\n      聚合关系（——◇）\\n\\n      组合关系（——◆）\\n\\n      泛化关系（——▷）\\n\\n      实现关系（----▷）\\n\\n4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n   2. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n      - [x] 意图\\n      - [x] 解决方案\\n      - [x] 参与者和协作者\\n\\n   3. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n      - [x] 对象组合\\n      - [ ] 使用抽象类\\n      - [ ] 使用实现类\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   3. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   2. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n      - [x] 创建型模式关注的是对象的创建\\n      - [ ] 创建型模式关注的是功能的实现\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n      - [ ] 创建型模式关注的是对象间的协作\\n   2. 在（）适合使用单例模式\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      - [ ] 根据需要创建开销很大的对象\\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 应用场景：\\n\\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n   3. 单选题：\\n   \\n      1. 以下意图（）可用来描述策略\\n         - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n         - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n         - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n         - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      2. 以下（）不适合使用策略模式\\n         - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这\\n           些对象是紧密耦合的\\n         - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个\\n           类的方法\\n         - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的\\n           算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n         - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.101', '山西省太原市 移动', '2022-06-24 16:38:16', NULL);
INSERT INTO `tb_operation_log` VALUES (1217, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n      - 123\\n            - 123 \\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（---->）\\n\\n      关联关系（——）\\n\\n      聚合关系（——◇）\\n\\n      组合关系（——◆）\\n\\n      泛化关系（——▷）\\n\\n      实现关系（----▷）\\n\\n4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n   2. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n      - [x] 意图\\n      - [x] 解决方案\\n      - [x] 参与者和协作者\\n\\n   3. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n      - [x] 对象组合\\n      - [ ] 使用抽象类\\n      - [ ] 使用实现类\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   3. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   2. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n      - [x] 创建型模式关注的是对象的创建\\n      - [ ] 创建型模式关注的是功能的实现\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n      - [ ] 创建型模式关注的是对象间的协作\\n   2. 在（）适合使用单例模式\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      - [ ] 根据需要创建开销很大的对象\\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 应用场景：\\n\\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n   3. 单选题：\\n   \\n      1. 以下意图（）可用来描述策略\\n         - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n         - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n         - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n         - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      2. 以下（）不适合使用策略模式\\n         - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这\\n           些对象是紧密耦合的\\n         - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个\\n           类的方法\\n         - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的\\n           算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n         - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.101', '山西省太原市 移动', '2022-06-24 16:38:29', NULL);
INSERT INTO `tb_operation_log` VALUES (1218, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n      - 123\\n      \\t- 123 \\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（---->）\\n\\n      关联关系（——）\\n\\n      聚合关系（——◇）\\n\\n      组合关系（——◆）\\n\\n      泛化关系（——▷）\\n\\n      实现关系（----▷）\\n\\n4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n   2. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n      - [x] 意图\\n      - [x] 解决方案\\n      - [x] 参与者和协作者\\n\\n   3. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n      - [x] 对象组合\\n      - [ ] 使用抽象类\\n      - [ ] 使用实现类\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   3. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   2. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n      - [x] 创建型模式关注的是对象的创建\\n      - [ ] 创建型模式关注的是功能的实现\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n      - [ ] 创建型模式关注的是对象间的协作\\n   2. 在（）适合使用单例模式\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      - [ ] 根据需要创建开销很大的对象\\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 应用场景：\\n\\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n   3. 单选题：\\n   \\n      1. 以下意图（）可用来描述策略\\n         - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n         - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n         - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n         - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      2. 以下（）不适合使用策略模式\\n         - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这\\n           些对象是紧密耦合的\\n         - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个\\n           类的方法\\n         - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的\\n           算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n         - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.101', '山西省太原市 移动', '2022-06-24 16:38:51', NULL);
INSERT INTO `tb_operation_log` VALUES (1219, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（---->）\\n\\n      关联关系（——）\\n\\n      聚合关系（——◇）\\n\\n      组合关系（——◆）\\n\\n      泛化关系（——▷）\\n\\n      实现关系（----▷）\\n\\n4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n   2. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n      - [x] 意图\\n      - [x] 解决方案\\n      - [x] 参与者和协作者\\n\\n   3. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n      - [x] 对象组合\\n      - [ ] 使用抽象类\\n      - [ ] 使用实现类\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   3. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   2. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n      - [x] 创建型模式关注的是对象的创建\\n      - [ ] 创建型模式关注的是功能的实现\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n      - [ ] 创建型模式关注的是对象间的协作\\n   2. 在（）适合使用单例模式\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      - [ ] 根据需要创建开销很大的对象\\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 应用场景：\\n\\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n   3. 单选题：\\n   \\n      1. 以下意图（）可用来描述策略\\n         - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n         - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n         - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n         - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      2. 以下（）不适合使用策略模式\\n         - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这\\n           些对象是紧密耦合的\\n         - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个\\n           类的方法\\n         - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的\\n           算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n         - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.101', '山西省太原市 移动', '2022-06-24 16:39:03', NULL);
INSERT INTO `tb_operation_log` VALUES (1220, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（---->）\\n\\n      关联关系（——）\\n\\n      聚合关系（——◇）\\n\\n      组合关系（——◆）\\n\\n      泛化关系（——▷）\\n\\n      实现关系（----▷）\\n\\n4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n5. 多选题\\n\\n   1. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n   2. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n7. 开闭原则\\n\\n   1. 定义：\\n\\n      软件实体应当对扩展开放，对修改关闭\\n\\n   2. 作用：\\n\\n      对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n   2. 在（）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（）\\n      - [x] 运行时刻增加和删除产品\\n      - [x] 改变值以指定新对象\\n      - [x] 减少子类的构造\\n      - [x] 用类动态配置应用\\n   2. 以下属于单例模式的优点是（）\\n      - [x] 对唯一实例的受控访问\\n      - [x] 允许对操作和表示的精化\\n      - [x] 允许可变数目的实例\\n      - [x] 比类操作更灵活\\n   3. 当应用工厂方法模式时需要考虑（）\\n      - [x] 主要有两种不同的情况\\n      - [x] 参数化工厂方法\\n      - [x] 特定语言的变化和问题\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n      \\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n      \\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      - [ ] 根据需要创建开销很大的对象\\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n      3. \\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n   \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n   \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n   \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n   \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n3. 单选题：\\n   \\n   1. 以下意图（）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n     \\n   2. 以下（）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-24 23:33:46', NULL);
INSERT INTO `tb_operation_log` VALUES (1221, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（---->）\\n\\n      关联关系（——）\\n\\n      聚合关系（——◇）\\n\\n      组合关系（——◆）\\n\\n      泛化关系（——▷）\\n\\n      实现关系（----▷）\\n\\n4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n5. 多选题\\n\\n   1. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n        \\n\\n   2. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n7. 开闭原则\\n\\n   1. 定义：\\n\\n      软件实体应当对扩展开放，对修改关闭\\n\\n   2. 作用：\\n\\n      对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n        \\n\\n   2. 在（）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（）\\n      - [x] 运行时刻增加和删除产品\\n      \\n      - [x] 改变值以指定新对象\\n      \\n      - [x] 减少子类的构造\\n      \\n      - [x] 用类动态配置应用\\n      \\n        \\n      \\n   2. 以下属于单例模式的优点是（）\\n      - [x] 对唯一实例的受控访问\\n      \\n      - [x] 允许对操作和表示的精化\\n      \\n      - [x] 允许可变数目的实例\\n      \\n      - [x] 比类操作更灵活\\n      \\n        \\n      \\n   3. 当应用工厂方法模式时需要考虑（）\\n      - [x] 主要有两种不同的情况\\n      - [x] 参数化工厂方法\\n      - [x] 特定语言的变化和问题\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n      \\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n      \\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      \\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      \\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n        \\n      \\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      \\n      - [ ] 根据需要创建开销很大的对象\\n      \\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      \\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n      \\n        \\n      \\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n      3. \\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n   \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n   \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n   \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n   \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n3. 单选题：\\n   \\n   1. 以下意图（）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n     - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n     \\n     - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n     \\n       \\n     \\n   2. 以下（）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.104', '山西省太原市 移动', '2022-06-24 23:37:48', NULL);
INSERT INTO `tb_operation_log` VALUES (1222, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（---->）\\n\\n      关联关系（——）\\n\\n      聚合关系（——◇）\\n\\n      组合关系（——◆）\\n\\n      泛化关系（——▷）\\n\\n      实现关系（----▷）\\n\\n4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n5. 多选题\\n\\n   1. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n        \\n\\n   2. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n7. 开闭原则\\n\\n   1. 定义：\\n\\n      软件实体应当对扩展开放，对修改关闭\\n\\n   2. 作用：\\n\\n      对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n        \\n\\n   2. 在（）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（）\\n      - [x] 运行时刻增加和删除产品\\n      \\n      - [x] 改变值以指定新对象\\n      \\n      - [x] 减少子类的构造\\n      \\n      - [x] 用类动态配置应用\\n      \\n        \\n      \\n   2. 以下属于单例模式的优点是（）\\n      - [x] 对唯一实例的受控访问\\n      \\n      - [x] 允许对操作和表示的精化\\n      \\n      - [x] 允许可变数目的实例\\n      \\n      - [x] 比类操作更灵活\\n      \\n        \\n      \\n   3. 当应用工厂方法模式时需要考虑（）\\n      - [x] 主要有两种不同的情况\\n      \\n      - [x] 参数化工厂方法\\n\\n      - [x] 特定语言的变化和问题\\n\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n      \\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n      \\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      \\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      \\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n        \\n      \\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      \\n      - [ ] 根据需要创建开销很大的对象\\n      \\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      \\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n      \\n        \\n      \\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      \\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      \\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      \\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n   \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n   \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n   \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n   \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n3. 单选题：\\n   \\n   1. 以下意图（）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n     \\n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n     \\n       \\n     \\n   2. 以下（）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      \\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      \\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      \\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.105', '山西省太原市 移动', '2022-06-24 23:40:40', NULL);
INSERT INTO `tb_operation_log` VALUES (1223, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（-->）\\n\\n      关联关系（—）\\n\\n      聚合关系（—◇）\\n\\n      组合关系（—◆）\\n\\n      泛化关系（—▷）\\n\\n      实现关系（--▷）\\n\\n4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n5. 多选题\\n\\n   1. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n        \\n\\n   2. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n7. 开闭原则\\n\\n   1. 定义：\\n\\n      软件实体应当对扩展开放，对修改关闭\\n\\n   2. 作用：\\n\\n      对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n        \\n\\n   2. 在（）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（）\\n      - [x] 运行时刻增加和删除产品\\n      \\n      - [x] 改变值以指定新对象\\n      \\n      - [x] 减少子类的构造\\n      \\n      - [x] 用类动态配置应用\\n      \\n        \\n      \\n   2. 以下属于单例模式的优点是（）\\n      - [x] 对唯一实例的受控访问\\n      \\n      - [x] 允许对操作和表示的精化\\n      \\n      - [x] 允许可变数目的实例\\n      \\n      - [x] 比类操作更灵活\\n      \\n        \\n      \\n   3. 当应用工厂方法模式时需要考虑（）\\n      - [x] 主要有两种不同的情况\\n      \\n      - [x] 参数化工厂方法\\n\\n      - [x] 特定语言的变化和问题\\n\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n      \\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n      \\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      \\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      \\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n        \\n      \\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      \\n      - [ ] 根据需要创建开销很大的对象\\n      \\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      \\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n      \\n        \\n      \\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      \\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      \\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      \\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n   \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n   \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n   \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n   \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n3. 单选题：\\n   \\n   1. 以下意图（）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n       \\n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n       \\n      \\n   2. 以下（）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      \\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      \\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      \\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.104', '山西省太原市 移动', '2022-06-24 23:54:27', NULL);
INSERT INTO `tb_operation_log` VALUES (1224, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、~~建造者~~\\n\\n      结构型模式：代理、外观、~~适配器、桥接、装饰、享元、组合~~\\n\\n      行为型模式：模板方法、策略、~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、~~适配器、解释器~~\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（- - - >）\\n\\n      关联关系（—）\\n\\n      聚合关系（—◇）\\n\\n      组合关系（—◆）\\n\\n      泛化关系（—▷）\\n\\n      实现关系（- - - ▷）\\n\\n4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n5. 多选题\\n\\n   1. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n        \\n\\n   2. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n7. 开闭原则\\n\\n   1. 定义：\\n\\n      软件实体应当对扩展开放，对修改关闭\\n\\n   2. 作用：\\n\\n      对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n        \\n\\n   2. 在（）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（）\\n      - [x] 运行时刻增加和删除产品\\n      \\n      - [x] 改变值以指定新对象\\n      \\n      - [x] 减少子类的构造\\n      \\n      - [x] 用类动态配置应用\\n      \\n        \\n      \\n   2. 以下属于单例模式的优点是（）\\n      - [x] 对唯一实例的受控访问\\n      \\n      - [x] 允许对操作和表示的精化\\n      \\n      - [x] 允许可变数目的实例\\n      \\n      - [x] 比类操作更灵活\\n      \\n        \\n      \\n   3. 当应用工厂方法模式时需要考虑（）\\n      - [x] 主要有两种不同的情况\\n      \\n      - [x] 参数化工厂方法\\n\\n      - [x] 特定语言的变化和问题\\n\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n      \\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n      \\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      \\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      \\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n        \\n      \\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      \\n      - [ ] 根据需要创建开销很大的对象\\n      \\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      \\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n      \\n        \\n      \\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      \\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      \\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      \\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n   \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n   \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n   \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n   \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n3. 单选题：\\n   \\n   1. 以下意图（）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n       \\n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n       \\n      \\n   2. 以下（）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      \\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      \\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      \\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.104', '山西省太原市 移动', '2022-06-24 23:55:18', NULL);
INSERT INTO `tb_operation_log` VALUES (1225, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、<font color=\\\"#e1e9ee\\\">~~建造者~~</font>\\n\\n      结构型模式：代理、外观、<font color=\\\"#e1e9ee\\\">~~适配器、桥接、装饰、享元、组合~~</font>\\n\\n      行为型模式：模板方法、策略、<font color=\\\"#e1e9ee\\\">~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、</font>\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、<font color=\\\"#e1e9ee\\\">~~适配器、解释器~~</font>\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（- - - >）\\n\\n      关联关系（—）\\n\\n      聚合关系（—◇）\\n\\n      组合关系（—◆）\\n\\n      泛化关系（—▷）\\n\\n      实现关系（- - - ▷）\\n\\n4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n5. 多选题\\n\\n   1. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n        \\n\\n   2. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n7. 开闭原则\\n\\n   1. 定义：\\n\\n      软件实体应当对扩展开放，对修改关闭\\n\\n   2. 作用：\\n\\n      对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性<font color=\\\"#e1e9ee\\\">123</font>\\n\\n## 2 创建型模式\\n\\n1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n        \\n\\n   2. 在（）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（）\\n      - [x] 运行时刻增加和删除产品\\n      \\n      - [x] 改变值以指定新对象\\n      \\n      - [x] 减少子类的构造\\n      \\n      - [x] 用类动态配置应用\\n      \\n        \\n      \\n   2. 以下属于单例模式的优点是（）\\n      - [x] 对唯一实例的受控访问\\n      \\n      - [x] 允许对操作和表示的精化\\n      \\n      - [x] 允许可变数目的实例\\n      \\n      - [x] 比类操作更灵活\\n      \\n        \\n      \\n   3. 当应用工厂方法模式时需要考虑（）\\n      - [x] 主要有两种不同的情况\\n      \\n      - [x] 参数化工厂方法\\n\\n      - [x] 特定语言的变化和问题\\n\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n      \\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n      \\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      \\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      \\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n        \\n      \\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      \\n      - [ ] 根据需要创建开销很大的对象\\n      \\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      \\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n      \\n        \\n      \\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      \\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      \\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      \\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。<font color=\\\"#e1e9ee\\\">~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~</font>（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n   \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n   \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n   \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n   \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n3. 单选题：\\n   \\n   1. 以下意图（）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n      \\n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      \\n   2. 以下（）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      \\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      \\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      \\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.105', '山西省太原市 移动', '2022-06-25 00:03:02', NULL);
INSERT INTO `tb_operation_log` VALUES (1226, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 设计模式\\n\\n## 1 设计模式基础\\n\\n1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、<font color=\\\"#e1e9ee\\\">~~建造者~~</font>\\n\\n      结构型模式：代理、外观、<font color=\\\"#e1e9ee\\\">~~适配器、桥接、装饰、享元、组合~~</font>\\n\\n      行为型模式：模板方法、策略、<font color=\\\"#e1e9ee\\\">~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、</font>\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、<font color=\\\"#e1e9ee\\\">~~适配器、解释器~~</font>\\n\\n      对象模式：（除了以上四种都是）\\n\\n3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（- - - >）\\n\\n      关联关系（—）\\n\\n      聚合关系（—◇）\\n\\n      组合关系（—◆）\\n\\n      泛化关系（—▷）\\n\\n      实现关系（- - - ▷）\\n\\n4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n5. 多选题\\n\\n   1. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n        \\n\\n   2. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n7. 开闭原则\\n\\n   1. 定义：\\n\\n      软件实体应当对扩展开放，对修改关闭\\n\\n   2. 作用：\\n\\n      对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性<font color=\\\"#e1e9ee\\\">123</font>\\n\\n## 2 创建型模式\\n\\n### 1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n        \\n\\n   2. 在（）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（）\\n      - [x] 运行时刻增加和删除产品\\n      \\n      - [x] 改变值以指定新对象\\n      \\n      - [x] 减少子类的构造\\n      \\n      - [x] 用类动态配置应用\\n      \\n        \\n      \\n   2. 以下属于单例模式的优点是（）\\n      - [x] 对唯一实例的受控访问\\n      \\n      - [x] 允许对操作和表示的精化\\n      \\n      - [x] 允许可变数目的实例\\n      \\n      - [x] 比类操作更灵活\\n      \\n        \\n      \\n   3. 当应用工厂方法模式时需要考虑（）\\n      - [x] 主要有两种不同的情况\\n      \\n      - [x] 参数化工厂方法\\n\\n      - [x] 特定语言的变化和问题\\n\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n      \\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n      \\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      \\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      \\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n        \\n      \\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      \\n      - [ ] 根据需要创建开销很大的对象\\n      \\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      \\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n      \\n        \\n      \\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      \\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      \\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      \\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。<font color=\\\"#e1e9ee\\\">~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~</font>（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n   \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n   \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n   \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n   \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n3. 单选题：\\n   \\n   1. 以下意图（）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n      \\n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      \\n   2. 以下（）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      \\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      \\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      \\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.105', '山西省太原市 移动', '2022-06-25 00:18:59', NULL);
INSERT INTO `tb_operation_log` VALUES (1227, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"[TOC]\\n\\n# 设计模式\\n\\n## 1 设计模式基础\\n\\n### 1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n### 2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、<font color=\\\"#e1e9ee\\\">~~建造者~~</font>\\n\\n      结构型模式：代理、外观、<font color=\\\"#e1e9ee\\\">~~适配器、桥接、装饰、享元、组合~~</font>\\n\\n      行为型模式：模板方法、策略、<font color=\\\"#e1e9ee\\\">~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、</font>\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、<font color=\\\"#e1e9ee\\\">~~适配器、解释器~~</font>\\n\\n      对象模式：（除了以上四种都是）\\n\\n### 3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（- - - >）\\n\\n      关联关系（—）\\n\\n      聚合关系（—◇）\\n\\n      组合关系（—◆）\\n\\n      泛化关系（—▷）\\n\\n      实现关系（- - - ▷）\\n\\n### 4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n### 5. 多选题\\n\\n   1. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n        \\n\\n   2. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n### 6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n### 7. 开闭原则\\n\\n   1. 定义：\\n\\n      软件实体应当对扩展开放，对修改关闭\\n\\n   2. 作用：\\n\\n      对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性<font color=\\\"#e1e9ee\\\">123</font>\\n\\n## 2 创建型模式\\n\\n### 1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n### 2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n### 3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n### 4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n        \\n\\n   2. 在（）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n### 5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（）\\n      - [x] 运行时刻增加和删除产品\\n      \\n      - [x] 改变值以指定新对象\\n      \\n      - [x] 减少子类的构造\\n      \\n      - [x] 用类动态配置应用\\n      \\n        \\n      \\n   2. 以下属于单例模式的优点是（）\\n      - [x] 对唯一实例的受控访问\\n      \\n      - [x] 允许对操作和表示的精化\\n      \\n      - [x] 允许可变数目的实例\\n      \\n      - [x] 比类操作更灵活\\n      \\n        \\n      \\n   3. 当应用工厂方法模式时需要考虑（）\\n      - [x] 主要有两种不同的情况\\n      \\n      - [x] 参数化工厂方法\\n\\n      - [x] 特定语言的变化和问题\\n\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n### 1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n      \\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n### 2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n      \\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n### 3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      \\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      \\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n        \\n      \\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      \\n      - [ ] 根据需要创建开销很大的对象\\n      \\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      \\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n      \\n        \\n      \\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      \\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      \\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      \\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n### 1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n### 2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。<font color=\\\"#e1e9ee\\\">~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~</font>（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n   \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n   \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n   \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n   \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n### 3. 单选题：\\n   \\n   1. 以下意图（）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n      \\n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      \\n   2. 以下（）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      \\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      \\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      \\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.104', '山西省太原市 移动', '2022-06-25 00:22:20', NULL);
INSERT INTO `tb_operation_log` VALUES (1228, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n## 1 设计模式基础\\n\\n### 1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n### 2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、<font color=\\\"#e1e9ee\\\">~~建造者~~</font>\\n\\n      结构型模式：代理、外观、<font color=\\\"#e1e9ee\\\">~~适配器、桥接、装饰、享元、组合~~</font>\\n\\n      行为型模式：模板方法、策略、<font color=\\\"#e1e9ee\\\">~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、</font>\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、<font color=\\\"#e1e9ee\\\">~~适配器、解释器~~</font>\\n\\n      对象模式：（除了以上四种都是）\\n\\n### 3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（- - - >）\\n\\n      关联关系（—）\\n\\n      聚合关系（—◇）\\n\\n      组合关系（—◆）\\n\\n      泛化关系（—▷）\\n\\n      实现关系（- - - ▷）\\n\\n### 4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n### 5. 多选题\\n\\n   1. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n        \\n\\n   2. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n### 6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n### 7. 开闭原则\\n\\n   1. 定义：\\n\\n      软件实体应当对扩展开放，对修改关闭\\n\\n   2. 作用：\\n\\n      对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性<font color=\\\"#e1e9ee\\\">123</font>\\n\\n## 2 创建型模式\\n\\n### 1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n### 2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n### 3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n### 4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n        \\n\\n   2. 在（）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n### 5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（）\\n      - [x] 运行时刻增加和删除产品\\n      \\n      - [x] 改变值以指定新对象\\n      \\n      - [x] 减少子类的构造\\n      \\n      - [x] 用类动态配置应用\\n      \\n        \\n      \\n   2. 以下属于单例模式的优点是（）\\n      - [x] 对唯一实例的受控访问\\n      \\n      - [x] 允许对操作和表示的精化\\n      \\n      - [x] 允许可变数目的实例\\n      \\n      - [x] 比类操作更灵活\\n      \\n        \\n      \\n   3. 当应用工厂方法模式时需要考虑（）\\n      - [x] 主要有两种不同的情况\\n      \\n      - [x] 参数化工厂方法\\n\\n      - [x] 特定语言的变化和问题\\n\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n### 1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n      \\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n### 2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n      \\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n### 3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      \\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      \\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n        \\n      \\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      \\n      - [ ] 根据需要创建开销很大的对象\\n      \\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      \\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n      \\n        \\n      \\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      \\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      \\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      \\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n### 1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n### 2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。<font color=\\\"#e1e9ee\\\">~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~</font>（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n   \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n   \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n   \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n   \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n### 3. 单选题：\\n   \\n   1. 以下意图（）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n      \\n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      \\n   2. 以下（）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      \\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      \\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      \\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.100', '山西省太原市 移动', '2022-06-25 00:24:13', NULL);
INSERT INTO `tb_operation_log` VALUES (1229, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"::: hljs-center\\n\\n# 设计模式\\n\\n:::\\n\\n\\n## 1 设计模式基础\\n\\n### 1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n### 2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、<font color=\\\"#e1e9ee\\\">~~建造者~~</font>\\n\\n      结构型模式：代理、外观、<font color=\\\"#e1e9ee\\\">~~适配器、桥接、装饰、享元、组合~~</font>\\n\\n      行为型模式：模板方法、策略、<font color=\\\"#e1e9ee\\\">~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、</font>\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、<font color=\\\"#e1e9ee\\\">~~适配器、解释器~~</font>\\n\\n      对象模式：（除了以上四种都是）\\n\\n### 3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（- - - >）\\n\\n      关联关系（—）\\n\\n      聚合关系（—◇）\\n\\n      组合关系（—◆）\\n\\n      泛化关系（—▷）\\n\\n      实现关系（- - - ▷）\\n\\n### 4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n### 5. 多选题\\n\\n   1. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n        \\n\\n   2. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n### 6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n### 7. 开闭原则\\n\\n   1. 定义：\\n\\n      软件实体应当对扩展开放，对修改关闭\\n\\n   2. 作用：\\n\\n      对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性<font color=\\\"#e1e9ee\\\">123</font>\\n\\n## 2 创建型模式\\n\\n### 1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n### 2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n### 3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n### 4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n        \\n\\n   2. 在（）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n### 5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（）\\n      - [x] 运行时刻增加和删除产品\\n      \\n      - [x] 改变值以指定新对象\\n      \\n      - [x] 减少子类的构造\\n      \\n      - [x] 用类动态配置应用\\n      \\n        \\n      \\n   2. 以下属于单例模式的优点是（）\\n      - [x] 对唯一实例的受控访问\\n      \\n      - [x] 允许对操作和表示的精化\\n      \\n      - [x] 允许可变数目的实例\\n      \\n      - [x] 比类操作更灵活\\n      \\n        \\n      \\n   3. 当应用工厂方法模式时需要考虑（）\\n      - [x] 主要有两种不同的情况\\n      \\n      - [x] 参数化工厂方法\\n\\n      - [x] 特定语言的变化和问题\\n\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n### 1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n      \\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n### 2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n      \\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n### 3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      \\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      \\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n        \\n      \\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      \\n      - [ ] 根据需要创建开销很大的对象\\n      \\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      \\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n      \\n        \\n      \\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      \\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      \\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      \\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n### 1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n### 2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。<font color=\\\"#e1e9ee\\\">~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~</font>（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n   \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n   \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n   \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n   \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n### 3. 单选题：\\n   \\n   1. 以下意图（）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n      \\n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      \\n   2. 以下（）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      \\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      \\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      \\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.101', '山西省太原市 移动', '2022-06-25 00:25:09', NULL);
INSERT INTO `tb_operation_log` VALUES (1230, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# <center>设计模式</center>\\n\\n## 1 设计模式基础\\n\\n### 1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n### 2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、<font color=\\\"#e1e9ee\\\">~~建造者~~</font>\\n\\n      结构型模式：代理、外观、<font color=\\\"#e1e9ee\\\">~~适配器、桥接、装饰、享元、组合~~</font>\\n\\n      行为型模式：模板方法、策略、<font color=\\\"#e1e9ee\\\">~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、</font>\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、<font color=\\\"#e1e9ee\\\">~~适配器、解释器~~</font>\\n\\n      对象模式：（除了以上四种都是）\\n\\n### 3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（- - - >）\\n\\n      关联关系（—）\\n\\n      聚合关系（—◇）\\n\\n      组合关系（—◆）\\n\\n      泛化关系（—▷）\\n\\n      实现关系（- - - ▷）\\n\\n### 4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n### 5. 多选题\\n\\n   1. 以下是模式的基本要素（）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n        \\n\\n   2. 面向对象系统中功能复用的最常用技术（）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n### 6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n### 7. 开闭原则\\n\\n   1. 定义：\\n\\n      软件实体应当对扩展开放，对修改关闭\\n\\n   2. 作用：\\n\\n      对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性<font color=\\\"#e1e9ee\\\">123</font>\\n\\n## 2 创建型模式\\n\\n### 1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n### 2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n### 3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n### 4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n        \\n\\n   2. 在（）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n### 5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（）\\n      - [x] 运行时刻增加和删除产品\\n      \\n      - [x] 改变值以指定新对象\\n      \\n      - [x] 减少子类的构造\\n      \\n      - [x] 用类动态配置应用\\n      \\n        \\n      \\n   2. 以下属于单例模式的优点是（）\\n      - [x] 对唯一实例的受控访问\\n      \\n      - [x] 允许对操作和表示的精化\\n      \\n      - [x] 允许可变数目的实例\\n      \\n      - [x] 比类操作更灵活\\n      \\n        \\n      \\n   3. 当应用工厂方法模式时需要考虑（）\\n      - [x] 主要有两种不同的情况\\n      \\n      - [x] 参数化工厂方法\\n\\n      - [x] 特定语言的变化和问题\\n\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n### 1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n      \\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n### 2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n      \\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n### 3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      \\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      \\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n        \\n      \\n   2. 以下情况不适合使用代理模式的是（）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      \\n      - [ ] 根据需要创建开销很大的对象\\n      \\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      \\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n      \\n        \\n      \\n   3. 以下意图可以用来描述外观（）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      \\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      \\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      \\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n### 1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n### 2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。<font color=\\\"#e1e9ee\\\">~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~</font>（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n   \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n   \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n   \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n   \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n   \\n### 3. 单选题：\\n   \\n   1. 以下意图（）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n      \\n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      \\n   2. 以下（）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      \\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      \\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      \\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.104', '山西省太原市 移动', '2022-06-25 00:26:53', NULL);
INSERT INTO `tb_operation_log` VALUES (1231, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# <center>设计模式</center>\\n\\n## 1 设计模式基础\\n\\n### 1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n### 2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、<font color=\\\"#e1e9ee\\\">~~建造者~~</font>\\n\\n      结构型模式：代理、外观、<font color=\\\"#e1e9ee\\\">~~适配器、桥接、装饰、享元、组合~~</font>\\n\\n      行为型模式：模板方法、策略、<font color=\\\"#e1e9ee\\\">~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、</font>\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、<font color=\\\"#e1e9ee\\\">~~适配器、解释器~~</font>\\n\\n      对象模式：（除了以上四种都是）\\n\\n### 3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（- - - >）\\n\\n      关联关系（—）\\n\\n      聚合关系（—◇）\\n\\n      组合关系（—◆）\\n\\n      泛化关系（—▷）\\n\\n      实现关系（- - - ▷）\\n\\n### 4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（A）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n### 5. 多选题\\n\\n   1. 以下是模式的基本要素（ABCD）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n        \\n\\n   2. 面向对象系统中功能复用的最常用技术（AB）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n### 6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n### 7. 开闭原则\\n\\n   1. 定义：\\n\\n      软件实体应当对扩展开放，对修改关闭\\n\\n   2. 作用：\\n\\n      对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性<font color=\\\"#e1e9ee\\\">123</font>\\n\\n## 2 创建型模式\\n\\n### 1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n### 2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n### 3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n### 4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（A）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n        \\n\\n   2. 在（C）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n### 5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（ABCD）\\n      - [x] 运行时刻增加和删除产品\\n      \\n      - [x] 改变值以指定新对象\\n      \\n      - [x] 减少子类的构造\\n      \\n      - [x] 用类动态配置应用\\n      \\n        \\n      \\n   2. 以下属于单例模式的优点是（ABCD）\\n      - [x] 对唯一实例的受控访问\\n      \\n      - [x] 允许对操作和表示的精化\\n      \\n      - [x] 允许可变数目的实例\\n      \\n      - [x] 比类操作更灵活\\n      \\n        \\n      \\n   3. 当应用工厂方法模式时需要考虑（ABCD）\\n      - [x] 主要有两种不同的情况\\n      \\n      - [x] 参数化工厂方法\\n\\n      - [x] 特定语言的变化和问题\\n\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n### 1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n      \\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n### 2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n      \\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n### 3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（C）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      \\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      \\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n        \\n      \\n   2. 以下情况不适合使用代理模式的是（A）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      \\n      - [ ] 根据需要创建开销很大的对象\\n      \\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      \\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n      \\n        \\n      \\n   3. 以下意图可以用来描述外观（A）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      \\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      \\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      \\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n### 1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n### 2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。<font color=\\\"#e1e9ee\\\">~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~</font>（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n\\n### 3. 单选题：\\n\\n   1. 以下意图（D）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n      \\n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      \\n   2. 以下（A）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      \\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      \\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      \\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.101', '山西省太原市 移动', '2022-06-27 15:00:45', NULL);
INSERT INTO `tb_operation_log` VALUES (1232, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# <center>设计模式</center>\\n\\n## 1 设计模式基础\\n\\n### 1. 设计模式的优点\\n\\n   1. 可以调程序员的思维的能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n### 2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、<font color=\\\"#e1e9ee\\\">~~建造者~~</font>\\n\\n      结构型模式：代理、外观、<font color=\\\"#e1e9ee\\\">~~适配器、桥接、装饰、享元、组合~~</font>\\n\\n      行为型模式：模板方法、策略、<font color=\\\"#e1e9ee\\\">~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、</font>\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、<font color=\\\"#e1e9ee\\\">~~适配器、解释器~~</font>\\n\\n      对象模式：（除了以上四种都是）\\n\\n### 3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（- - - >）\\n\\n      关联关系（—）\\n\\n      聚合关系（—◇）\\n\\n      组合关系（—◆）\\n\\n      泛化关系（—▷）\\n\\n      实现关系（- - - ▷）\\n\\n### 4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（A）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n### 5. 多选题\\n\\n   1. 以下是模式的基本要素（ABCD）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n        \\n\\n   2. 面向对象系统中功能复用的最常用技术（AB）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n### 6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n### 7. 开闭原则\\n\\n   1. 定义：\\n\\n      软件实体应当对扩展开放，对修改关闭\\n\\n   2. 作用：\\n\\n      对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性<font color=\\\"#e1e9ee\\\">123</font>\\n\\n## 2 创建型模式\\n\\n### 1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 只生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n### 2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n### 3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体共厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n### 4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（A）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n        \\n\\n   2. 在（C）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n### 5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（ABCD）\\n      - [x] 运行时刻增加和删除产品\\n      \\n      - [x] 改变值以指定新对象\\n      \\n      - [x] 减少子类的构造\\n      \\n      - [x] 用类动态配置应用\\n      \\n        \\n      \\n   2. 以下属于单例模式的优点是（ABCD）\\n      - [x] 对唯一实例的受控访问\\n      \\n      - [x] 允许对操作和表示的精化\\n      \\n      - [x] 允许可变数目的实例\\n      \\n      - [x] 比类操作更灵活\\n      \\n        \\n      \\n   3. 当应用工厂方法模式时需要考虑（ABCD）\\n      - [x] 主要有两种不同的情况\\n      \\n      - [x] 参数化工厂方法\\n\\n      - [x] 特定语言的变化和问题\\n\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n### 1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n      \\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n### 2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n      \\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n### 3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（C）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      \\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      \\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n        \\n      \\n   2. 以下情况不适合使用代理模式的是（A）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      \\n      - [ ] 根据需要创建开销很大的对象\\n      \\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      \\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n      \\n        \\n      \\n   3. 以下意图可以用来描述外观（A）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      \\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      \\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      \\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n### 1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n### 2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。<font color=\\\"#e1e9ee\\\">~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~</font>（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n\\n### 3. 单选题：\\n\\n   1. 以下意图（D）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n      \\n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      \\n   2. 以下（A）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      \\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      \\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      \\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"Java\"],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.101', '山西省太原市 移动', '2022-06-27 15:01:02', NULL);
INSERT INTO `tb_operation_log` VALUES (1233, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# <center>设计模式</center>\\n\\n## 1 设计模式基础\\n\\n### 1. 设计模式的优点\\n\\n   1. 可以提高程序员的思维能力、编程能力和设计能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n### 2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、<font color=\\\"#e1e9ee\\\">~~建造者~~</font>\\n\\n      结构型模式：代理、外观、<font color=\\\"#e1e9ee\\\">~~适配器、桥接、装饰、享元、组合~~</font>\\n\\n      行为型模式：模板方法、策略、<font color=\\\"#e1e9ee\\\">~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、</font>\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、<font color=\\\"#e1e9ee\\\">~~适配器、解释器~~</font>\\n\\n      对象模式：（除了以上四种都是）\\n\\n### 3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（- - - >）\\n\\n      关联关系（—）\\n\\n      聚合关系（—◇）\\n\\n      组合关系（—◆）\\n\\n      泛化关系（—▷）\\n\\n      实现关系（- - - ▷）\\n\\n### 4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（A）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n### 5. 多选题\\n\\n   1. 以下是模式的基本要素（ABCD）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n        \\n\\n   2. 面向对象系统中功能复用的最常用技术（AB）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n### 6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n### 7. 开闭原则\\n\\n   1. 定义：\\n\\n      软件实体应当对扩展开放，对修改关闭\\n\\n   2. 作用：\\n\\n      对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性<font color=\\\"#e1e9ee\\\">123</font>\\n\\n## 2 创建型模式\\n\\n### 1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 某类只要求生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合，由于单例模式只允许创建一个对象，共享该对象可以节省资源\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n### 2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n### 3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体工厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n### 4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（A）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n        \\n\\n   2. 在（C）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n### 5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（ABCD）\\n      - [x] 运行时刻增加和删除产品\\n      \\n      - [x] 改变值以指定新对象\\n      \\n      - [x] 减少子类的构造\\n      \\n      - [x] 用类动态配置应用\\n      \\n        \\n      \\n   2. 以下属于单例模式的优点是（ABCD）\\n      - [x] 对唯一实例的受控访问\\n      \\n      - [x] 允许对操作和表示的精化\\n      \\n      - [x] 允许可变数目的实例\\n      \\n      - [x] 比类操作更灵活\\n      \\n        \\n      \\n   3. 当应用工厂方法模式时需要考虑（ABCD）\\n      - [x] 主要有两种不同的情况\\n      \\n      - [x] 参数化工厂方法\\n\\n      - [x] 特定语言的变化和问题\\n\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n### 1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n   1. （明星）例子：\\n\\n      结构图：\\n\\n      ![明星代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/笔记/设计模式/图片1-f10.png)\\n\\n      代码：\\n\\n      ```java\\n      package porxy;\\n      \\n      public interface Star {\\n        void confer();                 //面谈\\n        void signContrack();           //签合同\\n        void bookTicket();             //订票\\n        void sing();                  //唱歌\\n        void collectmoney();            //收钱\\n      }\\n      \\n      public class RealStar implements Star{\\n      \\t public void confer(){               //面谈\\n      \\t    System.out.println(\\\"RealStar.confer()\\\");\\n      \\t }\\n      \\t  public void signContrack(){           //签合同\\n      \\t\\t  System.out.println(\\\"RealStar.signContrack()\\\");  \\n      \\t  }\\n      \\t  public void bookTicket(){           //订票\\n      \\t\\t  System.out.println(\\\"RealStar.bookTicket()\\\");  \\n      \\t  }\\n      \\t  public void sing(){                  //唱歌\\n      \\t\\t  System.out.println(\\\"RealStar(周杰伦本人).sing()\\\");  \\n      \\t  }\\n      \\t  public void collectmoney(){            //收钱\\n      \\t\\t  System.out.println(\\\"RealStar.collectmoney()\\\");  \\n      \\t  }\\n      }\\n      \\n      public class porxyStar implements Star {\\n         private Star star;\\n         public porxyStar(Star star){\\n      \\t   super();\\n      \\t   this.star = star;\\n           }\\n         public void confer() {\\n      \\t  System.out.println(\\\"porxyStar.confer()\\\");\\t\\t\\n      \\t}\\n         public void signContrack() {\\n      \\t\\t System.out.println(\\\"porxyStar.signContrack()\\\");\\t\\n      \\t}\\n      \\tpublic void bookTicket() {\\n      \\t\\tSystem.out.println(\\\"porxyStar.bookTicket()\\\");\\n      \\t}\\n      \\tpublic void sing() {\\n      \\t\\t star.sing();\\n      \\t}\\n      \\tpublic void collectmoney() {\\n      \\t\\t System.out.println(\\\"porxyStar.collectmoney()\\\");\\n      \\t}\\n      }\\n      \\n      public class client {\\n      \\tpublic static void main(String[] args) {\\t\\n      \\tStar real = new RealStar();\\n      \\tStar porxy = new porxyStar(real);\\t\\n              porxy.confer();\\n              porxy.signContrack();\\n              porxy.bookTicket();\\n              porxy.sing();\\n              porxy.collectmoney();\\n      \\t}\\n      }\\n      ```\\n\\n      \\n\\n### 2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n   1. （注册公司）例子：\\n\\n      结构图：\\n\\n      ![注册公司外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/笔记/设计模式/外观模式2-015.png)\\n\\n      代码：\\n\\n      ```java\\n      package chapter05.facade;         //外观角色\\n      \\n      public class  Client{\\n      \\tpublic static void main(String[] args) {\\n      \\n      \\tnew RegisterFacade().register();\\n      \\n      \\t}\\n      }\\n      \\n      public class RegisterFacade  {\\n          public void register(){\\n            工商总局 a = new 工商局();\\n            a.checkName();\\n      \\t    税务总局 b = new 税务局();\\n            b.texCertificate();\\n            质监总局 c = new 质监局();\\n            c.orgCodeCertificate();\\n            银行 d = new 工商银行()\\n            d.openAccount();\\n         }\\t\\t\\t\\n      }\\n      \\n      public interface 工商总局{\\n         void checkName();\\n      }\\n      class 工商局 implements 工商总局  {\\n      \\tSystem.out.println(“检查名字是否冲突！”);\\t\\t\\n      }\\n      public interface 税务总局{\\n         void texCertificate();   //办理税务登记证\\n      }\\n      class 税务局 implements 税务总局  {\\n      \\tSystem.out.println(“在税务局办理税务登记证！”);\\t\\t\\n      }\\n      public interface 银行{\\n         void openAccount();   //开户\\n      }\\n      \\n      class 工商银行 implements 银行  {\\n      \\tSystem.out.println(“在中国工商银行开户！”);\\t\\t\\t\\n      }\\n      public interface 质监总局{\\n         void orgCodeCertificate();   //办理组织结构代码证\\n      }\\n      class 质监局 implements 质监总局  {\\n      \\tSystem.out.println(“在质监总局办理组织结构代码证！”);\\t\\t\\n      \\t\\n      }\\n      \\n      \\n      ```\\n\\n      \\n\\n### 3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（C）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      \\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      \\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n        \\n      \\n   2. 以下情况不适合使用代理模式的是（A）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      \\n      - [ ] 根据需要创建开销很大的对象\\n      \\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      \\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n      \\n        \\n      \\n   3. 以下意图可以用来描述外观（A）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      \\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      \\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      \\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n### 1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n### 2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。<font color=\\\"#e1e9ee\\\">~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~</font>（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n\\n### 3. 单选题：\\n\\n   1. 以下意图（D）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n      \\n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      \\n   2. 以下（A）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      \\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      \\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      \\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.100', '山西省太原市 移动', '2022-06-27 22:59:24', NULL);
INSERT INTO `tb_operation_log` VALUES (1234, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# <center>设计模式</center>\\n\\n## 1 设计模式基础\\n\\n### 1. 设计模式的优点\\n\\n   1. 可以提高程序员的思维能力、编程能力和设计能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n### 2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、<font color=\\\"#e1e9ee\\\">~~建造者~~</font>\\n\\n      结构型模式：代理、外观、<font color=\\\"#e1e9ee\\\">~~适配器、桥接、装饰、享元、组合~~</font>\\n\\n      行为型模式：模板方法、策略、<font color=\\\"#e1e9ee\\\">~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、</font>\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、<font color=\\\"#e1e9ee\\\">~~适配器、解释器~~</font>\\n\\n      对象模式：（除了以上四种都是）\\n\\n### 3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（- - - >）\\n\\n      关联关系（—）\\n\\n      聚合关系（—◇）\\n\\n      组合关系（—◆）\\n\\n      泛化关系（—▷）\\n\\n      实现关系（- - - ▷）\\n\\n### 4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（A）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n### 5. 多选题\\n\\n   1. 以下是模式的基本要素（ABCD）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n        \\n\\n   2. 面向对象系统中功能复用的最常用技术（AB）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n### 6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n### 7. 开闭原则\\n\\n   1. 定义：\\n\\n      软件实体应当对扩展开放，对修改关闭\\n\\n   2. 作用：\\n\\n      对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性<font color=\\\"#e1e9ee\\\">123</font>\\n\\n## 2 创建型模式\\n\\n### 1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 某类只要求生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合，由于单例模式只允许创建一个对象，共享该对象可以节省资源\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n### 2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n### 3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体工厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一个等级的的一组产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n### 4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（A）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n        \\n\\n   2. 在（C）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n### 5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（ABCD）\\n      - [x] 运行时刻增加和删除产品\\n      \\n      - [x] 改变值以指定新对象\\n      \\n      - [x] 减少子类的构造\\n      \\n      - [x] 用类动态配置应用\\n      \\n        \\n      \\n   2. 以下属于单例模式的优点是（ABCD）\\n      - [x] 对唯一实例的受控访问\\n      \\n      - [x] 允许对操作和表示的精化\\n      \\n      - [x] 允许可变数目的实例\\n      \\n      - [x] 比类操作更灵活\\n      \\n        \\n      \\n   3. 当应用工厂方法模式时需要考虑（ABCD）\\n      - [x] 主要有两种不同的情况\\n      \\n      - [x] 参数化工厂方法\\n\\n      - [x] 特定语言的变化和问题\\n\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n### 1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n   1. （明星）例子：\\n\\n      结构图：\\n\\n      ![明星代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/笔记/设计模式/图片1-f10.png)\\n\\n      代码：\\n\\n      ```java\\n      package porxy;\\n      \\n      public interface Star {\\n        void confer();                 //面谈\\n        void signContrack();           //签合同\\n        void bookTicket();             //订票\\n        void sing();                  //唱歌\\n        void collectmoney();            //收钱\\n      }\\n      \\n      public class RealStar implements Star{\\n      \\t public void confer(){               //面谈\\n      \\t    System.out.println(\\\"RealStar.confer()\\\");\\n      \\t }\\n      \\t  public void signContrack(){           //签合同\\n      \\t\\t  System.out.println(\\\"RealStar.signContrack()\\\");  \\n      \\t  }\\n      \\t  public void bookTicket(){           //订票\\n      \\t\\t  System.out.println(\\\"RealStar.bookTicket()\\\");  \\n      \\t  }\\n      \\t  public void sing(){                  //唱歌\\n      \\t\\t  System.out.println(\\\"RealStar(周杰伦本人).sing()\\\");  \\n      \\t  }\\n      \\t  public void collectmoney(){            //收钱\\n      \\t\\t  System.out.println(\\\"RealStar.collectmoney()\\\");  \\n      \\t  }\\n      }\\n      \\n      public class porxyStar implements Star {\\n         private Star star;\\n         public porxyStar(Star star){\\n      \\t   super();\\n      \\t   this.star = star;\\n           }\\n         public void confer() {\\n      \\t  System.out.println(\\\"porxyStar.confer()\\\");\\t\\t\\n      \\t}\\n         public void signContrack() {\\n      \\t\\t System.out.println(\\\"porxyStar.signContrack()\\\");\\t\\n      \\t}\\n      \\tpublic void bookTicket() {\\n      \\t\\tSystem.out.println(\\\"porxyStar.bookTicket()\\\");\\n      \\t}\\n      \\tpublic void sing() {\\n      \\t\\t star.sing();\\n      \\t}\\n      \\tpublic void collectmoney() {\\n      \\t\\t System.out.println(\\\"porxyStar.collectmoney()\\\");\\n      \\t}\\n      }\\n      \\n      public class client {\\n      \\tpublic static void main(String[] args) {\\t\\n      \\tStar real = new RealStar();\\n      \\tStar porxy = new porxyStar(real);\\t\\n              porxy.confer();\\n              porxy.signContrack();\\n              porxy.bookTicket();\\n              porxy.sing();\\n              porxy.collectmoney();\\n      \\t}\\n      }\\n      ```\\n\\n      \\n\\n### 2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n   1. （注册公司）例子：\\n\\n      结构图：\\n\\n      ![注册公司外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/笔记/设计模式/外观模式2-015.png)\\n\\n      代码：\\n\\n      ```java\\n      package chapter05.facade;         //外观角色\\n      \\n      public class  Client{\\n      \\tpublic static void main(String[] args) {\\n      \\n      \\tnew RegisterFacade().register();\\n      \\n      \\t}\\n      }\\n      \\n      public class RegisterFacade  {\\n          public void register(){\\n            工商总局 a = new 工商局();\\n            a.checkName();\\n      \\t    税务总局 b = new 税务局();\\n            b.texCertificate();\\n            质监总局 c = new 质监局();\\n            c.orgCodeCertificate();\\n            银行 d = new 工商银行()\\n            d.openAccount();\\n         }\\t\\t\\t\\n      }\\n      \\n      public interface 工商总局{\\n         void checkName();\\n      }\\n      class 工商局 implements 工商总局  {\\n      \\tSystem.out.println(“检查名字是否冲突！”);\\t\\t\\n      }\\n      public interface 税务总局{\\n         void texCertificate();   //办理税务登记证\\n      }\\n      class 税务局 implements 税务总局  {\\n      \\tSystem.out.println(“在税务局办理税务登记证！”);\\t\\t\\n      }\\n      public interface 银行{\\n         void openAccount();   //开户\\n      }\\n      class 工商银行 implements 银行  {\\n      \\tSystem.out.println(“在中国工商银行开户！”);\\t\\t\\t\\n      }\\n      public interface 质监总局{\\n         void orgCodeCertificate();   //办理组织结构代码证\\n      }\\n      class 质监局 implements 质监总局  {\\n      \\tSystem.out.println(“在质监总局办理组织结构代码证！”);\\t\\t\\n      }\\n      ```\\n\\n      \\n\\n### 3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（C）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      \\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      \\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n        \\n      \\n   2. 以下情况不适合使用代理模式的是（A）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      \\n      - [ ] 根据需要创建开销很大的对象\\n      \\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      \\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n      \\n        \\n      \\n   3. 以下意图可以用来描述外观（A）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      \\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      \\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      \\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n### 1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n### 2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。<font color=\\\"#e1e9ee\\\">~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~</font>（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n\\n### 3. 单选题：\\n\\n   1. 以下意图（D）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n      \\n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      \\n   2. 以下（A）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      \\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      \\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      \\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.100', '山西省太原市 移动', '2022-06-27 23:04:19', NULL);
INSERT INTO `tb_operation_log` VALUES (1235, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# <center>设计模式</center>\\n\\n## 1 设计模式基础\\n\\n### 1. 设计模式的优点\\n\\n   1. 可以提高程序员的思维能力、编程能力和设计能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n### 2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、<font color=\\\"#e1e9ee\\\">~~建造者~~</font>\\n\\n      结构型模式：代理、外观、<font color=\\\"#e1e9ee\\\">~~适配器、桥接、装饰、享元、组合~~</font>\\n\\n      行为型模式：模板方法、策略、<font color=\\\"#e1e9ee\\\">~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、</font>\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、<font color=\\\"#e1e9ee\\\">~~适配器、解释器~~</font>\\n\\n      对象模式：（除了以上四种都是）\\n\\n### 3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（- - - >）\\n\\n      关联关系（—）\\n\\n      聚合关系（—◇）\\n\\n      组合关系（—◆）\\n\\n      泛化关系（—▷）\\n\\n      实现关系（- - - ▷）\\n\\n### 4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（A）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n### 5. 多选题\\n\\n   1. 以下是模式的基本要素（ABCD）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n        \\n\\n   2. 面向对象系统中功能复用的最常用技术（AB）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n### 6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n### 7. 开闭原则\\n\\n   1. 定义：\\n\\n      软件实体应当对扩展开放，对修改关闭\\n\\n   2. 作用：\\n\\n      对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性<font color=\\\"#e1e9ee\\\">123</font>\\n\\n## 2 创建型模式\\n\\n### 1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 某类只要求生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合，由于单例模式只允许创建一个对象，共享该对象可以节省资源\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n### 2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n### 3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体工厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一种产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式是用来创建不同类的各个产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n### 4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（A）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n        \\n\\n   2. 在（C）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n### 5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（ABCD）\\n      - [x] 运行时刻增加和删除产品\\n      \\n      - [x] 改变值以指定新对象\\n      \\n      - [x] 减少子类的构造\\n      \\n      - [x] 用类动态配置应用\\n      \\n        \\n      \\n   2. 以下属于单例模式的优点是（ABCD）\\n      - [x] 对唯一实例的受控访问\\n      \\n      - [x] 允许对操作和表示的精化\\n      \\n      - [x] 允许可变数目的实例\\n      \\n      - [x] 比类操作更灵活\\n      \\n        \\n      \\n   3. 当应用工厂方法模式时需要考虑（ABCD）\\n      - [x] 主要有两种不同的情况\\n      \\n      - [x] 参数化工厂方法\\n\\n      - [x] 特定语言的变化和问题\\n\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n### 1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n   1. （明星）例子：\\n\\n      结构图：\\n\\n      ![明星代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/笔记/设计模式/图片1-f10.png)\\n\\n      代码：\\n\\n      ```java\\n      package porxy;\\n      \\n      public interface Star {\\n        void confer();                 //面谈\\n        void signContrack();           //签合同\\n        void bookTicket();             //订票\\n        void sing();                  //唱歌\\n        void collectmoney();            //收钱\\n      }\\n      \\n      public class RealStar implements Star{\\n      \\t public void confer(){               //面谈\\n      \\t    System.out.println(\\\"RealStar.confer()\\\");\\n      \\t }\\n      \\t  public void signContrack(){           //签合同\\n      \\t\\t  System.out.println(\\\"RealStar.signContrack()\\\");  \\n      \\t  }\\n      \\t  public void bookTicket(){           //订票\\n      \\t\\t  System.out.println(\\\"RealStar.bookTicket()\\\");  \\n      \\t  }\\n      \\t  public void sing(){                  //唱歌\\n      \\t\\t  System.out.println(\\\"RealStar(周杰伦本人).sing()\\\");  \\n      \\t  }\\n      \\t  public void collectmoney(){            //收钱\\n      \\t\\t  System.out.println(\\\"RealStar.collectmoney()\\\");  \\n      \\t  }\\n      }\\n      \\n      public class porxyStar implements Star {\\n         private Star star;\\n         public porxyStar(Star star){\\n      \\t   super();\\n      \\t   this.star = star;\\n           }\\n         public void confer() {\\n      \\t  System.out.println(\\\"porxyStar.confer()\\\");\\t\\t\\n      \\t}\\n         public void signContrack() {\\n      \\t\\t System.out.println(\\\"porxyStar.signContrack()\\\");\\t\\n      \\t}\\n      \\tpublic void bookTicket() {\\n      \\t\\tSystem.out.println(\\\"porxyStar.bookTicket()\\\");\\n      \\t}\\n      \\tpublic void sing() {\\n      \\t\\t star.sing();\\n      \\t}\\n      \\tpublic void collectmoney() {\\n      \\t\\t System.out.println(\\\"porxyStar.collectmoney()\\\");\\n      \\t}\\n      }\\n      \\n      public class client {\\n      \\tpublic static void main(String[] args) {\\t\\n      \\tStar real = new RealStar();\\n      \\tStar porxy = new porxyStar(real);\\t\\n              porxy.confer();\\n              porxy.signContrack();\\n              porxy.bookTicket();\\n              porxy.sing();\\n              porxy.collectmoney();\\n      \\t}\\n      }\\n      ```\\n\\n      \\n\\n### 2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n   1. （注册公司）例子：\\n\\n      结构图：\\n\\n      ![注册公司外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/笔记/设计模式/外观模式2-015.png)\\n\\n      代码：\\n\\n      ```java\\n      package chapter05.facade;         //外观角色\\n      \\n      public class  Client{\\n      \\tpublic static void main(String[] args) {\\n      \\n      \\tnew RegisterFacade().register();\\n      \\n      \\t}\\n      }\\n      \\n      public class RegisterFacade  {\\n          public void register(){\\n            工商总局 a = new 工商局();\\n            a.checkName();\\n      \\t    税务总局 b = new 税务局();\\n            b.texCertificate();\\n            质监总局 c = new 质监局();\\n            c.orgCodeCertificate();\\n            银行 d = new 工商银行()\\n            d.openAccount();\\n         }\\t\\t\\t\\n      }\\n      \\n      public interface 工商总局{\\n         void checkName();\\n      }\\n      class 工商局 implements 工商总局  {\\n      \\tSystem.out.println(“检查名字是否冲突！”);\\t\\t\\n      }\\n      public interface 税务总局{\\n         void texCertificate();   //办理税务登记证\\n      }\\n      class 税务局 implements 税务总局  {\\n      \\tSystem.out.println(“在税务局办理税务登记证！”);\\t\\t\\n      }\\n      public interface 银行{\\n         void openAccount();   //开户\\n      }\\n      class 工商银行 implements 银行  {\\n      \\tSystem.out.println(“在中国工商银行开户！”);\\t\\t\\t\\n      }\\n      public interface 质监总局{\\n         void orgCodeCertificate();   //办理组织结构代码证\\n      }\\n      class 质监局 implements 质监总局  {\\n      \\tSystem.out.println(“在质监总局办理组织结构代码证！”);\\t\\t\\n      }\\n      ```\\n\\n      \\n\\n### 3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（C）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      \\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      \\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n        \\n      \\n   2. 以下情况不适合使用代理模式的是（A）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      \\n      - [ ] 根据需要创建开销很大的对象\\n      \\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      \\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n      \\n        \\n      \\n   3. 以下意图可以用来描述外观（A）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      \\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      \\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      \\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n### 1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n### 2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。<font color=\\\"#e1e9ee\\\">~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~</font>（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n\\n### 3. 单选题：\\n\\n   1. 以下意图（D）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n      \\n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      \\n   2. 以下（A）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      \\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      \\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      \\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.105', '山西省太原市 移动', '2022-06-29 16:31:33', NULL);
INSERT INTO `tb_operation_log` VALUES (1236, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# <center>设计模式</center>\\n\\n## 1 设计模式基础\\n\\n### 1. 设计模式的优点\\n\\n   1. 可以提高程序员的思维能力、编程能力和设计能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n### 2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：单例、原型、工厂方法、抽象工程、<font color=\\\"#e1e9ee\\\">~~建造者~~</font>\\n\\n      结构型模式：代理、外观、<font color=\\\"#e1e9ee\\\">~~适配器、桥接、装饰、享元、组合~~</font>\\n\\n      行为型模式：模板方法、策略、<font color=\\\"#e1e9ee\\\">~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、</font>\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、<font color=\\\"#e1e9ee\\\">~~适配器、解释器~~</font>\\n\\n      对象模式：（除了以上四种都是）\\n\\n### 3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（- - - >）\\n\\n      关联关系（—）\\n\\n      聚合关系（—◇）\\n\\n      组合关系（—◆）\\n\\n      泛化关系（—▷）\\n\\n      实现关系（- - - ▷）\\n\\n### 4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（A）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n### 5. 多选题\\n\\n   1. 以下是模式的基本要素（ABCD）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n        \\n\\n   2. 面向对象系统中功能复用的最常用技术（AB）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n### 6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n### 7. 开闭原则\\n\\n   1. 定义：\\n\\n      软件实体应当对扩展开放，对修改关闭\\n\\n   2. 作用：\\n\\n      对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性<font color=\\\"#e1e9ee\\\">123</font>\\n\\n## 2 创建型模式\\n\\n### 1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 某类只要求生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合，由于单例模式只允许创建一个对象，共享该对象可以节省资源\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n### 2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n### 3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体工厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：将不同工厂生产的同一种产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式可以用来创建不同类的各个产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n### 4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（A）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n        \\n\\n   2. 在（C）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩转的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n### 5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（ABCD）\\n      - [x] 运行时刻增加和删除产品\\n      \\n      - [x] 改变值以指定新对象\\n      \\n      - [x] 减少子类的构造\\n      \\n      - [x] 用类动态配置应用\\n      \\n        \\n      \\n   2. 以下属于单例模式的优点是（ABCD）\\n      - [x] 对唯一实例的受控访问\\n      \\n      - [x] 允许对操作和表示的精化\\n      \\n      - [x] 允许可变数目的实例\\n      \\n      - [x] 比类操作更灵活\\n      \\n        \\n      \\n   3. 当应用工厂方法模式时需要考虑（ABCD）\\n      - [x] 主要有两种不同的情况\\n      \\n      - [x] 参数化工厂方法\\n\\n      - [x] 特定语言的变化和问题\\n\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n### 1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n   1. （明星）例子：\\n\\n      结构图：\\n\\n      ![明星代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/笔记/设计模式/图片1-f10.png)\\n\\n      代码：\\n\\n      ```java\\n      package porxy;\\n      \\n      public interface Star {\\n        void confer();                 //面谈\\n        void signContrack();           //签合同\\n        void bookTicket();             //订票\\n        void sing();                  //唱歌\\n        void collectmoney();            //收钱\\n      }\\n      \\n      public class RealStar implements Star{\\n      \\t public void confer(){               //面谈\\n      \\t    System.out.println(\\\"RealStar.confer()\\\");\\n      \\t }\\n      \\t  public void signContrack(){           //签合同\\n      \\t\\t  System.out.println(\\\"RealStar.signContrack()\\\");  \\n      \\t  }\\n      \\t  public void bookTicket(){           //订票\\n      \\t\\t  System.out.println(\\\"RealStar.bookTicket()\\\");  \\n      \\t  }\\n      \\t  public void sing(){                  //唱歌\\n      \\t\\t  System.out.println(\\\"RealStar(周杰伦本人).sing()\\\");  \\n      \\t  }\\n      \\t  public void collectmoney(){            //收钱\\n      \\t\\t  System.out.println(\\\"RealStar.collectmoney()\\\");  \\n      \\t  }\\n      }\\n      \\n      public class porxyStar implements Star {\\n         private Star star;\\n         public porxyStar(Star star){\\n      \\t   super();\\n      \\t   this.star = star;\\n           }\\n         public void confer() {\\n      \\t  System.out.println(\\\"porxyStar.confer()\\\");\\t\\t\\n      \\t}\\n         public void signContrack() {\\n      \\t\\t System.out.println(\\\"porxyStar.signContrack()\\\");\\t\\n      \\t}\\n      \\tpublic void bookTicket() {\\n      \\t\\tSystem.out.println(\\\"porxyStar.bookTicket()\\\");\\n      \\t}\\n      \\tpublic void sing() {\\n      \\t\\t star.sing();\\n      \\t}\\n      \\tpublic void collectmoney() {\\n      \\t\\t System.out.println(\\\"porxyStar.collectmoney()\\\");\\n      \\t}\\n      }\\n      \\n      public class client {\\n      \\tpublic static void main(String[] args) {\\t\\n      \\tStar real = new RealStar();\\n      \\tStar porxy = new porxyStar(real);\\t\\n              porxy.confer();\\n              porxy.signContrack();\\n              porxy.bookTicket();\\n              porxy.sing();\\n              porxy.collectmoney();\\n      \\t}\\n      }\\n      ```\\n\\n      \\n\\n### 2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n   1. （注册公司）例子：\\n\\n      结构图：\\n\\n      ![注册公司外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/笔记/设计模式/外观模式2-015.png)\\n\\n      代码：\\n\\n      ```java\\n      package chapter05.facade;         //外观角色\\n      \\n      public class  Client{\\n      \\tpublic static void main(String[] args) {\\n      \\n      \\tnew RegisterFacade().register();\\n      \\n      \\t}\\n      }\\n      \\n      public class RegisterFacade  {\\n          public void register(){\\n            工商总局 a = new 工商局();\\n            a.checkName();\\n      \\t    税务总局 b = new 税务局();\\n            b.texCertificate();\\n            质监总局 c = new 质监局();\\n            c.orgCodeCertificate();\\n            银行 d = new 工商银行()\\n            d.openAccount();\\n         }\\t\\t\\t\\n      }\\n      \\n      public interface 工商总局{\\n         void checkName();\\n      }\\n      class 工商局 implements 工商总局  {\\n      \\tSystem.out.println(“检查名字是否冲突！”);\\t\\t\\n      }\\n      public interface 税务总局{\\n         void texCertificate();   //办理税务登记证\\n      }\\n      class 税务局 implements 税务总局  {\\n      \\tSystem.out.println(“在税务局办理税务登记证！”);\\t\\t\\n      }\\n      public interface 银行{\\n         void openAccount();   //开户\\n      }\\n      class 工商银行 implements 银行  {\\n      \\tSystem.out.println(“在中国工商银行开户！”);\\t\\t\\t\\n      }\\n      public interface 质监总局{\\n         void orgCodeCertificate();   //办理组织结构代码证\\n      }\\n      class 质监局 implements 质监总局  {\\n      \\tSystem.out.println(“在质监总局办理组织结构代码证！”);\\t\\t\\n      }\\n      ```\\n\\n      \\n\\n### 3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（C）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      \\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      \\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n        \\n      \\n   2. 以下情况不适合使用代理模式的是（A）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      \\n      - [ ] 根据需要创建开销很大的对象\\n      \\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      \\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n      \\n        \\n      \\n   3. 以下意图可以用来描述外观（A）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      \\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      \\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      \\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n### 1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n### 2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。<font color=\\\"#e1e9ee\\\">~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~</font>（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n\\n### 3. 单选题：\\n\\n   1. 以下意图（D）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n      \\n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      \\n   2. 以下（A）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      \\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      \\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      \\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.101', '山西省太原市 移动', '2022-06-29 16:32:48', NULL);
INSERT INTO `tb_operation_log` VALUES (1237, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# <center>设计模式</center>\\n\\n## 1 设计模式基础\\n\\n### 1. 设计模式的优点\\n\\n   1. 可以提高程序员的思维能力、编程能力和设计能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n### 2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：以灵活的方式创建对象集合，用于管理对象的创建。包含：单例、原型、工厂方法、抽象工程、<font color=\\\"#e1e9ee\\\">~~建造者~~</font>\\n\\n      结构型模式：将已有的代码集成到新的面向对象中，用于处理类或对象的组合。包含：代理、外观、<font color=\\\"#e1e9ee\\\">~~适配器、桥接、装饰、享元、组合~~</font>\\n\\n      行为型模式：用于描述对类或对象怎样交互和怎样分配职责。包含：模板方法、策略、<font color=\\\"#e1e9ee\\\">~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、</font>\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、<font color=\\\"#e1e9ee\\\">~~适配器、解释器~~</font>\\n\\n      对象模式：（除了以上四种都是）\\n\\n### 3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（- - - >）：耦合度最低的一种关联方式，是临时性的关联\\n\\n      关联关系（—）：是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的关系\\n\\n      聚合关系（—◇）：强关联关系，是整体和部分之间的关系\\n\\n      组合关系（—◆）：关联关系的一种，是整体与部分之间更强烈的聚合的关系\\n\\n      泛化关系（—▷）：耦合度最大的的一种关系，表示父类和子类之间的继承关系\\n\\n      实现关系（- - - ▷）：是接口和实现类之间的关系，类中要实现接口中的所有抽象方法\\n\\n### 4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（A）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n### 5. 多选题\\n\\n   1. 以下是模式的基本要素（ABCD）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n        \\n\\n   2. 面向对象系统中功能复用的最常用技术（AB）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n### 6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n### 7. 七大原则\\n\\n   1. 开闭原则：\\n\\n      软件实体应当对扩展开放，对修改关闭。（对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性\\n\\n   2. 里氏替换原则：\\n\\n      继承必须确保父类拥有的性质在子类中仍然成立\\n\\n   3. 依赖倒置原则：\\n\\n      高层模块不应该依赖底层模块，两者都应该依赖其抽象\\n\\n   4. 单一职责原则：\\n\\n      一个类应该有且仅有一个引起它变化的原因\\n\\n   5. 接口隔离原则：\\n\\n      一个类对另一个类的依赖应该建立在最小的接口上\\n\\n   6. 迪米特法则：\\n\\n      又叫最少知识原则，如果两个软件实体无需直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用\\n\\n   7. 合成复用原则：\\n\\n      又叫组合/聚合原则，尽量使用合成或聚合等关系来实现，其次才考虑继承关系实现\\n\\n## 2 创建型模式\\n\\n### 1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 某类只要求生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合，由于单例模式只允许创建一个对象，共享该对象可以节省资源\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n### 2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n### 3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体工厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：同一种产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式可以用来创建不同类的各个产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n### 4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（A）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n        \\n\\n   2. 在（C）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n### 5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（ABCD）\\n      - [x] 运行时刻增加和删除产品\\n      \\n      - [x] 改变值以指定新对象\\n      \\n      - [x] 减少子类的构造\\n      \\n      - [x] 用类动态配置应用\\n      \\n        \\n      \\n   2. 以下属于单例模式的优点是（ABCD）\\n      - [x] 对唯一实例的受控访问\\n      \\n      - [x] 允许对操作和表示的精化\\n      \\n      - [x] 允许可变数目的实例\\n      \\n      - [x] 比类操作更灵活\\n      \\n        \\n      \\n   3. 当应用工厂方法模式时需要考虑（ABCD）\\n      - [x] 主要有两种不同的情况\\n      \\n      - [x] 参数化工厂方法\\n\\n      - [x] 特定语言的变化和问题\\n\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n### 1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n   1. （明星）例子：\\n\\n      结构图：\\n\\n      ![明星代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/笔记/设计模式/图片1-f10.png)\\n\\n      代码：\\n\\n      ```java\\n      package porxy;\\n      \\n      public interface Star {\\n        void confer();                 //面谈\\n        void signContrack();           //签合同\\n        void bookTicket();             //订票\\n        void sing();                  //唱歌\\n        void collectmoney();            //收钱\\n      }\\n      \\n      public class RealStar implements Star{\\n      \\t public void confer(){               //面谈\\n      \\t    System.out.println(\\\"RealStar.confer()\\\");\\n      \\t }\\n      \\t  public void signContrack(){           //签合同\\n      \\t\\t  System.out.println(\\\"RealStar.signContrack()\\\");  \\n      \\t  }\\n      \\t  public void bookTicket(){           //订票\\n      \\t\\t  System.out.println(\\\"RealStar.bookTicket()\\\");  \\n      \\t  }\\n      \\t  public void sing(){                  //唱歌\\n      \\t\\t  System.out.println(\\\"RealStar(周杰伦本人).sing()\\\");  \\n      \\t  }\\n      \\t  public void collectmoney(){            //收钱\\n      \\t\\t  System.out.println(\\\"RealStar.collectmoney()\\\");  \\n      \\t  }\\n      }\\n      \\n      public class porxyStar implements Star {\\n         private Star star;\\n         public porxyStar(Star star){\\n      \\t   super();\\n      \\t   this.star = star;\\n           }\\n         public void confer() {\\n      \\t  System.out.println(\\\"porxyStar.confer()\\\");\\t\\t\\n      \\t}\\n         public void signContrack() {\\n      \\t\\t System.out.println(\\\"porxyStar.signContrack()\\\");\\t\\n      \\t}\\n      \\tpublic void bookTicket() {\\n      \\t\\tSystem.out.println(\\\"porxyStar.bookTicket()\\\");\\n      \\t}\\n      \\tpublic void sing() {\\n      \\t\\t star.sing();\\n      \\t}\\n      \\tpublic void collectmoney() {\\n      \\t\\t System.out.println(\\\"porxyStar.collectmoney()\\\");\\n      \\t}\\n      }\\n      \\n      public class client {\\n      \\tpublic static void main(String[] args) {\\t\\n      \\tStar real = new RealStar();\\n      \\tStar porxy = new porxyStar(real);\\t\\n              porxy.confer();\\n              porxy.signContrack();\\n              porxy.bookTicket();\\n              porxy.sing();\\n              porxy.collectmoney();\\n      \\t}\\n      }\\n      ```\\n\\n      \\n\\n### 2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n   1. （注册公司）例子：\\n\\n      结构图：\\n\\n      ![注册公司外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/笔记/设计模式/外观模式2-015.png)\\n\\n      代码：\\n\\n      ```java\\n      package chapter05.facade;         //外观角色\\n      \\n      public class  Client{\\n      \\tpublic static void main(String[] args) {\\n      \\n      \\tnew RegisterFacade().register();\\n      \\n      \\t}\\n      }\\n      \\n      public class RegisterFacade  {\\n          public void register(){\\n            工商总局 a = new 工商局();\\n            a.checkName();\\n      \\t    税务总局 b = new 税务局();\\n            b.texCertificate();\\n            质监总局 c = new 质监局();\\n            c.orgCodeCertificate();\\n            银行 d = new 工商银行()\\n            d.openAccount();\\n         }\\t\\t\\t\\n      }\\n      \\n      public interface 工商总局{\\n         void checkName();\\n      }\\n      class 工商局 implements 工商总局  {\\n      \\tSystem.out.println(“检查名字是否冲突！”);\\t\\t\\n      }\\n      public interface 税务总局{\\n         void texCertificate();   //办理税务登记证\\n      }\\n      class 税务局 implements 税务总局  {\\n      \\tSystem.out.println(“在税务局办理税务登记证！”);\\t\\t\\n      }\\n      public interface 银行{\\n         void openAccount();   //开户\\n      }\\n      class 工商银行 implements 银行  {\\n      \\tSystem.out.println(“在中国工商银行开户！”);\\t\\t\\t\\n      }\\n      public interface 质监总局{\\n         void orgCodeCertificate();   //办理组织结构代码证\\n      }\\n      class 质监局 implements 质监总局  {\\n      \\tSystem.out.println(“在质监总局办理组织结构代码证！”);\\t\\t\\n      }\\n      ```\\n\\n      \\n\\n### 3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（C）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      \\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      \\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n        \\n      \\n   2. 以下情况不适合使用代理模式的是（A）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      \\n      - [ ] 根据需要创建开销很大的对象\\n      \\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      \\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n      \\n        \\n      \\n   3. 以下意图可以用来描述外观（A）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      \\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      \\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      \\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n### 1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进\\n         行扩展。\\n\\n### 2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。<font color=\\\"#e1e9ee\\\">~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~</font>（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关\\n         的数据结构。\\n      \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n\\n### 3. 单选题：\\n\\n   1. 以下意图（D）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n      \\n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      \\n   2. 以下（A）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      \\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      \\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      \\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.105', '山西省太原市 移动', '2022-06-29 19:23:37', NULL);
INSERT INTO `tb_operation_log` VALUES (1238, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# <center>设计模式</center>\\n\\n## 1 设计模式基础\\n\\n### 1. 设计模式的优点\\n\\n   1. 可以提高程序员的思维能力、编程能力和设计能力\\n   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\\n   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\\n\\n### 2. 设计模式分为哪几类\\n\\n   1. 根据目的来分：\\n\\n      创建型模式：以灵活的方式创建对象集合，用于管理对象的创建。包含：单例、原型、工厂方法、抽象工程、<font color=\\\"#e1e9ee\\\">~~建造者~~</font>\\n\\n      结构型模式：将已有的代码集成到新的面向对象中，用于处理类或对象的组合。包含：代理、外观、<font color=\\\"#e1e9ee\\\">~~适配器、桥接、装饰、享元、组合~~</font>\\n\\n      行为型模式：用于描述对类或对象怎样交互和怎样分配职责。包含：模板方法、策略、<font color=\\\"#e1e9ee\\\">~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、</font>\\n\\n   2. 根据作用范围来分：\\n\\n      类模式：工厂方法、模板方法、<font color=\\\"#e1e9ee\\\">~~适配器、解释器~~</font>\\n\\n      对象模式：（除了以上四种都是）\\n\\n### 3. 类之间的关系\\n\\n   1. 耦合度从弱到强：\\n\\n      依赖关系（- - - >）：耦合度最低的一种关联方式，是临时性的关联\\n\\n      关联关系（—）：是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的关系\\n\\n      聚合关系（—◇）：强关联关系，是整体和部分之间的关系\\n\\n      组合关系（—◆）：关联关系的一种，是整体与部分之间更强烈的聚合的关系\\n\\n      泛化关系（—▷）：耦合度最大的的一种关系，表示父类和子类之间的继承关系\\n\\n      实现关系（- - - ▷）：是接口和实现类之间的关系，类中要实现接口中的所有抽象方法\\n\\n### 4. 单选题：\\n\\n   1. 以下对开闭原则的描述错误的是（A）\\n\\n      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性\\n\\n      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则\\n\\n      - [ ] C. 对修改关闭，是其原则之一\\n\\n      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一\\n\\n### 5. 多选题\\n\\n   1. 以下是模式的基本要素（ABCD）\\n\\n      - [x] 名称\\n\\n      - [x] 意图\\n\\n      - [x] 解决方案\\n\\n      - [x] 参与者和协作者\\n\\n        \\n\\n   2. 面向对象系统中功能复用的最常用技术（AB）\\n\\n      - [x] 类继承\\n\\n      - [x] 对象组合\\n\\n      - [ ] 使用抽象类\\n\\n      - [ ] 使用实现类\\n\\n### 6. 设计模式的两大主题：\\n\\n   系统复用、系统扩展\\n\\n### 7. 七大原则\\n\\n   1. 开闭原则：\\n\\n      软件实体应当对扩展开放，对修改关闭。（对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性\\n\\n   2. 里氏替换原则：\\n\\n      继承必须确保父类拥有的性质在子类中仍然成立\\n\\n   3. 依赖倒置原则：\\n\\n      高层模块不应该依赖底层模块，两者都应该依赖其抽象\\n\\n   4. 单一职责原则：\\n\\n      一个类应该有且仅有一个引起它变化的原因\\n\\n   5. 接口隔离原则：\\n\\n      一个类对另一个类的依赖应该建立在最小的接口上\\n\\n   6. 迪米特法则：\\n\\n      又叫最少知识原则，如果两个软件实体无需直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用\\n\\n   7. 合成复用原则：\\n\\n      又叫组合/聚合原则，尽量使用合成或聚合等关系来实现，其次才考虑继承关系实现\\n\\n## 2 创建型模式\\n\\n### 1. 单例模式\\n\\n   1. 定义：\\n\\n      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）\\n\\n   2. 主要角色：\\n\\n      1. 单例类：包含一个实例且能够自行创建这个实例的类\\n      2. 访问类：使用单例的类\\n\\n   3. 两种实现形式：\\n\\n      懒汉式单例、饿汉式单例\\n\\n   4. 应用场景：\\n\\n      1. 某类只要求生成一个对象的时候，如总统、班长、太阳等\\n      2. 当对象需要被共享的场合，由于单例模式只允许创建一个对象，共享该对象可以节省资源\\n      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候\\n\\n### 2. 工厂方法\\n\\n   1. 主要角色：\\n\\n      1. 抽象工厂\\n      2. 具体工厂\\n      3. 抽象产品\\n      4. 具体产品\\n      \\n   1. 工厂方法和简单工厂的区别\\n\\n      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。\\n\\n### 3. 抽象工厂模式\\n\\n   1. 主要角色：\\n\\n      （与工厂方法一致）\\n\\n   2. 产品族、产品等级\\n\\n      产品族：将同一个具体工厂所产生的位于不同等级的一组产品称为一个产品族\\n\\n      产品等级：同一种产品称为一个产品等级\\n\\n   3. 工厂方法和抽象工厂方法区别\\n\\n      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式可以用来创建不同类的各个产品（不同品牌的空调、冰箱、洗衣机等产品）\\n\\n### 4. 单选题：\\n\\n   1. 以下关于创建型模式说法正确的是（A）\\n\\n      - [x] 创建型模式关注的是对象的创建\\n\\n      - [ ] 创建型模式关注的是功能的实现\\n\\n      - [ ] 创建型模式关注的是组织类和对象常用方法\\n\\n      - [ ] 创建型模式关注的是对象间的协作\\n\\n        \\n\\n   2. 在（C）适合使用单例模式\\n\\n      - [ ] 当一个类不知道她所必须创建的对象的类的时候\\n\\n      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时\\n\\n      - [x] 当这个唯一实力应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时\\n\\n      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候\\n\\n### 5. 多选题：\\n\\n   1. 下面属于原型模式的优点是（ABCD）\\n      - [x] 运行时刻增加和删除产品\\n      \\n      - [x] 改变值以指定新对象\\n      \\n      - [x] 减少子类的构造\\n      \\n      - [x] 用类动态配置应用\\n      \\n        \\n      \\n   2. 以下属于单例模式的优点是（ABCD）\\n      - [x] 对唯一实例的受控访问\\n      \\n      - [x] 允许对操作和表示的精化\\n      \\n      - [x] 允许可变数目的实例\\n      \\n      - [x] 比类操作更灵活\\n      \\n        \\n      \\n   3. 当应用工厂方法模式时需要考虑（ABCD）\\n      - [x] 主要有两种不同的情况\\n      \\n      - [x] 参数化工厂方法\\n\\n      - [x] 特定语言的变化和问题\\n\\n      - [x] 使用模板以避免创建子类\\n\\n## 3 结构型模式\\n\\n### 1. 代理模式\\n\\n   1. 主要角色：\\n\\n      1. 抽象主题类\\n      2. 真实主题类\\n      3. 代理类\\n\\n   1. 结构图：\\n\\n      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)\\n\\n   1. （明星）例子：\\n\\n      结构图：\\n\\n      ![明星代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/笔记/设计模式/图片1-f10.png)\\n\\n      代码：\\n\\n      ```java\\n      package porxy;\\n      \\n      public interface Star {\\n        void confer();                 //面谈\\n        void signContrack();           //签合同\\n        void bookTicket();             //订票\\n        void sing();                  //唱歌\\n        void collectmoney();            //收钱\\n      }\\n      \\n      public class RealStar implements Star{\\n      \\t public void confer(){               //面谈\\n      \\t    System.out.println(\\\"RealStar.confer()\\\");\\n      \\t }\\n      \\t  public void signContrack(){           //签合同\\n      \\t\\t  System.out.println(\\\"RealStar.signContrack()\\\");  \\n      \\t  }\\n      \\t  public void bookTicket(){           //订票\\n      \\t\\t  System.out.println(\\\"RealStar.bookTicket()\\\");  \\n      \\t  }\\n      \\t  public void sing(){                  //唱歌\\n      \\t\\t  System.out.println(\\\"RealStar(周杰伦本人).sing()\\\");  \\n      \\t  }\\n      \\t  public void collectmoney(){            //收钱\\n      \\t\\t  System.out.println(\\\"RealStar.collectmoney()\\\");  \\n      \\t  }\\n      }\\n      \\n      public class porxyStar implements Star {\\n         private Star star;\\n         public porxyStar(Star star){\\n      \\t   super();\\n      \\t   this.star = star;\\n           }\\n         public void confer() {\\n      \\t  System.out.println(\\\"porxyStar.confer()\\\");\\t\\t\\n      \\t}\\n         public void signContrack() {\\n      \\t\\t System.out.println(\\\"porxyStar.signContrack()\\\");\\t\\n      \\t}\\n      \\tpublic void bookTicket() {\\n      \\t\\tSystem.out.println(\\\"porxyStar.bookTicket()\\\");\\n      \\t}\\n      \\tpublic void sing() {\\n      \\t\\t star.sing();\\n      \\t}\\n      \\tpublic void collectmoney() {\\n      \\t\\t System.out.println(\\\"porxyStar.collectmoney()\\\");\\n      \\t}\\n      }\\n      \\n      public class client {\\n      \\tpublic static void main(String[] args) {\\t\\n      \\tStar real = new RealStar();\\n      \\tStar porxy = new porxyStar(real);\\t\\n              porxy.confer();\\n              porxy.signContrack();\\n              porxy.bookTicket();\\n              porxy.sing();\\n              porxy.collectmoney();\\n      \\t}\\n      }\\n      ```\\n\\n      \\n\\n### 2. 外观模式\\n\\n   1. 主要角色：\\n\\n      1. 外观角色\\n      2. 子系统角色\\n      3. 客户角色\\n\\n   1. 结构图：\\n\\n      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)\\n\\n   1. （注册公司）例子：\\n\\n      结构图：\\n\\n      ![注册公司外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/笔记/设计模式/外观模式2-015.png)\\n\\n      代码：\\n\\n      ```java\\n      package chapter05.facade;         //外观角色\\n      \\n      public class  Client{\\n      \\tpublic static void main(String[] args) {\\n      \\n      \\tnew RegisterFacade().register();\\n      \\n      \\t}\\n      }\\n      \\n      public class RegisterFacade  {\\n          public void register(){\\n            工商总局 a = new 工商局();\\n            a.checkName();\\n      \\t    税务总局 b = new 税务局();\\n            b.texCertificate();\\n            质监总局 c = new 质监局();\\n            c.orgCodeCertificate();\\n            银行 d = new 工商银行()\\n            d.openAccount();\\n         }\\t\\t\\t\\n      }\\n      \\n      public interface 工商总局{\\n         void checkName();\\n      }\\n      class 工商局 implements 工商总局  {\\n      \\tSystem.out.println(“检查名字是否冲突！”);\\t\\t\\n      }\\n      public interface 税务总局{\\n         void texCertificate();   //办理税务登记证\\n      }\\n      class 税务局 implements 税务总局  {\\n      \\tSystem.out.println(“在税务局办理税务登记证！”);\\t\\t\\n      }\\n      public interface 银行{\\n         void openAccount();   //开户\\n      }\\n      class 工商银行 implements 银行  {\\n      \\tSystem.out.println(“在中国工商银行开户！”);\\t\\t\\t\\n      }\\n      public interface 质监总局{\\n         void orgCodeCertificate();   //办理组织结构代码证\\n      }\\n      class 质监局 implements 质监总局  {\\n      \\tSystem.out.println(“在质监总局办理组织结构代码证！”);\\t\\t\\n      }\\n      ```\\n\\n      \\n\\n### 3. 单选题：\\n\\n   1. 以下意图用来描述代理（Proxy）的是（C）\\n      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\\n      \\n      - [ ] 运用共享技术有效地支持大量细粒度的对象\\n      \\n      - [x] 为其他对象提供一种代理以控制对这个对象的访问\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n        \\n      \\n   2. 以下情况不适合使用代理模式的是（A）\\n      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求\\n      \\n      - [ ] 根据需要创建开销很大的对象\\n      \\n      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候\\n      \\n      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作\\n      \\n        \\n      \\n   3. 以下意图可以用来描述外观（A）\\n      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\\n      \\n      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类\\n      \\n      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点\\n      \\n      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态\\n\\n## 4 行为型模式\\n\\n### 1. 模板方法\\n\\n   1. 定义：\\n\\n      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤\\n\\n   2. 主要角色：\\n\\n      1. 抽象类\\n      2. 具体子类\\n\\n   3. 应用场景：\\n\\n      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\\n      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。\\n      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。\\n\\n### 2. 策略模式\\n\\n   1. 定义：\\n\\n      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。<font color=\\\"#e1e9ee\\\">~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~</font>（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）\\n\\n   2. 主要角色：\\n\\n      1. 抽象策略类\\n      2. 具体策略类\\n      3. 环境类\\n   \\n   3. 应用场景：\\n   \\n      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\\n      \\n      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\\n      \\n      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\\n      \\n      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。\\n         \\n      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\\n\\n### 3. 单选题：\\n\\n   1. 以下意图（D）可用来描述策略\\n      \\n      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化\\n      \\n      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\\n      \\n      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中\\n      \\n      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换\\n      \\n   2. 以下（A）不适合使用策略模式\\n      \\n      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的\\n      \\n      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\\n      \\n      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式\\n      \\n      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/3d4da8e3763c9337aea9e41b1280e084.jpg\",\"articleTitle\":\"设计模式\",\"categoryName\":\"学习和技术总结\",\"id\":67,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.104', '山西省太原市 移动', '2022-06-30 22:08:08', NULL);
INSERT INTO `tb_operation_log` VALUES (1239, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre>\\n  首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n  剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n  我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n  祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n<div id=\\\"musicMouseDrag\\\" style=\\\"position:fixed; z-index: 9999; bottom: 0; right: 0;\\\">\\n    <div id=\\\"musicDragArea\\\" style=\\\"position: absolute; top: 0; left: 0; width: 100%;height: 10px;cursor: move; z-index: 10;\\\"></div>\\n    <iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n</div>\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"动漫\",\"京阿尼\"],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.101', '山西省太原市 移动', '2022-06-30 22:36:45', NULL);
INSERT INTO `tb_operation_log` VALUES (1240, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre>\\n  首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n  剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n  我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n  祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n<div id=\\\"musicMouseDrag\\\" style=\\\"position:fixed; z-index: 9999; bottom: 0; align=\\\"left\\\";\\\">\\n    <div id=\\\"musicDragArea\\\" style=\\\"position: absolute; top: 0; left: 0; width: 100%;height: 10px;cursor: move; z-index: 10;\\\"></div>\\n    <iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n</div>\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.104', '山西省太原市 移动', '2022-06-30 22:40:53', NULL);
INSERT INTO `tb_operation_log` VALUES (1241, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre>\\n  首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n  剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n  我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n  祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n<div id=\\\"musicMouseDrag\\\" style=\\\"position:fixed; bottom: 0; right: 0; left: 9999\\\">\\n    <div id=\\\"musicDragArea\\\" style=\\\"position: absolute; top: 0; left: 0; width: 100%;height: 10px;cursor: move; z-index: 10;\\\"></div>\\n    <iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n</div>\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.102', '山西省太原市 移动', '2022-06-30 22:43:33', NULL);
INSERT INTO `tb_operation_log` VALUES (1242, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre>\\n  首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n  剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n  我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n  祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n<div id=\\\"musicMouseDrag\\\" style=\\\"position:fixed; bottom: 0; right: 0; left: 9999\\\">\\n    <div id=\\\"musicDragArea\\\" style=\\\"position: absolute; top: 0; left: 0; width: 100%;height: 10px;cursor: move; z-index: 500;\\\"></div>\\n    <iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n</div>\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.102', '山西省太原市 移动', '2022-06-30 22:43:58', NULL);
INSERT INTO `tb_operation_log` VALUES (1243, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre>\\n  首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n  剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n  我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n  祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n<link rel=\\\"stylesheet\\\" href=\\\"https://blog-static.cnblogs.com/files/lihanqing/APlayer.min.css\\\">\\n<script src=\\\"https://blog-static.cnblogs.com/files/lihanqing/APlayer.min.js\\\"></script>\\n<script src=\\\"https://blog-static.cnblogs.com/files/lihanqing/Meting.min.js\\\"></script>\\n<div id=\\\"player\\\" class=\\\"aplayer aplayer-withlist aplayer-fixed\\\" data-id=\\\"<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\\" data-server=\\\"netease\\\" data-type=\\\"playlist\\\" data-order=\\\"random\\\" data-fixed=\\\"true\\\" data-listfolded=\\\"true\\\" data-theme=\\\"orange\\\"></div>\\n\\n\\n\\n\\n\\n\\n<div id=\\\"musicMouseDrag\\\" style=\\\"position:fixed; bottom: 0; right: 0; left: 9999\\\">\\n    <div id=\\\"musicDragArea\\\" style=\\\"position: absolute; top: 0; left: 0; width: 100%;height: 10px;cursor: move; z-index: 10;\\\"></div>\\n    \\n</div>\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-30 22:48:02', NULL);
INSERT INTO `tb_operation_log` VALUES (1244, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre>\\n  首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n  剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n  我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n  祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n<div id=\\\"musicMouseDrag\\\" style=\\\"position:fixed; bottom: 0; right: 0; left: 9999\\\">\\n    <div id=\\\"musicDragArea\\\" style=\\\"position: absolute; top: 0; left: 0; width: 100%;height: 10px;cursor: move; z-index: 500;\\\"></div>\\n    <iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n</div>\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":71,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.100', '山西省太原市 移动', '2022-06-30 22:48:35', NULL);
INSERT INTO `tb_operation_log` VALUES (1245, '文章模块', '修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[68],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.100', '山西省太原市 移动', '2022-06-30 22:48:42', NULL);
INSERT INTO `tb_operation_log` VALUES (1246, '文章模块', '修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[69],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.100', '山西省太原市 移动', '2022-06-30 22:48:45', NULL);
INSERT INTO `tb_operation_log` VALUES (1247, '文章模块', '修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[70],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.100', '山西省太原市 移动', '2022-06-30 22:48:48', NULL);
INSERT INTO `tb_operation_log` VALUES (1248, '文章模块', '修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.updateArticleDelete', '恢复或删除文章', '[{\"idList\":[71],\"isDelete\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.100', '山西省太原市 移动', '2022-06-30 22:48:51', NULL);
INSERT INTO `tb_operation_log` VALUES (1249, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre>\\n  首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n  剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n  我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n  祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n<link rel=\\\"stylesheet\\\" href=\\\"https://blog-static.cnblogs.com/files/lihanqing/APlayer.min.css\\\">\\n<script src=\\\"https://blog-static.cnblogs.com/files/lihanqing/APlayer.min.js\\\"></script>\\n<script src=\\\"https://blog-static.cnblogs.com/files/lihanqing/Meting.min.js\\\"></script>\\n<div id=\\\"player\\\" class=\\\"aplayer aplayer-withlist aplayer-fixed\\\" data-id=\\\"<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\\" data-server=\\\"netease\\\" data-type=\\\"playlist\\\" data-order=\\\"random\\\" data-fixed=\\\"true\\\" data-listfolded=\\\"true\\\" data-theme=\\\"orange\\\"></div>\\n\\n\\n\\n\\n\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.100', '山西省太原市 移动', '2022-06-30 22:49:08', NULL);
INSERT INTO `tb_operation_log` VALUES (1250, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre>\\n  首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n  剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n  我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n  祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n<link rel=\\\"stylesheet\\\" href=\\\"https://blog-static.cnblogs.com/files/lihanqing/APlayer.min.css\\\">\\n<script src=\\\"https://blog-static.cnblogs.com/files/lihanqing/APlayer.min.js\\\"></script>\\n<script src=\\\"https://blog-static.cnblogs.com/files/lihanqing/Meting.min.js\\\"></script>\\n<div id=\\\"player\\\" class=\\\"aplayer aplayer-withlist aplayer-fixed\\\" data-id=\\\"534065323\\\" data-server=\\\"netease\\\" data-type=\\\"playlist\\\" data-order=\\\"random\\\" data-fixed=\\\"true\\\" data-listfolded=\\\"true\\\" data-theme=\\\"orange\\\"></div>\\n\\n\\n\\n\\n\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.100', '山西省太原市 移动', '2022-06-30 22:51:11', NULL);
INSERT INTO `tb_operation_log` VALUES (1251, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre>\\n  首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n  剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n  我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n  祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n<link rel=\\\"stylesheet\\\" href=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\\\">\\n\\n<link rel=\\\"stylesheet\\\" href=\\\"https://blog-static.cnblogs.com/files/lihanqing/APlayer.min.css\\\">\\n<script src=\\\"https://blog-static.cnblogs.com/files/lihanqing/APlayer.min.js\\\"></script>\\n<script src=\\\"https://blog-static.cnblogs.com/files/lihanqing/Meting.min.js\\\"></script>\\n<div id=\\\"player\\\" class=\\\"aplayer aplayer-withlist aplayer-fixed\\\" data-id=\\\"534065323\\\" data-server=\\\"netease\\\" data-type=\\\"playlist\\\" data-order=\\\"random\\\" data-fixed=\\\"true\\\" data-listfolded=\\\"true\\\" data-theme=\\\"orange\\\"></div>\\n\\n\\n\\n\\n\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.100', '山西省太原市 移动', '2022-06-30 22:52:37', NULL);
INSERT INTO `tb_operation_log` VALUES (1252, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre>\\n  首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n  剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n  我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n  祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.102', '山西省太原市 移动', '2022-06-30 22:54:05', NULL);
INSERT INTO `tb_operation_log` VALUES (1253, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre style=\\\"white-space: pre-wrap;\\n  word-wrap: break-word; background: white; \\\">首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n  剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n  我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n  祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.100', '山西省太原市 移动', '2022-06-30 23:10:33', NULL);
INSERT INTO `tb_operation_log` VALUES (1254, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre style=\\\"white-space: pre-wrap;\\n  word-wrap: break-word; background: white; border-top: 5px solid #f56c6c; border-bottom: 5px solid #f56c6c;\\\">首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n  剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n  我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n  祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.105', '山西省太原市 移动', '2022-06-30 23:14:23', NULL);
INSERT INTO `tb_operation_log` VALUES (1255, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre style=\\\"white-space: pre-wrap;\\n  word-wrap: break-word; background: white; border-top: 5px solid #f56c6c; border-bottom: 5px solid #f56c6c;\\\">\\n    首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n    剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n    我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n    祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.100', '山西省太原市 移动', '2022-06-30 23:15:12', NULL);
INSERT INTO `tb_operation_log` VALUES (1256, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre style=\\\"white-space: pre-wrap;\\n  word-wrap: break-word; background: white; border-top: 5px solid #f56c6c; border-bottom: 5px solid #f56c6c; line-height: 2\\\">\\n    首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n    剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n    我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n    祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.101', '山西省太原市 移动', '2022-06-30 23:16:16', NULL);
INSERT INTO `tb_operation_log` VALUES (1257, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre style=\\\"white-space: pre-wrap;\\n  word-wrap: break-word; background: white; border-top: 5px solid #f56c6c; border-bottom: 5px solid #f56c6c; line-height: 2; font-size: 16px;\\\">\\n    首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n    剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n    我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n    祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.105', '山西省太原市 移动', '2022-06-30 23:17:04', NULL);
INSERT INTO `tb_operation_log` VALUES (1258, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre style=\\\"white-space: pre-wrap;\\n  word-wrap: break-word; background: white; border-top: 5px solid #f56c6c; border-bottom: 5px solid #f56c6c; line-height: 2; font-size: 16px;\\\">\\n    \\t首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n    \\t剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n    \\t我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n    \\t祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.102', '山西省太原市 移动', '2022-06-30 23:17:32', NULL);
INSERT INTO `tb_operation_log` VALUES (1259, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre style=\\\"white-space: pre-wrap;\\n  word-wrap: break-word; background: #eaeaea; border-top: 5px solid #f56c6c; border-bottom: 5px solid #f56c6c; line-height: 2; font-size: 16px;\\\">\\n    \\t首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n    \\t剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n    \\t我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n    \\t祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.105', '山西省太原市 移动', '2022-06-30 23:22:42', NULL);
INSERT INTO `tb_operation_log` VALUES (1260, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre style=\\\"white-space: pre-wrap;\\n  word-wrap: break-word; background: #eaeaea; border-top: 5px solid #f56c6c; border-bottom: 5px solid #f56c6c; line-height: 2; font-size: 16px; font-family:宋体;\\\">\\n    \\t首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n    \\t剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n    \\t我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n    \\t祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-30 23:25:48', NULL);
INSERT INTO `tb_operation_log` VALUES (1261, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre style=\\\"white-space: pre-wrap;\\n  word-wrap: break-word; background: #fafafa; border-top: 5px solid #f56c6c; border-bottom: 5px solid #f56c6c; line-height: 2; font-size: 16px; font-family:宋体;\\\">\\n    \\t首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n    \\t剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n    \\t我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n    \\t祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-30 23:26:31', NULL);
INSERT INTO `tb_operation_log` VALUES (1262, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre style=\\\"white-space: pre-wrap;\\n  word-wrap: break-word; background: #fafafa; border-top: 5px solid #f56c6c; border-bottom: 5px solid #f56c6c; line-height: 2; font-size: 16px; font-family:仿宋;\\\">\\n    \\t首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n    \\t剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n    \\t我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n    \\t祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-30 23:26:53', NULL);
INSERT INTO `tb_operation_log` VALUES (1263, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"<font color=red>温馨提示：该文章写于三年前，makrdown、html、css 和 js都还不熟悉，因此文章和格式写的很烂很烂，请抱着死亡的心态阅读下去吧！</font>\\n<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%发E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre style=\\\"white-space: pre-wrap;\\n  word-wrap: break-word; background: #fafafa; border-top: 5px solid #f56c6c; border-bottom: 5px solid #f56c6c; line-height: 2; font-size: 16px; font-family:仿宋;\\\">\\n    \\t首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n    \\t剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n    \\t我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n    \\t祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-06-30 23:32:41', NULL);
INSERT INTO `tb_operation_log` VALUES (1264, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre>\\n  首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n  剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n  我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n  祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n<div id=\\\"musicMouseDrag\\\" style=\\\"position:fixed; bottom: 0; right: 0; left: 9999\\\">\\n    <div id=\\\"musicDragArea\\\" style=\\\"position: absolute; top: 0; left: 0; width: 100%;height: 10px;cursor: move; z-index: 500;\\\"></div>\\n    <iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n</div>\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":71,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.101', '山西省太原市 移动', '2022-06-30 23:33:31', NULL);
INSERT INTO `tb_operation_log` VALUES (1265, '文章模块', '删除', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.deleteArticles', '物理删除文章', '[[71,70,69,68,66,65,64]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.102', '山西省太原市 移动', '2022-06-30 23:34:24', NULL);
INSERT INTO `tb_operation_log` VALUES (1266, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"<font color=red>温馨提示：该文章写于三年前，makrdown、html、css 和 js都还不熟悉，因此文章和格式写的很烂很烂，请抱着死亡的心态阅读下去吧！</font>\\n<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<!--more-->\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%发E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre style=\\\"white-space: pre-wrap;\\n  word-wrap: break-word; background: #fafafa; border-top: 5px solid #f56c6c; border-bottom: 5px solid #f56c6c; line-height: 2; font-size: 16px; font-family:仿宋;\\\">\\n    \\t首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n    \\t剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n    \\t我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n    \\t祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '120.208.43.183', '山西省长治市 移动', '2022-07-04 17:32:09', NULL);
INSERT INTO `tb_operation_log` VALUES (1267, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"<font color=red>温馨提示：该文章写于三年前，makrdown、html、css 和 js都还不熟悉，因此文章和格式写的很烂很烂，请抱着死亡的心态阅读下去吧！</font>\\n\\n<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n\\n薇尔莉特是这部剧的女主，是一名在战场上失去双臂，为寻求什么是爱而加入了自动手记人偶这一职业并逐渐成长的故事\\n\\n什么是自动手记人偶呢？在过去，尤其是战争时期，大多数人都未能接受良好的教育，以至于不会写字和识字，因此想要写信时，就需要代写的人帮忙写信，后来逐渐演变成为一种职业，在该剧中被称之为——自动手记人偶。【既然有职业代写人，自然有职业读信人，所以别产生 “寄了信对方看不懂，那怎么办” 的想法了】\\n\\n一种职业的产生和发展必定和“内卷”离不开关系，一开始代写的人只是重述着写信人的话语，但是大多数人来写信都因其抱有着思念之情无处安放，有的是爱人、家人、朋友；有的是国家、家乡；他们的感情浓厚且强烈，而如何把 “老伴儿啊，俺好想你了，你啷个时候能回来啊？娃儿都长高了” 这句话用生动、精彩、美丽又富有感情地表达出来，就显得尤为重要了。\\n\\n如果翻译成 “老公，我想你了，你什么时候能回来？” 好像也不错，但是似乎有点不够生动；如果翻译成 “亲爱的，你现在身在何方？又何时能够归来？风为我捎来讯息，硝烟在落叶上书信，诉说着远方的战火。想起了你拥我入眠的每个夜晚，你说星星是天使在偷看我们，你用温柔话语回应我的羞涩，而如今窗外只有军队的踏步声，偌大的床褥，却如此的拥挤而寒冷。林克慢慢长大，你离家的时候他还只会牙牙学语，如今已经是个强壮勇敢的男子汉了......” 这样似乎又有点太过华丽了，对于一个只会种地农民和打仗的士兵而言，反而没那么接地气。由此可见，感情是一封信中最重要的东西，怎样更能把写信人的想法全盘托出，又怎样能让读信人完美接收，就需要代写者细细品味两者之间感情的韵味了。\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%发E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre style=\\\"white-space: pre-wrap;\\n  word-wrap: break-word; background: #fafafa; border-top: 5px solid #f56c6c; border-bottom: 5px solid #f56c6c; line-height: 2; font-size: 16px; font-family:仿宋;\\\">\\n    \\t首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n    \\t剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n    \\t我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n    \\t祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '120.208.43.188', '山西省长治市 移动', '2022-07-17 18:55:51', NULL);
INSERT INTO `tb_operation_log` VALUES (1268, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"<font color=red>温馨提示：该文章写于三年前，makrdown、html、css 和 js都还不熟悉，因此文章和格式写的很烂很烂，请抱着死亡的心态阅读下去吧！</font>\\n\\n<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n\\n## <center>简介</center>\\n\\n薇尔莉特是这部剧的女主，是一名在战场上失去双臂，为寻求什么是爱而加入了自动手记人偶这一职业并逐渐成长的故事\\n\\n什么是自动手记人偶呢？在过去，尤其是战争时期，大多数人都未能接受良好的教育，以至于不会写字和识字，因此想要写信时，就需要代写的人帮忙写信，后来逐渐演变成为一种职业，在该剧中被称之为——自动手记人偶。【既然有职业代写人，自然有职业读信人，所以别产生 “寄了信对方看不懂，那怎么办” 的想法了】\\n\\n一种职业的产生和发展必定和“内卷”离不开关系，一开始代写的人只是重述着写信人的话语，但是大多数人来写信都因其抱有着思念之情无处安放，有的是爱人、家人、朋友；有的是国家、家乡；他们的感情浓厚且强烈，而如何把 “老伴儿啊，俺好想你了，你啷个时候能回来啊？娃儿都长高了” 这句话用生动、精彩、美丽又富有感情地表达出来，就显得尤为重要了。\\n\\n如果翻译成 “老公，我想你了，你什么时候能回来？” 好像也不错，但是似乎有点不够生动；如果翻译成 “亲爱的，你现在身在何方？又何时能够归来？风为我捎来讯息，硝烟在落叶上书信，诉说着远方的战火。想起了你拥我入眠的每个夜晚，你说星星是天使在偷看我们，你用温柔话语回应我的羞涩，而如今窗外只有军队的踏步声，偌大的床褥，却如此的拥挤而寒冷。林克慢慢长大，你离家的时候他还只会牙牙学语，如今已经是个强壮勇敢的男子汉了......” 这样似乎又有点太过华丽了，对于一个只会种地农民和打仗的士兵而言，反而没那么接地气。由此可见，感情是一封信中最重要的东西，怎样更能把写信人的想法全盘托出，又怎样能让读信人完美接收，就需要代写者细细品味两者之间感情的韵味了。\\n\\n<center>“只要是客人的愿望，不论天涯海角我们都竭诚为您服务\\n\\n自动笔记人偶薇尔莉特·伊芙加登”</center>\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%发E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre style=\\\"white-space: pre-wrap;\\n  word-wrap: break-word; background: #fafafa; border-top: 5px solid #f56c6c; border-bottom: 5px solid #f56c6c; line-height: 2; font-size: 16px; font-family:仿宋;\\\">\\n    \\t首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n    \\t剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n    \\t我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n    \\t祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '120.208.43.188', '山西省长治市 移动', '2022-07-17 19:01:57', NULL);
INSERT INTO `tb_operation_log` VALUES (1269, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"<font color=red>温馨提示：该文章写于三年前，makrdown、html、css 和 js都还不熟悉，因此文章和格式写的很烂很烂，请抱着死亡的心态阅读下去吧！</font>\\n\\n<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n\\n## <center>简介</center>\\n\\n薇尔莉特是这部剧的女主，是一名在战场上失去双臂，为寻求什么是爱而加入了自动手记人偶这一职业并逐渐成长的故事\\n\\n什么是自动手记人偶呢？在过去，尤其是战争时期，大多数人都未能接受良好的教育，以至于不会写字和识字，因此想要写信时，就需要代写的人帮忙写信，后来逐渐演变成为一种职业，在该剧中被称之为——自动手记人偶。【既然有职业代写人，自然有职业读信人，所以别产生 “寄了信对方看不懂，那怎么办” 的想法了】\\n\\n一种职业的产生和发展必定和“内卷”离不开关系，一开始代写的人只是重述着写信人的话语，但是大多数人来写信都因其抱有着思念之情无处安放，有的是爱人、家人、朋友；有的是国家、家乡；他们的感情浓厚且强烈，而如何把 “老伴儿啊，俺好想你了，你啷个时候能回来啊？娃儿都长高了” 这句话用生动、精彩、美丽又富有感情地表达出来，就显得尤为重要了。\\n\\n如果翻译成 “老公，我想你了，你什么时候能回来？” 好像也不错，但是似乎有点不够生动；如果翻译成 “亲爱的，你现在身在何方？又何时能够归来？风为我捎来讯息，硝烟在落叶上书信，诉说着远方的战火。想起了你拥我入眠的每个夜晚，你说星星是天使在偷看我们，你用温柔话语回应我的羞涩，而如今窗外只有军队的踏步声，偌大的床褥，却如此的拥挤而寒冷。林克慢慢长大，你离家的时候他还只会牙牙学语，如今已经是个强壮勇敢的男子汉了......” 这样似乎又有点太过华丽了，对于一个只会种地农民和打仗的士兵而言，反而没那么接地气。由此可见，感情是一封信中最重要的东西，怎样更能把写信人的想法全盘托出，又怎样能让读信人完美接收，就需要代写者细细品味两者之间感情的韵味了。\\n\\n<center>“只要是客人的愿望，不论天涯海角我们都竭诚为您服务</center>\\n\\n<center>自动笔记人偶薇尔莉特·伊芙加登”</center>\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%发E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre style=\\\"white-space: pre-wrap;\\n  word-wrap: break-word; background: #fafafa; border-top: 5px solid #f56c6c; border-bottom: 5px solid #f56c6c; line-height: 2; font-size: 16px; font-family:仿宋;\\\">\\n    \\t首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n    \\t剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n    \\t我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n    \\t祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '120.208.43.188', '山西省长治市 移动', '2022-07-17 19:02:28', NULL);
INSERT INTO `tb_operation_log` VALUES (1270, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"<font color=red>温馨提示：该文章写于三年前，makrdown、html、css 和 js都还不熟悉，因此文章和格式写的很烂很烂，请抱着死亡的心态阅读下去吧！</font>\\n\\n<iframe frameborder=\\\"no\\\" border=\\\"0\\\" marginwidth=\\\"0\\\" marginheight=\\\"0\\\" width=330 height=86 src=\\\"//music.163.com/outchain/player?type=2&id=534065323&auto=1&height=66\\\"></iframe>\\n\\n## <center>简介</center>\\n\\n薇尔莉特是这部剧的女主，是一名在战场上失去双臂，为寻求什么是爱而加入了自动手记人偶这一职业并逐渐成长的故事\\n\\n什么是自动手记人偶呢？在过去，尤其是战争时期，大多数人都未能接受良好的教育，以至于不会写字和识字，因此想要写信时，就需要代写的人帮忙写信，后来逐渐演变成为一种职业，在该剧中被称之为——自动手记人偶。【既然有职业代写人，自然有职业读信人，所以别产生 “寄了信对方看不懂，那怎么办” 的想法了】\\n\\n一种职业的产生和发展必定和“内卷”离不开关系，一开始代写的人只是重述着写信人的话语，但是大多数人来写信都因其抱有着思念之情无处安放，有的是爱人、家人、朋友；有的是国家、家乡；他们的感情浓厚且强烈，而如何把 “老伴儿啊，俺好想你了，你啷个时候能回来啊？娃儿都长高了” 这句话用生动、精彩、美丽又富有感情地表达出来，就显得尤为重要了。\\n\\n如果翻译成 “老公，我想你了，你什么时候能回来？” 好像也不错，但是似乎有点不够生动；如果翻译成 “亲爱的，你现在身在何方？又何时能够归来？风为我捎来讯息，硝烟在落叶上书信，诉说着远方的战火。想起了你拥我入眠的每个夜晚，你说星星是天使在偷看我们，你用温柔话语回应我的羞涩，而如今窗外只有军队的踏步声，偌大的床褥，却如此的拥挤而寒冷。林克慢慢长大，你离家的时候他还只会牙牙学语，如今已经是个强壮勇敢的男子汉了......” 这样似乎又有点太过华丽了，对于一个只会种的农民和打仗的士兵而言，反而没那么接地气。由此可见，感情是一封信中最重要的东西，怎样更能把写信人的想法全盘托出，又怎样能让读信人完美接收，就需要代写者细细品味两者之间感情的韵味了。\\n\\n<center>“只要是客人的愿望，不论天涯海角我们都竭诚为您服务</center>\\n\\n<center>自动笔记人偶薇尔莉特·伊芙加登”</center>\\n\\n![紫罗兰永恒花园](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD-57b.png)\\n\\n## <center>OP</center>\\n\\n<center>\\n\\n每每学会未知的词语\\n\\n仿佛触及你的追忆\\n\\n但是或许也会有单词\\n\\n只身一人   终究无法理解\\n\\n再见  是苦涩的\\n\\n我爱你   则带着遥远的气息\\n\\n无可比拟的这份情愫\\n\\n让我胆战心惊   却又让我心动不已\\n\\n为什么的眼里噙满泪水\\n\\n该怎么回答我的心灵\\n\\n话语总在嘴边\\n\\n越是说不出口   越是揪人心肠\\n\\n让我想要与你相见\\n\\n</center>\\n\\n![是个结婚的好天气](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%98%AF%E4%B8%AA%E7%BB%93%E5%A9%9A%E5%92%8C%E5%A5%BD%E5%A4%A9%E6%B0%94-d98.png)\\n\\n“对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死”\\n\\n<br />\\n\\n“薇尔莉特，怎么样，你在看吗？”\\n\\n“我在，这是我第一次这么近的看星星”\\n\\n“不是星星，是彗星！”\\n\\n“我们今生今世再也不能与它相见了”\\n<br />\\n\\n“然此非悲恸之别离   逝者当于   久远之妖精之国   得新生   其魂不灭   亘古永存”\\n\\n![薇尔莉特·伊芙加登](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%C2%B7%E4%BC%8A%E8%8A%99%E5%8A%A0%E7%99%BB-109.png)\\n\\n![再会星空之下](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%86%8D%E4%BC%9A%E6%98%9F%E7%A9%BA%E4%B9%8B%E4%B8%8B-3a3.png)\\n\\n“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登”\\n<br />\\n“这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去”\\n![在湖面就踏着落叶飞回去](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%9C%A8%E6%B9%96%E9%9D%A2%E5%B0%B1%E8%B8%8F%E7%9D%80%E8%90%BD%E5%8F%B6%E9%A3%9E%E5%9B%9E%E5%8E%BB-ea7.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BB%9D%E7%BE%8E-e28.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%9C%80%E7%BE%8E%E7%9A%84%E7%9C%BC%E7%9D%9B-e00.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%发E6%81%92%E8%8A%B1%E5%9B%AD/%E6%B4%8B%E5%A8%83%E5%A8%83-3b8.png)\\n\\n## <center>剧场版-终</center>\\n\\n<pre style=\\\"white-space: pre-wrap;\\n  word-wrap: break-word; background: #fafafa; border-top: 5px solid #f56c6c; border-bottom: 5px solid #f56c6c; line-height: 2; font-size: 16px; font-family:仿宋;\\\">\\n    \\t首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。\\n    \\t剧场版或者说终章的剧情相比较TV是有很大进步的，大概7->8.5分这样的进步，加上9.9999分的画风和9.9999分的音乐，9.5分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。\\n    \\t我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人猝不及防；如草木般倔强，让人向死而生。\\n    \\t祝愿世界上每一个生物都有能有配偶:-D\\n</pre>\\n\\n\\n自己截下来的一些图片：\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%93%E5%AD%97%E6%9C%BA-44d.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E6%89%8B-871.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%93%AD-cdd.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E6%B5%B7%E5%B0%91%E6%A0%A1-a53.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E9%82%AE%E7%A5%A8-885.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E5%AF%84%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0-56b.png)\\n\\n![](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/%E7%AC%94%E8%AE%B0/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/%E7%BA%A6%E5%AE%9A-4ca.png)\\n\\n\",\"articleCover\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/articles/fe33cba301dccbc79f526f7ae3a233e4.png\",\"articleTitle\":\"紫罗兰永恒花园\",\"categoryName\":\"动漫和电影分享\",\"id\":72,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '120.208.43.188', '山西省长治市 移动', '2022-07-17 19:05:25', NULL);
INSERT INTO `tb_operation_log` VALUES (1271, '相册模块', '新增或修改', '/admin/photos/albums', 'com.minzheng.blog.controller.PhotoAlbumController.saveOrUpdatePhotoAlbum', '保存或更新相册', '[{\"albumCover\":\"http://www.static.lxuan.fun/photos/bff5516b0f78dc8af0582b60872d324a.jpg\",\"albumDesc\":\"qwe\",\"albumName\":\"qwe\",\"status\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '152.69.196.109', '美国', '2022-10-11 16:18:54', NULL);
INSERT INTO `tb_operation_log` VALUES (1272, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 📙Java基础\\n\\n## 1. 类与对象\\n\\n![对象在内存中的存在形式](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%9C%A8%E5%BD%A2%E5%BC%8F-cd2.jpg)\\n\\n\\n\\n### 1.1 作用域\\n\\n|  作用域   | 当前类 | 同一包 | 子类 | 不同包 |\\n| :-------: | :----: | :----: | :--: | :----: |\\n|  public   |   √    |   √    |  √   |   √    |\\n| protected |   √    |   √    |  √   |   x    |\\n|  default  |   √    |   √    |  x   |   x    |\\n|  private  |   √    |   x    |  x   |   x    |\\n\\n全局变量（属性）可以不赋值，直接使用，因为有默认值，局部变量必须赋值后才能使用，因为没有默认值。\\n\\n1. 属性和局部变量可以重名，访问时遵循就近原则。\\n2. 同一个作用域中，两个局部变量不能重名。\\n3. 全局变量可以加修饰符，局部变量不行。\\n\\n### 1.2 构造器\\n\\n  构造方法又叫构造器（constructor），是类的一种特殊方法，它的主要作用是完成对<u>*新对象的初始化*</u>。\\n\\n1. 构造器修饰符可以默认，也可以是public protected private\\n\\n2. <u>构造器没有返回值</u>\\n\\n3. <u>方法名和类名必须一样</u>\\n\\n4. 参数列表和成员方法一样的规则\\n\\n5. 构造器的调用，由系统完成\\n\\n6. <u>构造器可以重载</u>\\n\\n   new 一个新对象的时候，会自动执行构造器，因此new时可以直接赋值，如：\\n\\n   Person p1 = new Person (\\\"梁渲\\\"， 20);\\n\\n### 1.3 this关键字\\n\\nthis(参数列表)只能在构造器中使用，也就是在一个构造器中访问另一个构造器，必须放在第一条语句，即同一给构造器中只能出现一次\\n\\n### 1.4 对象可以为空，也就是说返回值可以为null\\n\\n### 1.5 数组可以为空\\n\\n### 1.6 方法中的变量称为局部变量，之外的变量称为全局变量，this.是全局变量\\n\\n### 1.7 一个Java源文件中可以有多个主类，但是只能有一个公共类或者没有公共类\\n\\njava源文件在运行后会被编译成一个个class文件，但public类只能有一个，而主类main()方法可以有多个，main()方法是程序执行的入口\\n\\n## 2. 包\\n\\n作用：\\n\\n1. 区分相同名字的类\\n2. 当类很多时，可以很好的管理类[看Java API 文档]\\n3. 控制访问范围\\n\\n---\\n\\n\\n\\n## 3. 继承\\n\\n1. 如果子类有这个属性，则输出，如果子类没有这个属性，则依次往上找父类的属性。\\n\\n2. 私有属性不能直接在子类中访问，需要用父类提供的公共方法去访问，如下。\\n\\n   ```java\\n   class A {\\n     private name = \\\"张三\\\";\\n     \\n     public String getName () {\\n       return name;\\n     }\\n   }\\n   class B extends A {\\n     \\n   }\\n   main{\\n     B b1 = new B;\\n     System.out.print(b1.name); // 报错\\n     System.out.print(b1.getName); // 返回张三\\n   }\\n   ```\\n\\n3. 子类的任何方法的第一行都存在一个 super() 方法，该方法用于执行父类的无参构造器；但 this(); 和 super() 不能共存，若是子类的构造器中存在 this(); 方法，则super(); 也就不会存在了。\\n\\n---\\n\\n## 4. 多态\\n\\n1. 一个对象的编译类型和运行类型可以不一致\\n2. 编译类型在定义对象时，就确定了，不能改变\\n3. 运行类型是可以变化的\\n4. 编译类型是看定义时 = 的左边，运行类型看 = 右边\\n\\n### 4.1 Java的动态绑定机制\\n\\n1. 当调用对象方法的时候，该方法会和该对象的**内存地址/运行类型**绑定\\n2. 当调用对象的属性时，没有动态绑定机制，哪里声明就在哪里使用\\n\\n\\n\\n## 5 == 和 equals\\n\\n1. == 是一个比较运算符\\n\\n   1. 既可以判断基本类型，又可以判断引用类型\\n   2. 如果判断基本类型，判断的是值是否相等。\\n   3. 如果判断引用类型，判断的是地址是否相同，即判断是否是同一个对象。\\n\\n   **<font color = \\\"red\\\">如果 == 两边一个是基本类型，一个是引用类型，则只要存在基本类型就是判断两边的值是否相等</font>**\\n\\n2. equal 是 Object 类中的方法，只能判断引用类型，默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等\\n\\n   **<font color = \\\"red\\\">字符串对象的比较不能使用 == ，而应该使用 String 类的 equals 方法</font>**\\n\\n| 名称  | 概念                             | 用于基本数据类型     | 用于引用类型                                                 |\\n| ----- | -------------------------------- | :------------------- | ------------------------------------------------------------ |\\n| ==    | 比较运算符                       | 可以，判断值是否相等 | 可以，判断两个对象是否相等                                   |\\n| equal         | object类的方法，Java类都可以使用 | 不可以               | 可以，默认是判断两个对象是否相等，但是子类往往重写该方法，比较对象的属性是否相等，比如（String,Integer) |\\n\\n## 6. javap 反编译\\n\\n![javap](assets/Java/javap.md)\\n\\n## 7. 三目运算符\\n\\n```java\\npublic static void main(String[] args) {\\n  Object obj1 = true ? new Integer(1) : new Double(2.0);\\n  System.out.println(obj1);\\n}\\n//输出结果：1.0\\n```\\n\\n1. 三目运算符只能使用基本数据类型，所以编译自动拆箱为 int、double\\n2. 三目运算符是一个整体，要求数据类型一致，所以编译 int 自动提升为精度更高的 double\\n\\n## 8. Java 中只有值传递，没有引用传递\\n\\n这里涉及到值传递和引用传递两种传递机制：\\n\\n1. **值传递(pass by value)：** 是指在调用方法(或者函数)时，将实际参数复制一份传递到方法(或者函数)中，这样在函数中如果对形式参数进行修改，将不会影响到实参。\\n\\n2. **引用传递(pass by reference)：** 在调用方法(函数)时，将实参的地址直接传递到函数中，那么在函数中对形参进行修改，将影响到实参。\\n\\n**<font color = \\\"red\\\">Java 中只有值传递，始终是传值的。参数是基本数据类型，复制的是具体值；如果参数是引用类型，把地址当成值，复制的是地址；还有String类是一个非常特殊的类，它是不可变的。</font>**\\n\\n## 9. equals 和 hashCode\\n\\n**<font color = \\\"red\\\">equals 相等 hashCode 一定相等，hashCode 相等 equals不一定相等</font>**\\n\\n---\",\"articleCover\":\"\",\"articleTitle\":\"Java 基础\",\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '152.69.196.109', '美国', '2022-10-11 19:25:09', NULL);
INSERT INTO `tb_operation_log` VALUES (1273, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 📙Java中级\\n\\n## 🖇️原生的equals和hashCode方法。\\n\\n1. **[equals](https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020)**\\n\\n   Object 中的 equals 方法和 == 是相同的，如下代码，比较的都是内存地址。\\n\\n   ```java\\n    public boolean equals(Object obj) {\\n      return (this == obj);\\n   }\\n   ```\\n\\n2. **hashCode**\\n\\n    原生的hashCode方法返回的是一个根据内存地址换算出来的一个值。它的定义是这样的：\\n\\n   ```java\\n   public native int hashCode();\\n   ```\\n\\n   可见这是一个 native 方法，因为 native 方法是并不是由 Java 语言来实现的，所以这个方法的定义中也没有具体的实现。根据 jdk 文档，该方法的实现一般是**“通过将该对象的内部地址转换成一个整数来实现的”**，这个返回值就作为该对象的哈希码值返回。\\n\\n3. **总结**\\n\\n    所以，在不重写equals和hashCode的情况下：\\n\\n   （1）两个对象如果equals相等的情况下，hashCode一定相等。因为equals默认是用“==”来比较，比较的是内存地址，而hashCode是根据内存地址得到哈希值，内存地址一样的话，得到的哈希值肯定是一样的。\\n\\n   （2）两个对象hashCode相等的情况下，equals不一定相等。这是为什么呢，首先我们来说一下哈希表，哈希表结合了直接寻址和链式寻址两个方式，简单来说就是先计算出要插入的数据的哈希值，然后插入到相应的分组当中去，因为哈希函数返回的是一个int类型，所以最多也就只有2的32次方个分组，对象多了，总有分组不够用的时候，这个时候，不同的对象就会产生相同的哈希值，也就是哈希冲突现象，此时就可以通过链地址法把分组用链表来代替，同一个链表上的对象hashCode肯定是相等的，因为是不同的对象，所以内存地址不同，所以他们的equals肯定是不相等的。这的hashCode就相当于是人名，equals就相当于身份证号，同名的人多了去了，但都不是同一个人。\\n\\n---\\n\\n## 🖇️ 类变量和类方法\\n\\n### 1. 类变量\\n\\n类变量也叫静态变量，被 static 修饰的变量会被所有对象实例共享。\\n\\n```java\\npublic static int count = 0;\\n```\\n\\n在jdk8以前，静态变量是放在方法区里的静态域，jdk8以后静态变量是放在堆里的，保存在class实例的尾部。\\n\\n---\\n\\n1. static被所有对象共享，任何一个对象访问的都是同一个值，修改的也是同一个变量。\\n\\n2. static类变量，在类加载的时候就生成了，所以即使没有对象实例也可以访问，如：\\n\\n   ```java\\n   System.out.println(类名.静态变量);\\n   ```\\n\\n   \\n\\n### 2. 类方法\\n\\n类方法与类变量同理\\n\\n我们在调用 Java 中的 Math 工具时，从来都不需要创建一个 Math 对象，就是因为 Math 类中的方法都是静态方法。\\n\\n因此我们可以将静态方法作为一种工具方法，放在工具类中随时调用。\\n\\n---\\n\\n1. 类方法中不允许使用和对象有关的关键字，比如 this 和 super ，普通方法可以。\\n2. 类方法中**只能访问类变量和类方法**，普通方法都可以访问。\\n\\n### 3. 理解 main 方法语法\\n\\n解释 main 方法的形式：\\n\\n```java\\npublic static vod main(String[] ages){}\\n```\\n\\n1. main 方法是虚拟机调用\\n\\n2. Java虚拟机西药调用类的 main() 方法，所以该方法的访问权限必须是public\\n\\n3. java虚拟机在执行 main() 方法时不必创建对象，所以该方法必须是 static \\n\\n4. 该方法接收 String 类型的数组参数，该数组中保存执行 java 命令时传递给所运行的类的参数\\n\\n5. java 源文件执行的方式：java 类名.java 参数1 参数2 参数3\\n\\n   ```java\\n   java hello.java qwe asd zxc\\n   ```\\n\\n\\n\\n## 🖇️代码块\\n\\n1. 代码块主要解决构造器中重复出现的语句。\\n2. 代码块调用的顺序优先于构造器。\\n3. 静态代码块只能调用静态属性和静态方法\\n4. 普通代码块都能调用\\n\\nstatic 代码块也叫静态代码块，作用就是对类进行初始化，伴随着类的加载而执行，且**只会执行一次**\\n\\n类什么时候被加载？\\n\\n* 创建对象实例（new）的时候\\n* 创建子类对象实例，父类也会被加载\\n* 实用类的静态成员时（类方法，类属性）\\n\\n普通代码块每创建一次就执行一次\\n\\n\\n\\n## 🖇️单例设计模式\\n\\n一个类只能同时存在一个实例（对象）\\n\\n1. 饿汉式\\n   1. 构造器私有化\\n   2. 类的内部创建实例（对象）\\n   3. 创建一个公共的 static 方法，返回该实例（对象）\\n2. 懒汉式\\n   1. （与上相同）\\n   2. 与饿汉式不同的是，懒汉式在用户不调用的时候不会加载对象\\n\\n\\n\\n## 🖇️final 关键字\\n\\n1. 定义：\\n\\n   final 修饰的属性又叫**常量**，一般用大写来命名\\n\\n2. 使用 final 的注意事项\\n   1. final 修饰类的时候，**<font color=\\\"red\\\">类不能被继承</font>**\\n   2. final 修饰方法的时候，父类的方法不能被子类**重写/覆盖**（override）\\n   3. final 修饰属性值的时候，**属性值不能被修改**\\n   4. final 修饰的属性在定义时必须赋值，之后就不能再修改（赋值位置：定义时、代码块中、构造器中）。如果 final 修饰的属性是静态的，则初始化位置只能是在定义时，代码块中（不能在构造器中）\\n   5. 虽然被 final 修饰的方法不能被重写，但是可以被继承和使用\\n   6. 如果一个类已经被 final 修饰，那类中的方法就不用 final 修饰了\\n   7. final 不能被修饰构造器\\n   8. final 和 static 搭配使用效率更高，底层代码做了优化（使用 static 会加载整个类，但是加上 final 就不会加载整个类了）\\n\\n\\n\\n## 🖇️ 抽象类\\n\\n1. 抽象类不一定要抽象方法，抽象方法必须为抽象类\\n\\n2. 抽象类不能被实例化\\n\\n3.  abstract 只能修饰类和方法，不能修饰属性和其他\\n\\n4. 如果一个类继承了抽=抽象类，则它必须实现抽象类中的所有方法，除非它自己也声明为抽象类\\n\\n5. 抽象方法不能使用 private、static 和  final 来修饰，因为这些修饰词都和重写相违背\\n\\n   > static：\\n   >\\n   > 被 static修饰的方法在和没有 static 修饰的方法在内存中的位置不一样。。\\n   > 被static修饰的方法属于类，是类自己的东西，不是给子类来继承的。就好像类是个房子，它的静态方法是里面的一面墙，每个人都可已在墙上画画，你画的东西别人也能看到，属于大家共同使用。你想通过继承来把这面墙拿走也不可能拿走，他是从属于类的。\\n   > 而抽象方法本身没有实现，就是用来给子类继承，存在内存中的位置也不是一样的。用 static修饰就不能被子类继承了。同样 你可以这么理解。\\n   > 抽象方法相当于房子中地上的白纸，继承了它的子类就必须从地上拿一张白纸回去画画，你想怎么画怎么画。\\n   > 一个相当于墙，你是拿不走的。一个相当于地上的纸，而且规定你实现了就必须拿走。\\n   >\\n   > final：\\n   >\\n   > final修饰的类不可继承，而抽象类本事是不能被实例化的，是需要让子类去继承，如果父类使用了 final 修饰符修饰方法，子类继承后，也无法重写该方法。\\n   >\\n   > private：\\n   >\\n   > private的访问权限是本类中，子类继承父类后，是无法方法 private 修饰的方法的。\\n\\n访问修饰符 abstract 类名{}\\n\\n\\n\\n## 🖇️模板设计模式\\n\\n1. 共同代码模板，不同代码抽象\\n\\n\\n\\n## 🖇️接口\\n\\n1. jdk8之前，在接口中，抽象方法可以省略 abstract 关键字，也就是说所有方法都是抽象方法，都不能有方法体\\n\\n2. jdk8后，接口中可以有默认方法，但是需要用 default 关键字修饰\\n\\n   ```java\\n   public default void AA(){}\\n   ```\\n\\n3. 也可以有静态方法\\n\\n   ```java\\n   public static void BB(){}\\n   ```\\n\\n4. 一个类可以实现多个接口\\n\\n   ```java\\n   class AA implements BB,CC,DD{}\\n   ```\\n\\n5. 接口中的属性只能是 final 的，而且是 public static final 修饰符\\n\\n6. 接口不能继承其它类，但是可以继承其它接口\\n\\n7. 接口的修饰符只能是 public 或者默认的，这点和类的修饰符是一样的\\n\\n### 1. 接口和继承\\n\\n1. 接口和继承解决的问题不同\\n\\n   接口的价值主要在于：设计、规定好各种方法，让其它类能够实现这些方法（功能）\\n\\n   继承的价值主要在于：解决代码的**复用性**和**可维护性**\\n\\n2. 接口比继承更加灵活\\n\\n   继承是满足 is - a 的关系\\n\\n   接口只需满足 like - a 的关系\\n\\n3. 接口在一定程度上实现代码解耦\\n\\n---\\n\\n## 🖇️四种内部类\\n\\n 类的五大成员：属性、方法、构造器、代码块、内部类\\n\\n内部类的最大特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系\\n\\n***定义在外部类局部位置上（比如方法内）:***\\n\\n### 1. 局部内部类（有类名）\\n\\n1. 定义在方法中 / 代码块中\\n2. 可以直接访问定义在外部类的所有成员（属性和方法），包含私有的\\n3. 不能添加访问修饰符，但是可以私用 final 修饰，被 final 修饰后就可以不被继承\\n4. 作用域：仅仅在定义它的方法或代码块中\\n5. 如果外部类和局部内部类的成员重名时，遵守就近原则。在此基础上访问外部成员可以使用 **`外部类名.this.成员`** 去访问，因为 **`外部类名.this`** 的意思就是访问创建了局部内部类这个方法的对象。\\n\\n### 2. 匿名内部类（没有类名）<font color = \\\"red\\\">重点！！</font>\\n\\n1. 定义在方法中 / 代码块中，并且没有类名\\n\\n2. 使用如下：\\n\\n   ```java\\n   AA aa = new AA(\\\"name\\\"){\\n     @Override\\n     public void A(){\\n     \\t....\\n     }\\n   };\\n   aa.A();\\n   \\n   或者\\n   \\n   new AA(){\\n     @Override\\n     public void B(){\\n     \\t...\\n     }\\n   }.B();\\n   ```\\n\\n   匿名内部类没有类名，(\\\"name\\\")这个形参列表是传给类的构造器的，当然也可以重写构造器。\\n\\n3. 可以访问外部类的所有成员，包含私有\\n\\n4. 不能添加访问修饰符，因为他的地位就是一个局部变量\\n\\n5. 作用域：定义它的方法或者代码块中\\n\\n***定义在外部类的成员位置上：***\\n\\n### 3. 成员内部类（没用 static 修饰）\\n\\n1. 直接定义在外部类的成员位置，而不在方法或代码块中，并且没有 static 修饰\\n2. 可以直接访问外部类的所有成员，包括私有\\n3. 可以添加任意访问修饰符（public、protected、默认、private），因为它本身就是一个成员\\n4. 使用如下：\\n\\n    ```java\\n    第一种方式\\n    main{\\n      Outside outside = new Outside();\\n      Outdise.memberInsideClass memberinsideclass = outside.new memberInsideClass();\\n    }\\n    \\n    第二种方式\\n    main{\\n      Outside.MemberInsideClass menberInsideClass = new Outside().getMenberInsideClass();\\n      memberInsideClass.方法();\\n    }\\n    Outside{\\n      public MemberInsideClass getMenberInsideClass() {\\n        return new MemberInsideClass();\\n      }\\n    }  \\n    ```\\n\\n### 4. 静态内部类（使用 static 修饰）\\n\\n1. 成员内部类添加 static 修饰符\\n2. 可以访问外部类所有静态成员，但不能访问非静态\\n3. 可以添加任意访问修饰符（public、protected、默认、private），因为它本身就是一个成员\\n\\n---\\n\\n## 🖇️枚举和注解 - annotate\\n\\n### 1 自定义枚举类\\n\\n1. 构造器**私有化**：防止被直接 new\\n2. 去掉 set 方法：防止属性被修改\\n3. 在外部类直接创建固定的对象 `public static final 类名 对象名 = new 类名();`\\n\\n### 2. Enum 修饰的枚举类\\n\\n1. 使用 enum 关键字 替代 class，默认继承 Enum 类，而且是一个 final 类\\n2. 将 `public static final 类名 对象名 = new 类名();` 简化成 `对象名();` 形式\\n3. 如果有多个对象使用，使用**逗号**间隔，最后有一个**分号**结尾，如： `SPRING(\\\"春天\\\",\\\"温暖\\\"),WINTER(\\\"冬天\\\",\\\"寒冷\\\");`\\n4. 枚举对象必须放在枚举类的行首\\n5. 如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略\\n\\n#### 2.1 Enum 方法\\n\\n1. 返回该枚举对象的对象名\\n\\n   ```java\\n   name()\\n   ```\\n\\n2. 返回该枚举对象的次序\\n\\n   ```java\\n   ordinal()\\n   ```\\n\\n3. 返回当前枚举类中的所有常量\\n\\n   ```java\\n   values()\\n   ```\\n\\n4. 将字符串转换为枚举对象，要求字符串必须为已有常量名\\n\\n   ```java\\n   valueOf()\\n   ```\\n\\n5. 比较两个枚举常量，比较的是 `ordinal()`\\n\\n   ```java\\n   compareTo()\\n   ```\\n\\n\\n#### 2.2 Enum 实现接口\\n\\n1. 使用 enum 关键字后，就不能继承其他类了，因为已经继承了 enum 类，而 java 是单继承机制。\\n2. 但是可以实现接口\\n\\n### 3. 注解\\n\\n1. 注解也被称之为元数据，用于修饰解释（包、类、方法、属性、构造器、局部变量）等数据信息\\n2. 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息\\n3. @Target 是修饰注解的注解，称为元注解\\n\\n#### 3.1 三个基本的 Annotation：\\n\\n1. @Override：限定某个方法，是重写父类方法\\n2. @Deprecated：用于表示某个程序元素（类，方法）已过时\\n3. @SuppressWarnings：抑制编辑器警告\\n\\n#### 3.2 常用的注解\\n\\n1. **@Data** ： 注在类上，提供类的get、set、equals、hashCode、canEqual、toString方法\\n2. **@AllArgsConstructor** ： 注在类上，提供类的**全参构造**\\n3. **@NoArgsConstructor** ： 注在类上，提供类的无参构造\\n4. @Setter ： 注在属性上，提供 set 方法\\n5. @Getter ： 注在属性上，提供 get 方法\\n6. @EqualsAndHashCode ： 注在类上，提供对应的 equals 和 hashCode 方法\\n7. @Log4j/@Slf4j ： 注在类上，提供对的 Logger 对象，变量名为 log\\n\\n---\\n\\n## 🖇️异常 - Exception\\n\\n### 1. 异常的概念\\n\\n```java\\nint a = 10;\\nint b = 0;\\nint c = a / b;\\n```\\n\\n如上代码，如果执行到第三行程序就会报错（ArithmeticException），导致整个程序的中断，这显然是不合理的，所以需要**异常处理机制**来解决该问题，如下。\\n\\n```java\\ntry{\\n  int c = num1 /num2;\\n}catch (Exception e){\\n  e.printStackTrace();\\n}\\n```\\n\\n**程序执行过程中所发生的异常事件可分为两大类：**\\n\\n1. Error（错误）：Java 虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError[栈溢出] 和 OOM(out of memory)，Error是严重错误，程序会崩溃\\n2. Exceptio：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等，Exception分为两大类：**运行时异常**和**编译时异常**。（如上述例子 ArithmeticException 就属于运行时异常，写代码时编译器不会报错）\\n\\n### 2. 常见的异常\\n\\n1. NullPointerException：空指针异常\\n2. ArithmeticException：数学运算异常\\n3. ArrayIndexOutOfBoundsException：数组下标越界异常\\n4. ClassCastException：类型转换异常\\n5. NumberFormatException：数字格式不正确异常\\n\\n### 3. 异常处理❗\\n\\n#### 3.1 异常处理方式\\n\\n1. **try-catch-finally**：程序员在代码中捕获发生的异常，自行处理\\n\\n   ```java\\n   try {\\n     //代码可能有异常\\n   } catch (Exception e) {\\n     // 捕获到异常\\n     // 1. 当异常发生时\\n     // 2. 系统将异常封装成Exception对象e, 传递给catch\\n     // 3 得到异常对象后，程序员，自己处理\\n     // 4 注意，如果没有发生异常catch代码块不执行\\n   } finally {\\n     // 1. 不管try代码块是否有异常发生，始终要执行finally\\n     // 2. 所以，通常将释放资源的代码，放在finally\\n   }\\n   ```\\n\\n   可以有**多个 catch 语句**，捕获不同的异常（进行不同的业务处理），要求**父类异常在后，子类异常在前。**比如（Exception 在后，NullPointerException 在前），如果发生异常，只会匹配前面的 catch，如下。\\n\\n   ```java\\n   try {\\n     //代码\\n   } catch (NullPointerException e) {\\n   } catch (Exception e) {\\n   } finally {\\n   }\\n   ```\\n\\n   也可以只使用 **try-finally**，相当于没有捕获异常，无论是否发生异常 finally 都要执行，**catch 即使是return，执行完成后也不会返回，而是执行 finally 后再返回**\\n\\n   ```java\\n   try {\\n     //代码\\n   } finally { //总是执行\\n     //代码\\n   }\\n   ```\\n\\n   **<font color = \\\"red\\\">注意：如果 catch 中有 return，finally 没有 return，则将 catch 的返回值保存在临时变量中，并不会受到 finally 的影响</font>**\\n\\n2. **throws**：将发生的异常抛出，交给调查者（方法）来处理，最顶级的处理者就是JVM\\n\\n   ![[assets/Java/throws机制处理图.png]]\\n\\n   如下代码，将错误抛给 Exception 处理，或者也可以用一个异常列表代替 `FileNotFoundException,NullPointerException,ArithmeticException`\\n\\n   ```java\\n   public void f1() throws Exception{\\n     FileInputStream fis = new FileInputStream(\\\"d://a.txt\\\");\\n   }\\n   ```\\n\\n\\n**<font color = \\\"red\\\">注意：</font>**\\n\\n**<font color = \\\"red\\\">1. 对于编译时异常，程序必须处理，比如：try-catch 和 throws </font>**\\n\\n**<font color = \\\"red\\\">2. 对于运行时异常，程序中如果没有处理，默认就是 throws </font>**\\n\\n**<font color = \\\"red\\\">3. 子类重写父类方法时，对抛出的异常有所规定：子类重写的方法，抛出的异常要么和父类保持一致，要么为父类抛出异常的子类型 </font>**\\n\\n**<font color = \\\"red\\\">4. 如果有 try-catch 就不用 throws </font>**\\n\\n### 4. 自定义异常\\n\\n自定义异常的步骤：\\n\\n1. 定义类：自定义异常类名（程序员自己写）继承 Exception 或 RuntimeException\\n\\n2. 如果继承 Exception，属于编译异常\\n\\n3. 如果继承 RuntimeException，属于运行异常（一般来说，继承 RuntimeException)\\n\\n```java\\n//自定义异常\\nclass xxxException extends RuntimeException {\\n    public xxxException(String message) { //构造器\\n        super(message);\\n    }\\n}\\n//使用\\npublic class Exception_ {\\n    public static void main(String[] args) {\\n        throw new xxxException(\\\"发生异常\\\");\\n    }\\n}\\n```\\n\\n**<font color = \\\"red\\\">一般情况下，我们自定义异常是继承 RuntimeException。也就是把自定义异常做成运行时异常，可以使用默认的处理机制，比较方便 </font>**\\n\\n### 5. throw 和 throws 的对比\\n\\n|        | 意义                     | 位置       | 后面跟的的东西 |\\n| ------ | ------------------------ | ---------- | -------------- |\\n| throws | 异常处理的一种方式       | 方法声明处 | 异常类型       |\\n| throw  | 手动生成异常对象的关键字 | 方法体中   | 异常对象       |\\n\\n### 6. 异常体系图❗\\n\\n![异常体系图](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE-69c.png)\\n\\n---\\n\\n## 🖇️包装类（Wrapper）\\n\\n### 1. 包装类的分类\\n\\n1. 针对八种基本数据类型相应的引用类型一包装类\\n2. **有了类的特点，就可以调用类中的方法**\\n\\n| 基本数据类型 |   包装类    |\\n| :----------: | :---------: |\\n|   boolean    |   Boolean   |\\n|     char     |  Character  |\\n|     byte     |  ==Byte==   |\\n|    short     |  ==Short==  |\\n|     int      | ==Integer== |\\n|     long     |  ==Long==   |\\n|    float     |  ==Float==  |\\n|    double    | ==Double==  |\\n\\n其中标记的六个包装类的父类是 Number（继承 Object），而 Boolean 和 Character 则直接继承 Object\\n\\n```java\\nInteger i = 200;\\nInteger i2 = 200;\\ni==i2 //false，不同对象\\n  \\nInteger i = 20;\\nInteger i2 = 20;\\ni==i2 //true，-128~127不会生成对象\\n```\\n\\n### 2. 包装类和基本数据类型的转换\\n\\n```java\\n//jdk5 之前的转换方式\\nint a = 0;\\nInteger integer = Integer.valueOf(a);\\nint b = integer.intValue();\\n\\n//jdk5 之后的转换方式\\nint a1 = 0;\\nInteger integer1 = a1;\\nint b1 = integer1;\\n```\\n\\n**<font color = \\\"red\\\">其本质也是 jdk5 之前的方式，只不过简化了而已</font>**\\n\\n#### 2.1 包装类和 String 类型的相互转换\\n\\n1. 包装类（Integer） -> String\\n\\n   ```java\\n   //包装类（Integer） -> String\\n   Integer a = 100;\\n   //方式一\\n   String str1 = a + \\\"\\\";\\n   //方式二\\n   String str2 = a.toString();\\n   //方式三\\n   String str3 = String.valueOf(a);\\n\\n2. String -> 包装类（Integer）\\n\\n   ```java\\n   //String -> 包装类（Integer）\\n   String str4 = \\\"123\\\";\\n   //方法一\\n   Integer a1 = Integer.parseInt(str4); //自动装箱\\n   //方法二\\n   Integer a2 = new Integer(str4); //构造器\\n\\n### 3. 包装类方法\\n\\n```java\\nSystem.out.printIn(Integer.MIN_VALUE);//返回最小值\\nSystem.out.println(Integer.MAX_VALUI);//返回最大值\\n  \\nSystem.out.println(Character.isDigit(\'a\'));//判断是不是数字\\nSystem.out.println(Character.isLetter(\'a\'));//判断是不是字母\\nSystem.out.printIn(Character.isUpperCase(\'a\'));//判断是不是大写\\nSystem.out.println(Character.isLowerCase(\'a\'));//判断是不是小写\\n                   \\nSystem.out.println(Character.isWhitespace(\'a\'));//判断是不是空格\\nSystem.out.println(Character.toUpperCase(\'a\'));//转成大写\\nSystem.out.println(Character.toLowerCase(\'A\'));//转成小写\\n```\\n\\n### 4. int[] 和 Integer[] 的转换\\n\\n```java\\n//int数组转Integer数组\\nInteger newNums[] = Arrays.stream(nums).boxed().toArray(Integer[]::new);\\n//Integer数组转int数组\\nint[] num = Arrays.stream(newNums).mapToInt(Integer::valueOf).toArray();\\n```\\n\\n\\n\\n---\\n\\n## 🖇️String 类\\n\\n1. String对象用于保存字符串，也就是一组字符序列\\n\\n2. 字符串常量对象是用双引号括起的字符序列。例如：\\\"你好\\\"、\\\"1297\\\"、\\\"boy\\\" 等\\n\\n3. 字符串的字符使用 Unicode 字符编码，一个字符（不区分字母还是汉字）占两个字节。\\n\\n   ==char 占两个字节==\\n\\n4. String 有属性 private final char[] **value**; 用于存放字符串内容，==其地址不可修改==\\n\\n5. String 类实现了接口  Serializable（String 可以串行化：可以在网络传输）\\n\\n6. String 类实现了接口  Comparable（String 对象可以比较大小）\\n\\n### 1. 两种创建 String 对象的区别\\n\\n1. 方式一：直接赋值 String a = \\\"a\\\";\\n\\n   先从常量池查看是否有 \\\"a\\\" 数据空间，如果有，直接指向；\\n\\n   如果没有则重新创建，然后指向；\\n\\n   a 最终指向的是常量池的空间地址\\n\\n2. 方式二：调用构造器 String b = new String(\\\"b\\\");\\n\\n   先在堆中创建空间，里面维护了 value 属性，指向常量池的 \\\"b\\\" 空间；\\n\\n   如果常量池没有 \\\"b\\\"，重新创建；\\n\\n   如果有，直接通过value指向。最终指向的是堆中的空间地址\\n\\n画出两种方式的内存分布图\\n\\n![String 内存分布图](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/String%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%9B%BE-4ad.png)\\n\\n### 2. String 对象特性❗\\n\\n1. String 是一个 final 类，代表不可变的字符序列\\n\\n   ```java\\n   // 以下语句创建了几个对象\\n   String s1 = \\\"hello\\\";\\n   s1 = \\\"haha\\\";\\n   // 答：两个\\n   ```\\n\\n   **<font color = \\\"red\\\">一个字符串一旦被分配，其内容是不可变的，只能重新创建一个新的字符串，赋一个新的地址</font>**\\n\\n   ---\\n\\n   ```java\\n   // 以下语句创建了几个对象\\n   String s2 = \\\"hello\\\" + \\\"abc\\\";\\n   // 答：一个\\n   // 优化等价于 String s2 = \\\"helloabc\\\";\\n   ```\\n\\n   ---\\n\\n   ```java\\n   // 以下语句创建了几个对象\\n   String a=\\\"hello\\\";\\n   String b=\\\"abc\\\";\\n   String c=a+b;\\n   // 答：三个\\n   // 1. 先创建一个 StringBuilder sb = StringBuilder()\\n   // 2. 执行sb.append(\\\"hello\\\"); \\n   // 3. sb.append(\\\"abc\\\");\\n   // 4. String c=sb.tostring()\\n   // 最后其实c是指向堆中的对象(String)value[] -> 池中 \\\"helloabc\\\"\\n   ```\\n\\n2. String 中的 == 和 equals\\n\\n   == 是用来判断地址是否相同\\n\\n   equals 的父类是 Object，在 String 中重写，用于判断字符串内容是否相等\\n\\n3. String 类常见方法\\n\\n   ```java\\n   equals //区分大小写，判断内容是否相等\\n   equalslgnoreCase //忽略大小写的判断内容是否相等\\n   length //获取字符的个数，字符串的长度\\n   indexOf //获取字符在字符串中第1次出现的索引，索引从0开始，如果找不到，返回-1\\n   lastIndexOf //获取字符在字符串中最后1次出现的索引，索引从0开始，如找不到，返回-1\\n   substring //截取指定范围的子串\\n   trim //去前后空格\\n   charAt //获取某索引处的字符，注意不能使用Str[index]这种方式\\n   replaceall //替换某处子字符串，可以使用正则表达式\\n   matches //验证子字符串是否按照某种要求，使用正则表达式\\n   split //分割字符串，\\n   ```\\n\\n### 3. StringBuffer❗\\n\\n1. 代表可变的字符序列，可以对字符串内容进行增删\\n2. StringBuffer是可变长度的。\\n\\n**<font color=\\\"red\\\">StringBuffer 比 String 效率更高</font>**\\n\\n### 4. StringBuilder❗\\n\\n1. 一个可变的字符序列，但不保证同步（**<font color=\\\"red\\\">不是线程安全</font>**），**用在字符串缓冲区被单个线程使用的时候**，在大多数实现中，它比 StringBuffer 要快\\n2. 在 StringBuilder 上的主要操作是 append 和 insert 方法，可重载这些方法以接受任意类型的数据。\\n\\n```java\\n//String可以通过append()方法转换成StringBuilder或StringBuffer类型\\nStringBuilder a = new StringBuilder(\\\"123\\\");\\n\\n//StringBuilder和StringBuffer 可以通过toString()方法转换成String类型\\nStringBuilder a1 = new StringBuilder(\\\"123\\\");\\nString a1 = a.toString();\\n```\\n\\n### 5. 三者比较和选择❗\\n\\n比较：\\n\\n1. StringBuilder 和 StringBuffer 非常类似，均代表可变的字符序列，而且方法也一样\\n2. String：字符串常量，不可变字符序列，效率低，但是复用率高。\\n3. StringBuffer：字符串变量，可变字符序列、效率较高（增删）、线程安全\\n4. StringBuilder：字符串变量，可变字符序列、效率最高、线程不安全\\n\\n选择：\\n\\n1. 如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder\\n2. 如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder\\n3. 如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer\\n4. 如果我们字符串很少修改，被多个对象引用，使用String,比如配置信息等\\n\\nString使用注意说明：   \\nstring s:=\\\"a\\\"; //创建了一个字符串  \\ns+=\\\"b\\\"; //实际上原来的\\\"a\\\"字符串对象已经丢弃了，现在又产生了一个字符串s+\\\"b\\\"(也就是\\\"ab\\\")。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。**<font color=\\\"red\\\">如果我们对String做大量修改，不要使用 String</font>**\\n\\n**<font color=\\\"red\\\">StringBuilder 和 StringBuffer 的使用方法是一样的</font>**\\n\\n---\\n\\n## 🖇️Math\\n\\n### 1. abs 绝对值\\n\\n### 2. pow 求幂\\n\\n### 3. ceil 向上取整\\n\\n### 4. floor 向下取整\\n\\n### 5. round 四舍五入\\n\\n### 6. sqrt 求开方\\n\\n### 7. random 求随机数\\n\\n获取一个a-b之间的一个随机整数\\n\\n```java\\nint num = (int)(a + Math.random()*(b - a + 1));\\n```\\n\\n### 8. max 求两个数的最大值\\n\\n### 9. min 求两个数的最小值\\n\\n## 🖇️Arrays 类\\n\\n### 1. toString 返回数组的字符串形式\\n\\n```java\\nArrays.toString(arr);\\n```\\n\\n### 2. sort 排序（自然排序和定制排序）\\n\\n```java\\nArrays.sort(a);\\n```\\n\\n```java\\nArrays.sort(a, new Comparator() {\\n  \\t\\t\\t@Override\\n  \\t\\t\\tpublic int compare(Object o1, Object o2) {\\n   \\t\\t\\treturn 0;\\n  \\t\\t\\t}\\n\\t\\t}\\n);\\n```\\n\\n### 3. binarySearch 通过二分搜索法进行查找\\n\\n返回对应数组下标（要求必须排好序，如果数组是无序的，则不能使用。如果数组中不存在搜索的数字，会返回与之相近的、偏大的数字的、下标数字加一的负数。如下）\\n\\n```java\\nInteger[] a = {-5, -4, 5, 31, 79, 100};\\n//查找6，但是6并不存在\\nSystem.out.println(Arrays.binarySearch(a, 6));//输出-4\\nSystem.out.println(Arrays.binarySearch(a, -3));//输出-3\\n```\\n\\n### 4. copyOf 数组元素的复制\\n\\n### 5. fill 数组元素的填充\\n\\n```java\\nArrays.fill(arr,1);//将数组元素全部用1替换\\n```\\n\\n### 6. equals 比较两个数组元素内容是否完全一致\\n\\n### 7. asList 将一组值，转换成list\\n\\n---\\n\\n## 🖇️System 类\\n\\n### 1. exit 退出当前程序\\n\\n### 2. arraycopy 复制数组元素\\n\\n```java\\nSystem.arraycopy(arr1, 0, arr2, 0, 3);\\n//源数组\\n//源数组的第几个位置\\n//目标数组\\n//目标数组的第几个位置\\n//拷贝几个元素\\n```\\n\\n一般不用它，一般用 Arrays.copyOf() ，它的底层就是 System.arraycopy()\\n\\n### 3. currenTimeMillens 返回当前时间距离 1970-1-1 的毫秒数\\n\\n### 4. gc 运行垃圾回收机制\\n\\n---\\n\\n## 🖇️BigInteger 和 BigDecimal 类\\n\\n1. 初始化的时候需要用字符串\\n\\n   ```java\\n   BigInteger bigInteger = new BigInteger(\\\"123456789123456789123456789\\\");\\n   BigDecimal bigDecimal = new BigDecimal(\\\"123.123456789123456789\\\");\\n   ```\\n\\n**<font color=\\\"red\\\">计算的时候不能用普通的运算符（+ - * /），需要使用以下的方法</font>**\\n\\n2. add 加\\n\\n3. subtract 减\\n\\n4. multiply 乘\\n\\n5. divide 除\\n\\n   **<font color=\\\"red\\\">小数除法的时候有可能除不尽，然后报错，需要添加一个参数，就可以保留到分子的精度</font>**\\n\\n   ```java\\n   bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING);\\n   ```\\n\\n---\\n\\n## 🖇️Date、Calendar、LocalDate 类\\n\\n### 1. Date\\n\\n1. Date 精确到毫秒，代表特定的瞬间\\n\\n   ```java\\n   Date date = new Date();\\n   ```\\n\\n2. SimpleDateFormat 格式和解析日期的类。它允许进行格式化（日期->文本）解析（文本->日期）和规范化\\n\\n   ```java\\n   //格式化日期\\n   SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy年MM月dd日 HH:mm:ss E\\\");\\n   System.out.println(dateFormat.format(date));\\n   //输出：2022年09月11日 15:41:37 周日\\n   ```\\n\\n   ```java\\n   //文本转日期\\n   String s = \\\"2022年09月11日 15:41:37 周日\\\";\\n   Date date1 = dateFormat.parse(s);\\n   System.out.println(dateFormat.format(date1));\\n   //字符串转日期\\n   String s = \\\"2022年09月11日 15:41:37 周日\\\";\\n   Date date1 = dateFormat.parse(s);\\n   System.out.println(dateFormat.format(date1));\\n   ```\\n\\n### 2. Calendar\\n\\n```java\\n//创建日历类对象\\nCalendar c = Calendar..getlnstance(); \\n\\n//获取日历对象的某个日历字段\\nSystem.out.printIn(\\\"年:\\\" + c.get(Calendar.YEAR));\\nSystem.out.println(\\\"月:\\\" + (c.get(Calendar.MONTH) + 1));\\nSystem.out.println(\\\"日:\\\" + c.get(Calendar.DAY_OF_MONTH));\\nSystem.out.println(\\\"小时：，\\\" + c.get(Calendar.HOUR));\\nSystem.out.printIn(\\\"分钟：\\\" + c.get(Calendar.MINUTE);\\nSystem.out.println(\\\"秒:\\\" + c.get(Calendar.SECOND));\\n                   \\n//Calender没有专门的格式化方法，所以需要程序员自己来组合显示\\nSystem.out.println(c.get(Calendar.YEAR) + \\\"年\\\" + (c.get(Calendar.MONTH) + 1) + \\\"月\\\" + c.get(Calendar.DAY_OF_MONTH) + \\\"日\\\");\\n```\\n\\nCalendar 中存在以下问题：\\n\\n1. 可变性：像日期和时间这样的类应该是不可变的。\\n2. 偏移性：Date中的年份是从1900开始的，而月份都从0开始。\\n3. 格式化：格式化只对Date有用，Calendar则不行。\\n4. 此外，它们也不是线程安全的；不能处理闰秒等（每隔2天，多出1s)。\\n\\n### 3. LocalDate - 第三代日期\\n\\n1. LocalDate（日期/年月日）\\n\\n2. LocalTime（时间/时分秒）\\n\\n3. LocalDateTime（日期+时间）\\n\\n   ```java\\n   LocalDateTime ldt = LocalDateTime.now();\\n                     getYear(); //年      \\n                     getMonth();  //月    \\n                     getMonthValue(); //月 \\n                     getDayofMonth(); //日\\n                     getHour(); //时     \\n                     getMinute(); //分   \\n                     getSecond(); //秒\\n   //使用now()返回表示当前日期时间的对象\\n   LocalDate now=LocalDate.now();//可以获取当前年月日\\n   LocalTime now2=LocalTime.now();//获取到当前时分秒\\n   ```\\n\\n4. DateTimeFormatter 日期格式化\\n\\n   ```java\\n   DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\\\"yyyy-MM-dd hh:mm:ss\\\");\\n   LocalDateTime localDateTime = LocalDateTime.now();\\n   String format = dateTimeFormatter.format(localDateTime);\\n   ```\\n\\n5. Instant 时间戳\\n\\n   ```java\\n   //通过静态方法now()获取表示当前时间戳的对象\\n   Instant instant = Instant.now();\\n   //通过from可以把Instant转成Date\\n   Date date = Date.from(instant);\\n   //通过date的toInstant()可以把date转成instant \\n   ```\\n\\n\\n---\\n\\n## 🖇️集合\\n\\n### 1. 集合框架体系\\n\\n数组的不足之处： \\n1. 长度开始时必须指定，不能更改\\n2. 保存的数据为同一种类型\\n3. 使用数组增加/删除元素的时候比较麻烦\\n\\n集合的好处： \\n1. 可以动态保存任意多个对象\\n2. 提供了一系列方便的操作对象的方法\\n3. 使用集合添加/删除元素比较方便\\n\\n### 2. Collection - 单列集合\\n\\n1. collection.实现子类可以存放多个元素，每个元素可以是Object\\n\\n2. 有些Collection的实现类，可以存放重复的元素，有些不可以\\n\\n3. 有些Collection的实现类，有些是有序的(List),有些不是有序(Set)\\n\\n4. Collection接口没有直接的实现子类，是通过它的子接口Set和List来\\n   实现的\\n\\n   ```java\\n   add:添加单个元素\\n   remove:删除指定元素\\n   contains:查找元素是否存在\\n   size:获取元素个数\\n   isEmpty:判断是香为空\\n   clear:清空\\n   addALl:添加多个元素\\n   containsAll:查找多个元素是否都存在\\n   removeAll:删除多个元素\\n   ```\\n\\n#### List\\n\\nList集合类中元素有序（即添加顺序和取出顺序一致）、且可重复\\n\\nList集合中的每个元素都有其对应的顺序索引，即支持索引\\n\\nList容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。\\n\\n1. 迭代器\\n\\n   ```java\\n   ArrayList arrayList = new ArrayList();\\n   //新建一个迭代器对象，并重置迭代器\\n   Iterator iterator = arrayList.iterator();\\n   //迭代元素\\n   while (iterator.hasNext()) {\\n     Object next = iterator.next();\\n     System.out.println(next);\\n   }\\n   ```\\n\\n2. 增强 for 循环\\n\\n   ```java\\n   for (Object obj : arrayList) {\\n   \\tSystem.out.println(obj);\\n   }\\n   ```\\n\\n**<font color=\\\"red\\\">增强for循环在普通数组中也能使用。</font>**\\n\\n**<font color=\\\"red\\\">增强for循环其实是简化版的迭代器，底层仍然是hasNext()</font>**\\n\\n##### ArrayList❗\\n\\n1. ArrayList是由数组来实现数据存储的\\n2. ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高）。在多线程情况下，不建议使用ArrayList\\n3. ArrayListr中维护了一个Object类型的数组elementData.  \\n   `transient Object[] elementData;`  \\n   transient 表示瞬间，短暂的，表示该属性不会被序列化 ^9da737\\n4. 当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容elementData为10，如需要再次扩容，则扩容elementData为1.5倍。\\n5. 如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍。\\n\\n##### Vector❗\\n\\n1. Vector底层也是一个对象数组，`protected Object[] elementData;`\\n2. Vector 是线程同步的，也就是线程安全\\n\\n##### Vector 和 ArrayList 的比较\\n\\n|           | 底层结构 | 版本   | 线程安全       | 扩容倍数                                                     |\\n| --------- | -------- | ------ | -------------- | ------------------------------------------------------------ |\\n| ArrayList | 可变数组 | jdk1.2 | 不安全，效率高 | 1. 无参默认0，第一次10，之后1.5倍<br />2. 有参第一次及之后都1.5倍 |\\n| Vector    | 可变数组 | jdk1.0 | 安全，效率不高 | 1. 无参默认为10，第一次及之后为2倍<br />2. 有参第一次及之后都2倍 |\\n\\n##### LinkedList\\n\\n1. LinkedList底层实现了**双向链表**和**双端队列**特点\\n2. 可以添加任意元素（元素可以重复），包括null\\n3. 线程不安全，没有实现同步\\n4. LinkedList底层维护了一个双向链表\\n5. LinkedList中维护了两个属性 first 和 last 分别指向首节点和尾节点\\n6. 每个节点(Node对象)，里面又维护了prev、next、item三个属性，其中通过\\n   prev指向前一个，通过next指向后一个节点。最终实现双向链表\\n7. 所以LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高。\\n![双向链表](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-5c3.png)\\n\\n##### LinkedList 和 ArrayList 的比较\\n\\n|            | 底层结构 | 增删的效率         | 改查的效率 |\\n| ---------- | -------- | ------------------ | ---------- |\\n| ArrayList  | 可变数组 | 较低，数组扩容     | 较高       |\\n| LinkedList | 双向链表 | 较高，通过链表追加 | 较低       |\\n\\n如何选择ArrayList和LinkedList:\\n\\n1. 如果我们改查的操作多，选择ArrayList\\n2. 如果我们增删的操作多，选择LinkedList\\n3. 一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList\\n4. 在一个项目中，根据业务灵活选择，也可能这样：一个模块使用的是ArrayList，另外一个模块是LinkedList\\n\\n#### Set\\n\\n1. Set 接口基本介绍\\n   1. 无序（添加和取出的顺序不一致），没有索引\\n   2. 不允许重复元素，所以最多包含一个null\\n   3. JDK APIE中Set接口的实现类有：HashSrt、TreeSet等\\n\\n2. Set 遍历方式\\n\\n   同Collection 的遍历方式一样，因为 Set 接口是 Collection 接口的子接口\\n\\n   1. 可以使用迭代器\\n   2. 增强 for\\n   3. 不能使用索引的方式来获取\\n\\n##### HashSet❗\\n\\n1. HashSet 的底层其实就是 HashMap\\n2. HashMap的底层是（数组+链表+红黑树）\\n\\nHashSet 添加元素底层是如何实现的：\\n\\n1. 添加一个元素时，**先得到 hash 值，然后转成索引值**（**<font color=\\\"red\\\">注意：不同对象 hashcode 值不一定不同，由 hashcode 转成的索引值也不一定不同。如果想要索引值相同，可以重写 hashcode() 方法</font>**）\\n\\n   ```java\\n   static final int hash(Object key) {\\n     int h;\\n     return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\\n   }\\n   ```\\n\\n2. 找到你想添加元素的存储数据表，看这个索引位置是否已经存放有元素\\n\\n3. 如果没有，直接加入。如果有，**调用 equals 比较**，如果相同就放弃添加，**如果不相同，则添加到这个索引的链表的最后**（**<font color=\\\"red\\\">注意：equals 可以重写，不再比较引用地址，而是比较内容：当对象的属性值相同时，返回相同的 hashcode 值 ，从而使得[不同对象但属性值相同的]对象，只能添加一个</font>**）\\n\\n4. 在 jdk8以后，如果一条链表的对象个数达到 TREEIFY_THRESHOLD（**默认是8**），并且 table 的大小达到 MIN_TREEIFY_CAPACITY （**默认是64**），就会进行**树化**（红黑树）\\n\\nHashSet 扩容机制：\\n\\n1. **第一次添加时，table 数组扩容到 16**，临界值（threshold）是16\\\\*加载因子（loadFactor）是0.75 = 12\\n2. 如果 table 数组使用到了**临界值12**（**<font color=\\\"red\\\">注意：这里是指整个 table 数组中的对象达到12个，并非仅仅一个链表</font>**），就会扩容到 16\\\\*2 = 21，新的临界值就是 32\\\\*0.75 = 24，依次类推\\n\\n##### TreeSet\\n\\n1. TreeSet 拥有一个可以传入两个参数的构造器，一个是存入的对象，一个是比较器（Comparator）\\n2. 如果没有传入比较器，就会在底层 `Comparator<? super k>k = (Comparable<?super K>)key;` 把存入的对象转成 Comparator类型 \\n\\n##### LinkedHashSet\\n\\n1. LinkedHashSet 底层是一个 LinkedHashMap，底层维护了一个 数组+双向链表\\n2. LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的。\\n3. LinkedHashSet 也不能添加重复元素\\n\\n### 3. Map - 双列集合\\n\\n1. 用于保存具有映射关系的数据：Key-Value（双列元素）\\n\\n2. Map中的key和value可以是任何引用类型的数据，会封装到HashMap:$Node对象中\\n\\n3. Map中的key不允许重复，原因和HashSet一样，当有相同的k，就等价于替换。\\n\\n4. Map 中的value是可以重复的\\n\\n   ```java\\n   Map map = new HashMap();\\n   map.put(key, value);\\n   ```\\n\\n5. Map 体系的继承图\\n\\n   ![Map体系图](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/Map%E4%BD%93%E7%B3%BB%E5%9B%BE-249.png)\\n\\n6. Map 接口常用方法\\n\\n   - put:添加\\n   - remove:根据键删除映射关系\\n   - get:根据键获取值\\n   - size获取元素个数\\n   - isEmpty:判断个数是否为0\\n   - clear:清除\\n   - containsKey:查找键是否存在\\n   - getOrDefault(a,0)：查看a是否存在，如果存在返回a的value，如果不存在就返回0\\n\\n#### HashMap❗\\n\\n1. Map接口的常用实现类：HashMap、Hashtable和Properties。\\n2. HashMap是Map接口使用频率最高的实现类。\\n3. HashMap是以key-val对的方式来存储数据（HashMap$Node类型）\\n4. key不能重复，但是值可以重复，允许使用nul键和nul值。\\n5. 如果添加相同的key，则会覆盖原来的key-val，等同于修改。(key不会替换，val会替换)\\n6. 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的。（jdk8的\\n   hashMap底层数组+链表+红黑树，之前是数组+链表）\\n7. HashMap没有实现同步，因此是线程不安全的\\n\\n#### Hashtable\\n\\n1. Hashtable 线程安全\\n\\n#### LinkedHashMap\\n\\n#### TreeMap\\n\\n1. TreeSet 的底层就是 TreeMap\\n\\n#### Properties\\n\\n1. Properties 类继承自 Hashtable 类并且实现了 Map 接口，也是使用一种键值对的形式来保存数据。\\n2. 他的使用特点和Hashtable类似\\n3. Properties 还可以用于从 xxx.properties 文件中，加载数据到 Properties 类对像，\\n   并进行读取和修改\\n\\n### Collections 工具类\\n\\n1. Collections工具类介绍\\n\\n   Collections是一个操作 Set、List 和 Map 等集合的工具类\\n\\n   Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作\\n\\n2. 排序操作：(均为 static 方法)\\n\\n   reverse(List)：反转 List 中元素的顺序\\n\\n   shuffle(List)：对 List 集合元素进行随机排序\\n\\n   sot(List)：根据元素的自然顺序对指定List集合元素按升序排序\\n\\n   sort(List, Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序\\n\\n   swap(List,int,int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换\\n\\n3. 查找、替换：\\n\\n   Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素\\n\\n   Object max(Collection, Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素\\n\\n   Object min(Collection)\\n\\n   Object min(Collection, Comparator)\\n\\n   int frequency(Collection, Object)：返回指定集合中指定元素的出现次数\\n\\n   void copy(List dest, List src)：将 src 中的内容复制到 dest 中\\n\\n   boolean replaceAll(List list, Object oldVal, Object newVal)：新值替换 List 对象的所有旧值\\n\\n**<font color=\\\"red\\\">自然排序是指按首字母A-Z、a-z排序</font>**\\n\\n### 总结-开发中如何选择集合实现类\\n\\n在开发中，选择什么集合实现类，主要取决于务操作特点，然后根据集合实现类特性进行\\n选择，分析如下：\\n\\n1. 先判断存储的类型（一组对象[单列]或一组键值对[双列]）\\n\\n2. 一组对象：Collection接口\\n\\n   - 允许重复：List\\n\\n     增删多：LinkedList [底层维护了一个双向链表]\\n\\n     改查多：ArrayList [底层维护Object类型的可变数组]\\n\\n   - 不允许重复：Set\\n\\n     无序：HashSet [底层是HashMap,维护了一个哈希表，即（数组+链表+红黑树）]\\n\\n     排序：TreeSet\\n\\n     插入和取出顺序一致：LinkedHashSet，维护数组+双向链表\\n\\n3. 一组键值对：Map\\n\\n   - 键无序：HashMap [底层是：哈希表 jdk7:数组+链表，jdk8:数组+链表+红黑树]\\n   - 键排序：TreeMap\\n   - 键插入和取出顺序一致：LinkedHashMap\\n   - 读取文件：Properties\\n\\n---\\n\\n## 🖇️泛型\\n\\n### 1. 泛型的理解和好处\\n\\n使用传统方法的问题分析\\n\\n1. 不能对加入到集合ArrayList中的数据类型进行约束（不安全）\\n2. 遍历的时候，需要进行类型转换，如果集合中的数据量较大，对效率有影响\\n\\n泛型介绍\\n\\n1. 泛型又称参数化类型，是Jdk5.0出现的新特性，解决数据类型的安全性问题\\n2. 在类声明或实例化时只要指定好需要的具体的类型即可\\n3. Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生 ClassCastException 异常。同时，代码更加简洁、健壮\\n4. 泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型或者是某个方法的返回值的类型，或者是参数类型\\n\\n### 2. 泛型基本语法\\n\\n1. 给泛型指向数据类型时，**要求是引用类型**，**不能是基本类型**\\n2. 在给泛型指定具体类型后，可以传入**该类型或者其子类类型**\\n3. 如果没有指定泛型，默认是object类型\\n4. 使用泛型的数组，不能初始化\\n5. 静态方法中不能使用类的泛型\\n\\n### 3. 自定义泛型\\n\\n#### 4. 泛型的继承和通配符\\n\\n1. 泛型不具备继承性\\n2. \\\\<?>：支持任意泛型类型\\n3. \\\\<? extends A>： 支持A类以及A类的子类，规定了泛型的上限\\n4. \\\\<?super A>：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限\\n\\n---\\n\\n## 🖇️Java 绘图坐标体系\\n\\n下图说明了Java坐标系。坐标原点位于左上角，以像素为单位。  \\n第一个是x坐标，表示当前位置为水平方向，距离坐标原点x个像素  \\n第二个是y坐标，表示当前位置为垂直方向，距离坐标原点y个像素。\\n\\n![Java 绘图坐标体系](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/Java%20%E7%BB%98%E5%9B%BE%E5%9D%90%E6%A0%87%E4%BD%93%E7%B3%BB-870.png)\\n\\n绘图原理：\\n\\n1. paint(Graphics g)绘制组件的外观\\n\\n2. repaint()刷新组件的外观。\\n3. 当组件第一次在屏幕显示的时候，程序会自动的调用paint()方法来绘制组件。\\n4. 窗口最小化，再最大化、窗口的大小发生变化、repaint函数被调用的时候pain()将会被调用\\n\\n```java\\n//JFrame 就是一个画框\\npublic class DrawCricle extends JFrame {\\n    private MyPanel mp = null;\\n\\n    public static void main(String[] args) {\\n        DrawCricle drawCricle = new DrawCricle();\\n    }\\n\\n    public DrawCricle() {\\n        mp = new MyPanel();\\n        this.add(mp);\\n        this.setSize(400, 300);\\n        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\\n        this.setVisible(true);\\n    }\\n}\\n//Mypanel 对象就是一个画板\\n//Graphics g 就是一个画笔\\nclass MyPanel extends JPanel {\\n    @Override\\n    public void paint(Graphics g) {\\n        super.paint(g);\\n        g.drawOval(10, 10, 100, 100);\\n    }\\n}\\n```\\n\\n---\\n\\n## 🖇️Java 事件处理机制\\n\\nKeyListener 是监听器，可以监听键盘事件\\n\\n```java\\nclass MyPanel extends JPanel implements KeyListener {\\n    @Override\\n    public void paint(Graphics g) {\\n        super.paint(g);\\n        g.fillOval(10, 10, 100, 100);\\n    }\\n\\t\\t//有字符输出时，该方法就会触发\\n    @Override\\n    public void keyTyped(KeyEvent e) {\\n        \\n    }\\n\\t\\t//当某个键按下，该方法会触发\\n    @Override\\n    public void keyPressed(KeyEvent e) {\\n        if (e.getKeyCode() == KeyEvent.VK_DOWN) {\\n            y++;\\n        } else if (e.getKeyCode() == KeyEvent.VK_UP) {\\n            y--;\\n        } else if (e.getKeyCode() == KeyEvent.VK_LEFT) {\\n            x--;\\n        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {\\n            x++;\\n        }\\n        this.repaint();\\n    }\\n\\t\\t//当某个键释放，该方法会触发\\n    @Override\\n    public void keyReleased(KeyEvent e) {\\n\\n    }\\n}\\n```\\n\\n![Java事件处理机制](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/Java%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6-aa3.png)\\n\\n1. 事件源：事件源是一个产生事件的对象，比如按钮，窗口等。\\n2. 事件：事件就是承载事件源状态改变时的对象，比如当键盘事件、鼠标事件、窗口事件等等，会生成一个事件对像，该对象保存着当前事件很多信息，比如KeyEvent对像有含义被按下键的Code值。java.awt.event包和javax.swing.event包中定义了各种事件类型\\n\\n## 🖇️线程\\n\\n### 1. 线程项关概念\\n\\n1. 进程：是指运行中的程序\\n\\n2. 线程：线程是由进程创建的，是进程的一个实体；一个进程可以拥有多个线程\\n   - 单线程：同一个时刻，只允许执行一个线程\\n   - 多线程：同一个时刻，可以执行多个线程\\n   - **并发**：同一个时刻，多个任务**交替执行**，造成一种“貌似同时”的错觉，简单的说，单核cpu实现的多任务就是并发\\n   - **并行**：同一时刻，多个任务**同时执行**，多核cpu可以实现并行；并发和并行可以同时存在\\n\\n3. 当一个类继承了 Thread 类，该类就可以当作线程使用\\n\\n   ```java\\n   at cat = new Cat();\\n   cat.start();\\n   //start()方法会启动一个线程，main线程和该线程会同时进行，\\n   //而单纯使用一个方法没有真正启动一个线程，而是会在方法执行完后再继续执行main方法\\n   ```\\n\\n4. 当一个类实现了 Runnable 接口，该类就可以当作线程使用\\n\\n   ```java\\n   class Cat implements Runnable {\\n     @Override\\n       public void run() {\\n           while (true) {\\n               System.out.println(\\\"miao~\\\");\\n           }\\n       }\\n   }\\n   ```\\n\\n5. 继承 Thread 和实现 Runnable 的区别\\n\\n   1. 从java的设计来看，通过继承Thread或者实现Runnable接口来创建线程本质上没有区别，而且Thread类本身就实现了Runnable接口\\n   2. 实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了java**单继承的限制**\\n\\n当main线程启动一个子线程，主线程不会阻塞，会继续交替执行\\n\\n***start()方法调用start0()方法后，该线程并不一定会立马执行，只是将线程变成了可运行状态。具体什么时候执行，取决于CPU,，由CPU统一调度。***\\n\\n### 2. 线程常用方法\\n\\n1. setName //设置线程名称，使之与参数name相同\\n\\n2. getName //返回该线程的名称\\n\\n3. start //使该线程开始执行；Java虚拟机底层调用该线程的start0方法\\n\\n4. run //调用线程对像run方法；\\n\\n5. setPriority //更改线程的优先级\\n\\n6. getPriority //获取线程的优先级\\n\\n   优先级有三种：\\n\\n   * MIN_PRIORITY = 1\\n   * NORM_PRIORITY = 5\\n   * MAX_PRIORITY = 10\\n\\n7. sleep //在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）\\n\\n8. interrupt //中断线程，没有真正的结束线程，一般用于中断正在休眠的线程\\n\\n9. yield //线程的礼让。让出cpu，让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功\\n\\n10. join //线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务\\n\\n### 3. 用户线程和守护线程：\\n\\n1. 用户线程：也叫工作线程，当线程的任务执行完或通知方式结束\\n\\n2. 守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束\\n\\n   ```java\\n   子线程对象.setDeamon(true) //将该对象设置为守护线程\\n   ```\\n\\n   * 常见的守护线程：**垃圾回收机制**\\n\\n### 4. 线程的生命周期\\n\\n\\n线程可以处于以下状态之一：\\n\\n1. NEW：尚未启动的线程处于此状态。\\n2. RUNNABLE：在Java虚拟机中执行的线程处于此状态。\\n3. BLOCKED：被阻塞等待监视器锁定的线程处于此状态。\\n4. WAITING：正在等待另一个线程执行特定动作的线程处于此状态。\\n5. TIMED WAITING：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。\\n6. TERMINATED：己退出的线程处于此状态。\\n\\n**<font color=\\\"red\\\">有些文章或者资料中标注有七种状态，其实是 Runable 状态下细分出两个子状态 Ready 和 Running 状态</font>**\\n\\n![Java线程状态转换图](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE-778.jpg)\\n\\n### 5. 线程同步机制\\n\\n在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，***保证数据在任何同一时刻，最多有一个线程访问，以保证数据的完整性***。  \\n也可以这里理解：线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，***直到该线程完成操作，其他线程才能对该内存地址进行操作***\\n\\n1. 同步具体方法 - **Synchronized**\\n\\n   * 同步代码块\\n\\n     ```java\\n     synchronized (同一个对象){//得到对像的锁，才能操作同步代码\\n     \\t//需要被同步代码;\\n     }\\n     ```\\n\\n   * synchronized 还可以放在方法声明中，表示整个方法-为同步方法\\n\\n     ```java\\n     public synchronized void run(){\\n     \\t//需要被同步的代码\\n     }   \\n     ```\\n\\n### 6. 互斥锁\\n\\n基本介绍：\\n\\n1. Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。\\n\\n2. 每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。\\n\\n3. 关键字 synchronized 来与对象的互斥锁联系。当某个对象用 synchronized 修饰时，表明该对象在任一时刻只能由一个线程访问\\n\\n4. 同步的局限性：导致程序的执行效率要降低\\n\\n5. 非静态的同步方法的锁可以是this，也可以是其他对象（要求是同一个对象）\\n\\n   如下，这就是一个同步方法，锁在this对象\\n\\n   ```java\\n   public synchronized void method(){\\n   \\t//需要被同步的代码\\n   }   \\n   ```\\n\\n   ```java\\n   synchronized (this){//得到对像的锁，才能操作同步代\\n   \\t//需要被同步代码;\\n   }\\n   ```\\n\\n6. 静态的同步方法的锁为当前类本身。\\n\\n   ```java\\n   public synchronized static void method(){\\n   \\t//需要被同步的代码\\n   }\\n   ```\\n\\n   ```java\\n   synchronized (类.class){//得到对像的锁，才能操作同步代码\\n   \\t//需要被同步代码;\\n   }\\n   ```\\n\\n7. 注意事项：\\n\\n   1. 同步方法如果没有使用static修饰：默认锁对象为this\\n   2. 如果方法使用static修饰，默认锁对象：当前类.class\\n   3. 实现步骤：\\n      * 需要先分析上锁的代码\\n      * 选择==同步代码块==或同步方法\\n      * 要求***多个线程的锁对象为同一个***\\n\\n### 7. 线程的死锁\\n\\n基本介绍：  \\n多个线程都占用了对方的锁资源，但不肯相让，导致了死锁，在编程是一定要避免死锁的发生\\n\\n### 8. 释放锁\\n\\n1. 当前线程的同步方法、同步代码块**执行结束**\\n2. 当前线程在同步代码块，同步方法中遇到**break、return**\\n3. 当前线程在同步代码块、同步方法中出现了**未处理的Error或Exception**，导致异常结束\\n4. 当前线程在同步代码块、同步方法中执行了线程对象的**wite()方法**，**当前线程暂停，并释放锁。**\\n\\n下面操作不会释放锁：\\n\\n1. 线程执行同步代码块或同步方法时，程序调用**Thread.sleep()、Thread.yield() 方法暂停当前线程的执行，不会释放锁**\\n2. 线程执行同步代码块时，其他线程调用了该线程的 **suspend() 方法**将该线程挂起，该线程不会释放锁。\\n\\n---\\n\\n## 🖇️IO\\n\\n### 1. 文件\\n\\n1. 文件流\\n\\n   文件在程序中是以流的形式来操作的\\n\\n   ![文件流](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E6%96%87%E4%BB%B6%E6%B5%81-938.png)\\n\\n   流：数据在数据源（文件）和程序（内存）之间经历的路径\\n\\n   输入流：数据从数据源（文件）到程序（内存）的路径\\n\\n   输出流：数据从程序（内存）到数据源（文件）的路径\\n\\n2. 创建文件对象相关构造器和方法\\n\\n   ```java\\n   File file = new File(String pathname)//根据路径构建一个File对象\\n   File file = new File(File parent,String child)//根据父目录文件+子路径构建\\n   File file = new File(String parent,String child)//根据父目录+子路径构建\\n     \\n   file.createNewFile(); //创建文件  \\n   ```\\n\\n   * getName //获取文件名\\n   * getAbsolutePath //文件绝对路径\\n   * getParent //文件的父级目录\\n   * length //文件内容大小（**一个字母占一个字节，一个汉字占三个字节**）\\n   * exists //文件是否存在\\n   * isFile //判断是否是一个文件\\n   * isDirectory //判断是否是一个目录\\n\\n3. 目录的操作和文件删除\\n\\n   * mkdir() //创建一级目录\\n   * mkdirs() //创建多级目录\\n   * delete() //删除空目录或文件\\n\\n### 2. IO流原理及流的分类\\n\\n#### 2.1 Java IO流原理\\n\\n1. IO是Input/Output的缩写，I/O技术是非常实用的技术，用于处理数据传输。如读/写文件，网络通讯等。\\n2. Java程序中，对于数据的输入/输出操作以”流(stream)”的方式进行。\\n3. java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过方法输入或输出数据\\n\\n#### 2.2 流的分类\\n\\n* 按操作数据单位不同分为：字节流(8bt)，字符流（按字符）\\n* 按数据流的流向不同分为：输入流，输出流\\n* 按流的角色的不同分为：节点流，处理流/包装流\\n\\n| （抽象基类） | 字节流       | 字符流 |\\n| ------------ | ------------ | ------ |\\n| 输入流       | InputStream  | Reader |\\n| 输出流       | OutputStream | Writer |\\n\\n### 3. 节点流和处理流\\n\\n#### 3.1 介绍\\n\\n1. 节点流可以从一个特定的数据源读写数据，如 FileReader、FileWriter\\n2. 处理流（也叫包装流）是“连接”在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，如 BufferedReader、BufferedWriter\\n\\n![节点流和处理流](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81-636.png)\\n\\nBufferedReader 类中，有属性 Reader，即可以封装一个节点流，该节点流可以是任意的，只要是Reader 的子类\\n\\n#### 3.2 节点流和处理流的区别和联系\\n\\n1. 节点流是底层流/低级流，**直接跟数据源相接**。\\n2. 处理流（包装流）包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出。\\n3. 处理流（也叫包装流）对节点流进行包装，使用了修饰器设计模式，**不会直接与数据源相连**\\n\\n#### 3.3 处理流的功能主要体现在以下两个方面：\\n\\n1. 性能的提高：主要以增加缓冲的方式来提高输入输出的效率。\\n2. 操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便\\n\\n#### 3.4 对象流-ObjectInputStream 和 ObjectOutputStream\\n\\n序列化和反序列化\\n\\n1. 序列化就是在保存数据时，保存**数据的值**和**数据类型**\\n2. 反序列化就是在恢复数据时，**恢复数据的值**和**数据类型**\\n3. 需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：\\n   * Serializable //这是一个标记接口，\\n   * Externalizable //该接口有方法需要实现，因此我们一般实现上面的 Serializable 接口\\n4. 序列化对象时，默认将里面所有属性都进行序列化，但除了 Static 或 [transient](java#^9da737) 修饰的成员\\n5. 序列化对象时，要求里面属性的类型也需要实现序列化接口\\n\\n```java\\n//序列化\\nObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(dirsrc));\\nobjectOutputStream.writeObject(dog);\\nobjectOutputStream.close();\\n//反序列化\\nObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(dirsrc1));\\nDog dog1 = (Dog) objectInputStream.readObject();\\nSystem.out.println(dog1);\\nobjectInputStream.close();\\n```\\n\\n![序列化和反序列化](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-484.png)\\n\\n**<font color=\\\"red\\\">存储对象数据的时候，要求该对象也要实现 Serializable 接口</font>** \\n\\n**<font color=\\\"red\\\">反序列化的顺序需要和序列化的顺序保持一致</font>** \\n\\n#### 3.5 标准输入输出流\\n\\n|                     | 类型         | 默认设备 |\\n| ------------------- | ------------ | -------- |\\n| System.in 标准输入  | InputStream  | 键盘     |\\n| System.out 标准输出 | OutputStream | 显示器   |\\n\\n#### 3.6 转换流-InputStreamReader 和 OutputStreamWriter\\n\\n1. InputStreamReader：\\n\\n   Readerl的子类，可以将 InputStream(字节流)包装成Reader(字符流)\\n\\n2. OutputStreamWriter：\\n\\n   Writer的子类，实现将OutputStream(字节流)包装成Vriter(字符流)\\n\\n3. 当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换成字符流\\n\\n4. 可以在使用时指定编码格式（比如 utf-8、gbk、gb2312、ISO8859-1 等）\\n\\n#### 3.7 打印流-PrintStream 和 PrintWriter\\n\\n**<font color=\\\"red\\\">打印流只有输出流，没有输入流</font>**\\n\\n### 4. 输入流\\n\\n#### 4.1 InputStream：字节输入流\\n\\n1. FilelnputStream：文件输入流\\n   * read()：一次读取一个字符\\n   * read(byte[] b)：一次读取b长度的字符\\n2. BufferedInputStream：缓冲字节输入流\\n3. ObjectInputStream：对像字节输入流\\n\\n#### 4.2 Reader：字符输入流\\n\\n1. FileReader\\n   * new FileReader(File/String)\\n   * read：每次读取单个字符，返回该字符，如果到文件末尾返回-1\\n   * read(char[])：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1\\n   * new String(char[])：将char[]转换成String\\n   * new String(char[],off,len)：将char[]的指定部分转换成String\\n\\n### 5. 输出流\\n\\n#### 5.1 OutputStream：字节输出流\\n\\n1. FileOutputStream：文件输出流\\n   * wirte(byte[] b)：一次写入b长度的字符\\n   * wirte(byte[] b, int off, int len)：将 b 的 len 字节从此文件的第 off 字节开始写入\\n   * write(int b)：将指定的字节写入此文件输出流。\\n\\n#### 5.2 Writer：字符输出流\\n\\n1. FileWriter\\n\\n   * new FileWriter(File/String)：覆盖模式，相当于流的指针在首端\\n   * new FileWriter(File/String,true)：追加模式，相当于流的指针在尾端\\n   * write(int)：写入单个字符\\n   * write(char[])：写入指定数组\\n   * write(char[],off,len)：写入指定数组的指定部分\\n   * write(string)：写入整个字符串\\n   * write(string,off,len)：写入字符串的指定部分\\n\\n   **<font color=\\\"red\\\">FileWriter使用后，必须要关闭(close)或刷新(flush)，否则要写入的数据还在内存中，没有写入到指定的文件！</font>**\\n\\n### 6. Properties类\\n\\n1. 专门用于读写配置文件的集合类\\n\\n   配置文的格式：`键=值`\\n\\n2. 键值对不需要有空格，值不需要用引号一起来。默认类型是String\\n\\n3. Properties 的常见方法\\n\\n   * load：加载配置文件的键值对到 Properties 对象\\n   * list：将数据显示到指定设备\\n   * getProperty(key)：根据键获取值\\n   * setProperty(key,value)：设置键值对到 Properties 对象\\n   * store：将 Properties 中的键值对存储到配置文件，在 idea中，保存信息到配置文件，如果含有中文，会存储为 unicode 码\\n\\n---\\n\\n## 🖇️网络编程\\n\\n### 1. 网络相关概念\\n\\n网络通信\\n\\n1. 概念：两台设备之间通过网络实现数据传输\\n2. 网络通信：将数据通过网络从一台设备传输到另一台设备\\n3. java.net包下提供了一系列的类或接口，供程序员使用，完成网络通信\\n\\nIP地址\\n\\n1. 概念：用于唯一标识网络中的每台计算机/主机\\n2. 查看ip地址：ipconfig\\n3. ip地址的表示形式：点分十进制 xx.xx.xx.xx\\n4. 每一个十进制数的范围：0~255\\n5. ip 地址的组成 = 网络地址 + 主机地址，比如：192.168.16.69\\n6. iIPV6是互联网工程任务组设计的用于替代IPV4的下一代IP协议，其地址数量号称可以\\n   为全世界的每一粒沙子编上一个地址\\n7. 由于IPV4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPV6\\n   的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联\\n   的障碍\\n\\n域名\\n\\n1. www.baidu.com\\n2. 好处：为了方便记忆，解决记ip的困难\\n3. 概念：将ip地址映射成域名\\n\\n端口号\\n\\n1. 概念：用于标识计算机上某个特定的网络程序\\n2. 表示形式：以整数形式，范围0~65535\\n3. 0~1024已经被占用，比如ssh22、ftp21、smtp25、http80\\n4. 常见的网络程序端口号：\\n   * tomcat 8080\\n   * mysql:3306\\n   * oracle:1521\\n   * sqlserver:1433\\n\\nTCP 和 UDP\\n\\n1. TCP 协议：传输控制协议\\n   1. 使用TCP协议前，须先建立TCP连接，形成传输数据通道\\n   2. 传输前，采用“三次握手”方式，是**<font color=\\\"red\\\">可靠的</font>**\\n   3. TCP协议进行通信的两个应用进程：客户端、服务端\\n   4. 在连接中可进行大数据量的传输\\n   5. 传输完毕，需释放已建立的连接，**效率低**\\n2. UDP协议：\\n   1. 将数据、源、目的封装成数据包，不需要建立连接\\n   2. ***<font color=\\\"red\\\">每个数据报的大小限制在64K内</font>***\\n   3. 因无需连接，故是**<font color=\\\"red\\\">不可靠的</font>**\\n   4. 发送数据结束时无需释放资源（因为不是面向连接的），速度快\\n\\n### 2. InetAddress 类\\n\\n相关方法\\n\\n1. 获取本机 InetAddress对象 getLocalHost\\n2. 根据指定主机名/域名获取ip地址对象getByName\\n3. 获取 InetAddress对象的主机名 getHostName\\n4. 获取 InetAddress 对象的地址 getHostAddress\\n\\n### 3. Socket\\n\\n基本介绍\\n\\n1. 套接字(Socket)开发网络应用程序被广泛采用，以至于成为事实上的标准。\\n2. 通信的两端都要有Socket，是两台机器间通信的端点\\n3. 网络通信其实就是Socket间的通信。\\n4. Socket:允许程序把网络连接当成一个流，数据在两个 Socket 间通过IO传输。\\n5. 一般主动发起通信的应用程序属客户端，等待通信请求的为服务端\\n\\n当我们需要通讯时（读写数据）\\n\\n1. socket.getOutputStream() //读取通道数据\\n\\n2. socket.getlnputStream() //写入通道数据\\n\\n   以上都是字符流，可以使用转换流转换成字节流\\n\\n3. socket.shutdownOutput() //写完数据后需要告知服务器，服务器才会继续执行\\n\\n   writer.newLine() //插入一个换行符，同样表示写入结束标记，但服务器也需要用 read.newLine() 读取\\n\\n### 4. TCP网络通信编程\\n\\n基本介绍\\n\\n1. 基于客户端--服务端的网络通信\\n2. 底层使用的是TCP/IP协议\\n3. 应用场景举例客户端发送数据，\\n4. 服务端接受并显示\\n5. 基于Socket的TCP编程\\n\\n![socket-TCP](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/socket-TCP-6d9.png)\\n\\n```java\\n//监听9999端口\\nServerSocket serverSocket =  new ServerSocket(9999);\\n//如果有客户端连接，则会返回Socket对象，程序继续\\nSocket socket = serverSocket.accept();\\n//连接本机9999端口\\nSocket socket = new Socket(InetAddress.getLocalHost(), 9999);\\n//得到和socket对象关联的输出流对象\\nOutputstream outputstream =  socket.getoutputstream();\\n//通过输出流，写入数据到数据通道\\noutputstream.write(\\\"hello,server\\\".getBytes());\\n//4.关闭流对象和socket,必须关闭\\noutputstream.close();\\nsocket.close();\\nserverSocket.close();\\n```\\n\\n***当客户端连接到服务端后，实际上客户端也是通过一个端口和服务端进行通讯的，这个端口是TCP/IP来分配的，是不确定的，是随机的***\\n\\n### 5. UDP网络通信编程[了解]\\n\\n基本介绍\\n\\n1. 类 DatagramSocket[数据报套接字] 和 DatagramPacket[数据包/数据报] 实现了基于UDP协议网络程序。\\n2. UDP数据报通过数据报套接字 DatagramSocket 发送和接收，***系统不保证 UDP 数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。***\\n3. DatagramPacket 对象封装了 UDP 数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。\\n4. UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接\\n5. UDP一个数据包最大为64k\\n\\n基本流程\\n\\n1. 核心的两个类/对象 DatagramSocket 与 DatagramPacket\\n2. 建立发送端，接收端（没有服务端和客户端概念）\\n3. 发送数据前，建立 数据包/报DatagramPacket 对象\\n4. 调用DatagramSocket的发送、接收方法\\n5. 关闭DatagramSocket\\n\\n```java\\n//监听9999端口\\nDatagramSocket datagramSocket = new DatagramSocket(9999);\\nbyte[] bytes = new byte[1024];\\nDatagramPacket datagramPacket = new DatagramPacket(bytes, bytes.length);\\n//收到的数据传给datagramPacket\\ndatagramSocket.receive(datagramPacket);\\n//转成char[]\\nint length = datagramPacket.getLength();\\nbyte[] data = datagramPacket.getData();\\n//转成字符串\\nString s = new String(data);\\ndatagramSocket.close();\\n\\n//监听9998端口\\nDatagramSocket datagramSocket = new DatagramSocket(9998);\\nbyte[] bytes = \\\"你好，大傻逼\\\".getBytes();\\nDatagramPacket datagramPacket = new DatagramPacket(bytes, bytes.length, InetAddress.getLocalHost(), 9999);\\n//发送数据\\ndatagramSocket.send(datagramPacket);\\n```\\n\\n---\\n\\n## 🖇️反射\\n\\n### 1. 反射机制❗\\n\\n***<font color=\\\"red\\\">设计模式的 ocp 原则，也就是开闭原则：也就是不修改源码，扩容功能</font>***\\n\\n1. 反射机制允许程序在执行期借助于 ReflectionAPI 取得任何类的内部信息（比如成员变量，构造器，成员方法等等)，并能操作对象的属性及方法。反射在设计模式和框架底层都会用到\\n2. 加载完类之后，在堆中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，形象的称之为反射\\n\\n![Java程序计算机有三个阶段](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/Java%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%89%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5-07e.png)\\n\\n#### Java 反射机制可以完成\\n\\n1. 在运行时判断任意一个对象所属的类\\n2. 在运行时构造任意一个类的对象\\n3. 在运行时得到任意一个类所具有的成员变量和方法\\n4. 在运行时调用任意一个对象的成员变量和方法\\n5. 生成动态代理\\n\\n#### 反射相关的主要类：\\n\\n1. java.lang.Class：代表一个类，Class对像表示某个类加载后在堆中的对象\\n2. java.lang.reflect.Method：代表类的方法，Method对象表示某个类的方法\\n3. java.lang.reflect.Field：代表类的成员变量，Field对像表示某个类的成员变量\\n4. java.lang.reflect.Constructor：代表类的构造方法，Constructor 对象表示构造器\\n\\n#### 反射优点和缺点\\n\\n1. 优点：可以动态的创建和使用对象（也是框架底层核心），使用灵活，没有反射机制，框架技术就失去底层支撑。\\n2. 缺点：使用反射基本是解释执行，对执行速度有影响\\n\\n#### 反射调用优化-关闭访问检查\\n\\n1. Method和Field、Constructor)对象都有setAccessible()方法，setAccessible作用是启动和禁用访问安全检查的开关 \\n\\n   ***<font color=\\\"red\\\">可以获取私有成员，不安全但能提升效率，慎用</font>***\\n\\n2. 参数值为true表示反射的对象在使用时取消访问检查，提高反射的效率。参数值为falsel则表示反射的对象执行访问检查\\n\\n### 2. Class类❗\\n\\n#### 基本介绍\\n\\n1. Class也是类，因此也继承Object类\\n2. Class类对象不是new出来的，而是系统创建的\\n3. 对于某个类的Cass类对象，在内存中只有一份，因为类只加载一次\\n4. 每个类的实例都会记得自己是由哪个Class实例所生成\\n5. 通过Class可以完整地得到一个类的完整结构，通过一系列API\\n6. Classi对象是存放在堆的\\n7. 类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码，变量名，方法名，访问权限等等\\n\\n#### 常用方法\\n\\n```java\\nString str = \\\"com.hspedu.reflection.Person\\\";\\n//获取到Class类对象，?表示不确定的java类型\\nClass<?> clazz = Class.forName(str);\\nSystem.out.println(clazz);//显示该clazzi对象是哪个类的Class对象\\nSystem.out.printIn(clazz.getClass());//运行类型\\nSystem.out.println(clazz.getPackage().getName());\\nSystem.out.println(clazz.getName());\\nObject obj = clazz.newlnstance();//通过反射创建对象\\nField field = clazz.getField(\\\"name\\\");//通过反射获取属性\\nfield.set(obj,\\\"hspedu\\\");//通过字段对象赋值\\nObject obj22=field.get(obj);//获取值\\nSystem.out.println(obj2);//输出\\n```\\n\\n#### 获取Class类对象的方式\\n\\n1. 前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName0获取，可能抛出ClassNotFoundException,实例：Class cls1=Class.forName(\\\"java.lang.Cat\\\")\\n\\n   应用场景：多用于配置文件，读取类全路径，加载类。\\n\\n2. 前提：若已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高实例：Class cls2 = Cat.class;\\n\\n   应用场景：多用于参数传递，比如通过反射得到对应构造器对象\\n\\n3. 前提：已知某个类的实例，调用该实例的getClass0方法获取Class对像，实例：Class clazz=对象.getClass()；\\n\\n   应用场景：通过创建好的对象，获取Class对象\\n\\n4. 其他方式\\n\\n   ClassLoader cl = 对象.getClass().getClassLoader();\\n\\n   Class clazz4 = cl.loadClass(\\\"类的全类名\\\");\\n\\n5. 基本数据(int,char,boolean,float,double,byte,long,short)按如下方式得到Class类对象\\n\\n   `Class cls = 基本数据类型.class`\\n\\n6. 基本数据类型对应的包装类，可以通过.TYPE得到Class类对象\\n\\n   `Class cls = 包装类.TYPE`\\n\\n#### 哪些类型有Class对象\\n\\n1. 外部类，成损内部类，静态内部类，局部内部类，匿名内部类\\n2. interface:接口\\n3. 数组\\n4. enum:枚举\\n5. annotation:注解\\n6. 基本数据类型\\n7. void\\n\\n### 3. 类加载❗\\n\\n#### 1. 基本说明\\n\\n反射机制是java实现动态语言的关键，也就是**通过反射实现类动态加载**。\\n\\n1. 静态加载：编译时加载相关的类，如果没有则报错，依赖性太强\\n2. 动态加载：运行时加载需要的类，如果运行时不用该类，则不报错，降低了依赖性\\n\\n#### 2. 类加载时机\\n\\n1. 当创建对象时(new)  （静态加载）\\n2. 当子类被加载时（静态加载）\\n3. 调用类中的静态成员时（静态加载）\\n4. 通过反射（动态加载）\\n\\n![类加载过程图](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%9B%BE-310.png)\\n\\n![类加载各阶段完成任务](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%90%84%E9%98%B6%E6%AE%B5%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1-890.png)\\n\\n#### 3. 类加载五个阶段\\n\\n##### 3.1 加载阶段\\n\\nJVM在该阶段的主要目的是将字节码从不同的数据源（可能是class文件、也可能是jar包，甚至网络)转化为***二进制字节流加载到内存中***，并生成一个代表该类的java.lang.Class对象\\n\\n##### 3.2 连接阶段-验证\\n\\n1. 目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全\\n2. 包括：文件格式验证（是否以魔数 oxcafebabe 开头）、元数据验证、字节码验证和符号引用验证\\n3. 可以考虑使用-Xverify:none 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间\\n\\n##### 3.3 连接阶段-准备\\n\\nJVM会在该阶段对静态变量，分配内存并默认初始化（对应数据类型的默认初始值，如：int是0、String是null、boolean是false等)。这些变量所使用的内存都将在方法区中进行分配\\n\\n```java\\npublic int n1 = 10;//是实例属性，不是静态变量，因此在准备阶段是不会分配内存的\\npublic static int n2 = 20;//静态变量，会分配内存，但默认是0，在初始化的时候才会重新赋值为20\\npublic static final int n3 = 30;//常量，和静态变量不同，一旦赋值就不会变，所以在准备阶段就赋值为30\\n```\\n\\n##### 3.4 连接阶段-解析\\n\\n虚拟机将常量池内的符号引用替换为直接引用的过程。\\n\\n##### 3.5 初始化\\n\\n1. 到初始化阶段，才真正开始执行类中定义的 java 程序代码，此阶段是执行\\\\<clinit>() 方法的过程。\\n\\n2. \\\\<clinit>()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并进行合并。\\n\\n   ***<font color=\\\"red\\\">加载顺序：加载类 --> 静态变量、静态代码块(先后顺序加载) --> 成员变量、普通代码块 --> 构造方法</font>***\\n\\n3. 虚拟机会保证一个类的\\\\<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的\\\\<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行\\\\<clinit>()方法完毕\\n\\n### 4. 反射获取类的结构信息❗\\n\\n#### 1. java.lang.Class 类\\n\\n1. getName：获取全类名\\n2. getSimpleName：获取简单类名\\n3. getFields：获取所有public修饰的属性，包含本类以及父类的\\n4. getDeclaredFields：获取本类中所有属性\\n5. getMethods：获取所有public修饰的方法，包含本类以及父类的\\n6. getDeclaredMethods：获取本类中所有方法\\n7. getConstructors：获取所有public修饰的构造器，包含本类\\n8. getDeclaredConstructors：获取本类中所有构造器\\n9. getPackage：以Package形式返回包信息\\n10. getSuperClass：以Class形式返回父类信息\\n11. getInterfaces：以Class[]形式返回接口信息\\n12. getAnnotations：以Annotation[]形式返回注解信息\\n\\n#### 2. java.lang.reflect.Field 类\\n\\n1. getModifiers：以int形式返回修饰符\\n\\n   ***说明：默认修饰符是0，public是1，private是2，protected是4，static是8，final是16***\\n\\n2. getType：以Class形式返回类型\\n\\n3. getName：返回属性名\\n\\n#### 3.java.lang.reflect.Method 类\\n\\n1. getModifiers:以int形式返回修饰符\\n\\n   ***说明：默认修饰符是0，public是1，private是2，protected是4，static是8，final是16***\\n\\n2. getReturnType：以Class形式获取返回类型\\n\\n3. getName：返回方法名\\n\\n4. getParameterTypes：以Class[]返回参数类型数组\\n\\n#### 4. java.lang.reflect.Constructor 类\\n\\n1. getModifiers：以int形式返回修饰符\\n2. getName：返回构造器名（全类名）\\n3. getParameterTypes：以Class[]返回参数类型数组\\n\\n### 5. 反射爆破\\n\\n#### 1. 通过反射创建实例\\n\\n1. 调用类中的 public 修饰的无参构造器或者有参构造器\\n\\n2. Class 类相关方法\\n\\n   * newlnstance：调用类中的无参构造器，获取对应类的对象getConstructor(Class...clazz)：根据参数列表，获取对应的 public 构造器对象\\n   * getDecalaredConstructor(Class..clazz)：根据参数列表，获取对应的所有构造器对象\\n\\n3. Constructor 类相关方法\\n\\n   * setAccessible：暴破\\n\\n     ```java\\n     setAccessible(true);\\n     ```\\n\\n     ***<font color=\\\"red\\\">使用反射可以访问private构造器/方法/属性</font>***\\n\\n   * newlnstance(Object...obj)：调用构造器\\n\\n#### 2. 反射访问类中的属性\\n\\n1. 根据属性名获取Fieldi对象\\n\\n   ```java\\n   Field f = clazz对象.getDeclaredField(\\\"属性名\\\");\\n   ```\\n\\n2. 暴破\\n\\n   ```java\\n   f.setAccessible(true); //f是Field\\n   ```\\n\\n3. 访问\\n\\n   ```java\\n   f.set(o,值); //o表示对象\\n   f.get(o); \\n   ```\\n\\n   ***注意：如果是静态属性，则set和get中的参数o，\\t可以写成null***\\n\\n#### 3. 反射访问类中的方法\\n\\n1. 根据方法名和参数列表获取Method方法对象\\n\\n   ```java\\n   //得到本类指定的方法，xxx.class是指方法中的形参类型\\n   Method m = clazz.getDeclaredMethod(方法名，XX.class); \\n   ```\\n\\n2. 获取对象\\n\\n   ```java\\n   Object o = clazz.newlnstance();\\n   ```\\n\\n3. 暴破\\n\\n   ```java\\n   m.setAccessible(true);\\n   ```\\n\\n4. 访问\\n\\n   ```java\\n   //如果方法有返回值，那么统一返回Object，Object只是编译类型，运行类型还是返回类型\\n   Object returnValue = m.invoke(o,实参列表);\\n   ```\\n\\n   ***注意：如果是静态方法，则 invokel 的参数 o ,可以写成 null!***\\n\\n---\\n\\n## 🖇️JDBC 和 连接池\\n\\n### 1. 基本介绍\\n\\n1. JDBC为访问不同的数据库提供了统一的接口，为使用者屏蔽了细节问题。\\n2. Java程序员使用JDBC，可以连接任何提供了JDBC驱动程序的数据库系统，从而完成对数据库的各种操作。\\n\\n```java\\nClass.forName(\\\"com.mysql.cj.jdbc.Driver\\\"); //可以省略，但是不建议\\nConnection connection = DriverManager.getConnection(\\\"jdbc:mysql://localhost:3306/demo\\\", \\\"root\\\", \\\"lx*0+0-0\\\");\\nStatement statement = connection.createStatement();\\nString sql = \\\"insert into student values(006,\'lxuan\',\'男\',\'123456\')\\\";\\nstatement.executeUpdate(sql);\\nstatement.close();\\nconnection.close();\\n```\\n\\n### 2. Statement\\n\\n1. Statement对象用于执行静态SQL语句并返回其生成的结果的对象\\n2. 在连接建立后，需要对数据库进行访问，执行命名或是SQL语句，可以通过\\n   - Statement [存在SQL注入的问题]\\n   - ***PreparedStatement*** [预处理]\\n   - CallableStatement [存储过程]\\n3. Statementi对象执行SQL语句，存在SQL注入风险\\n4. SQL注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的SQL语句段或命令，恶意攻击数据库。\\n5. 要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了\\n\\n***<font color=\\\"red\\\">为避免产生 sql 注入问题，正常程序中我们不使用 Statement，而使用 PrepareStatement</font>***\\n\\n[JDBC API](assets/Java/JDBC%20API.md)\\n\\n### 3. 事务\\n\\n1. JDBC程序中当一个Connection对象创建时，***默认情况下是自动提交事务***，每次执行一个SQL语句时，如果执行成功，就会向数据库自动提交，而不能回滚。\\n2. JDBC程序中为了让多个SQL语句作为一个整体执行，需要使用事务\\n3. 调用`Connection的setAutoCommit(false)`可以取消自动提交事务\\n4. 在所有的SQL语句都成功执行后，调用 Connection 的 `commit()` 方法提交事务\\n5. 在其中某个操作失败或出现异常时，调用 Connection  的 `rollback()` 方法回滚事务\\n\\n### 4. 批处理\\n\\n1. 当需要成批插，入或者更新记录时。可以采用)va的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。\\n2. JDBC的批量处理语句包括下面方法：\\n   - `addBatch()`：添加需要批量处理的SQL语句或参数\\n   - `executeBatch()`：执行批量处理语句\\n   - `clearBatch()`：清空批处理包的语句\\n3. JDBC连接MySQL时，如果要使用批处理功能，请再 url 中加参数`?rewriteBatchedStatements = true`\\n4. 批处理往往和 PreparedStatement 一起搭配使用，可以既减少编译次数，又减少运行次数，效率大大提高\\n\\n### 5. 数据库连接池\\n\\n#### 5.1 基本介绍\\n\\n1. 预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。\\n2. 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序**重复使用**一个现有的数据库连接，而不是重新建立一个。\\n3. 当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列\\n\\n![数据库连接池](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0-3ef.png)\\n\\n#### 5.2 数据库连接池种类\\n\\n1. JDBC的数据库连接池使用javax.sql.DataSource来表示，DataSource 只是一个接口，该接口通常由第三方提供实现\\n2. **C3P0** 数据库连接池，速度相对较慢，稳定性不错（hibernate,spring）\\n3. DBCP 数据库连接池，速度相对c3p0较快，但不稳定\\n4. Proxool 数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点\\n5. BoneCP 数据库连接池，速度快\\n6. ***Druid***(德鲁伊)是阿里提供的数据库连接池，集DBCP、C3P0、Proxool 优点于一身的数据库连接池\\n\\n#### 5.3 C3P0\\n\\n1. 裸连\\n\\n    ```java\\n    ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();\\n    comboPooledDataSource.setDriverClass(\\\"com.mysql.cj.jdbc.Driver\\\");\\n    comboPooledDataSource.setJdbcUrl(\\\"jdbc:mysql://localhost:3306/demo\\\");\\n    comboPooledDataSource.setUser(\\\"root\\\");\\n    comboPooledDataSource.setPassword(\\\"lx*0+0-0\\\");\\n    //初始化连接数\\n    comboPooledDataSource.setInitialPoolSize(10);\\n    //最大连接数\\n    comboPooledDataSource.setMaxPoolSize(50);\\n    Connection connection = comboPooledDataSource.getConnection();\\n    System.out.println(\\\"连接成功\\\");\\n    connection.close();\\n    ```\\n\\n2. c3p0-config.xml\\n\\n    ```c3p0-config.xml\\n    <?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n    \\n    <c3p0-config>\\n       <!-- 使用默认的配置读取连接池对象 -->\\n       <default-config>\\n          <!--  连接参数 -->\\n          <property name=\\\"driverClass\\\">com.mysql.cj.jdbc.Driver</property>\\n          <property name=\\\"jdbcUrl\\\">jdbc:mysql:///bd2?serverTimezone=UTC&amp;useSSL=false</property>\\n          <property name=\\\"user\\\">root</property>\\n          <property name=\\\"password\\\">xxxxxxx</property>\\n    \\n          <!-- 连接池参数 -->\\n          <!--初始化申请的连接数量-->\\n          <property name=\\\"initialPoolSize\\\">5</property>\\n          <!--最大的连接数量(池子中最大的数量是10个)-->\\n          <property name=\\\"maxPoolSize\\\">10</property>\\n          <!--超时时间3000表示，如果出错，3s后报错-->\\n          <property name=\\\"checkoutTimeout\\\">3000</property>\\n       </default-config>\\n    \\n        <named-config name=\\\"mysql\\\">\\n            <!-- 配置数据库用户名 -->\\n            <property name=\\\"user\\\">root</property>\\n            <!-- 配置数据库密码 -->\\n            <property name=\\\"password\\\"></property>\\n            <!-- 配置数据库链接地址 -->\\n            <property name=\\\"jdbcUrl\\\">jdbc:mysql://localhost:3306/cdcol?useUnicode=true&amp;characterEncoding=UTF-8</property>\\n            <!-- 配置数据库驱动 -->\\n            <property name=\\\"driverClass\\\">com.mysql.jdbc.Driver</property>\\n            <!-- 数据库连接池一次性向数据库要多少个连接对象 -->\\n            <property name=\\\"acquireIncrement\\\">20</property>\\n            <!-- 初始化连接数 -->\\n            <property name=\\\"initialPoolSize\\\">10</property>\\n            <!-- 最小连接数 -->\\n            <property name=\\\"minPoolSize\\\">5</property>\\n            <!--连接池中保留的最大连接数。Default: 15 -->\\n            <property name=\\\"maxPoolSize\\\">30</property>\\n            <!--JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量。但由于预缓存的statements 属于单个connection而不是整个连接池。所以设置这个参数需要考虑到多方面的因素。如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default:0 -->\\n            <property name=\\\"maxStatements\\\">0</property>\\n            <!--maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数。Default: 0 -->\\n            <property name=\\\"maxStatementsPerConnection\\\">0</property>\\n            <!--c3p0是异步操作的，缓慢的JDBC操作通过帮助进程完成。扩展这些操作可以有效的提升性能 通过多线程实现多个操作同时被执行。Default:3 -->\\n            <property name=\\\"numHelperThreads\\\">3</property>\\n            <!--用户修改系统配置参数执行前最多等待300秒。Default: 300 -->\\n            <property name=\\\"propertyCycle\\\">3</property>\\n            <!-- 获取连接超时设置 默认是一直等待单位毫秒 -->\\n            <property name=\\\"checkoutTimeout\\\">1000</property>\\n            <!--每多少秒检查所有连接池中的空闲连接。Default: 0 -->\\n            <property name=\\\"idleConnectionTestPeriod\\\">3</property>\\n            <!--最大空闲时间,多少秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 -->\\n            <property name=\\\"maxIdleTime\\\">10</property>\\n            <!--配置连接的生存时间，超过这个时间的连接将由连接池自动断开丢弃掉。当然正在使用的连接不会马上断开，而是等待它close再断开。配置为0的时候则不会对连接的生存时间进行限制。 -->\\n            <property name=\\\"maxIdleTimeExcessConnections\\\">5</property>\\n            <!--两次连接中间隔时间，单位毫秒。Default: 1000 -->\\n            <property name=\\\"acquireRetryDelay\\\">1000</property>\\n            <!--c3p0将建一张名为Test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数那么属性preferredTestQuery将被忽略。你不能在这张Test表上进行任何操作，它将只供c3p0测试使用。Default: null -->\\n            <property name=\\\"automaticTestTable\\\">Test</property>\\n            <!-- 获取connnection时测试是否有效 -->\\n            <property name=\\\"testConnectionOnCheckin\\\">true</property>\\n        </named-config>\\n    </c3p0-config>\\n    ```\\n\\n#### 5.4 Druid(德鲁伊)\\n\\n```java\\nProperties properties = new Properties();\\nproperties.load(new FileReader(\\\"src\\\\\\\\druid.properties\\\"));\\nDataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\\nConnection connection = dataSource.getConnection();\\nSystem.out.println(\\\"Connection Success!\\\");\\nconnection.close();\\n```\\n\\n```druid.properties\\n# druid.properties文件的配置\\n#驱动加载\\ndriverClassName=com.mysql.cj.jdbc.Driver\\n#注册驱动\\nurl=jdbc:mysql://localhost:3306/demo?characterEncoding=utf-8\\n#连接数据库的用户名\\nusername=root\\n#连接数据库的密码\\npassword=lx*0+0-0\\n#属性类型的字符串，通过别名的方式配置扩展插件， 监控统计用的stat 日志用log4j 防御sql注入:wall\\nfilters=stat\\n#初始化时池中建立的物理连接个数。\\ninitialSize=2\\n#最大的可活跃的连接池数量\\nmaxActive=300\\n#获取连接时最大等待时间，单位毫秒，超过连接就会失效。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降， 如果需要可以通过配置useUnfairLock属性为true使用非公平锁。\\nmaxWait=60000\\n#连接回收器的运行周期时间，时间到了清理池中空闲的连接，testWhileIdle根据这个判断\\ntimeBetweenEvictionRunsMillis=60000\\nminEvictableIdleTimeMillis=300000\\n#用来检测连接是否有效的sql，要求是一个查询语句。\\nvalidationQuery=SELECT 1\\n#建议配置为true，不影响性能，并且保证安全性。 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis， 执行validationQuery检测连接是否有效。\\ntestWhileIdle=true\\n#申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。设置为false\\ntestOnBorrow=false\\n#归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能,设置为flase\\ntestOnReturn=false\\n#是否缓存preparedStatement，也就是PSCache。\\npoolPreparedStatements=false\\n#池中能够缓冲的preparedStatements语句数量\\nmaxPoolPreparedStatementPerConnectionSize=200\\n```\\n\\n### 6. Apache-DBUtils\\n\\njavaBean 一定要有无参构造器，底层使用了反射\\n\\n1. commons-dbutils是Apache组织提供的一个开源JDBC工具类库，它是对JDBC的封装，使用dbutils能极大简化jdbc编码的工作量\\n\\n* DbUtils类\\n  1. QueryRunner类：该类封装了SQL的执行，是线程安全的。可以实现增、删、改、查、批处理\\n  2. 使用QueryRunner类实现查询\\n  3. ResultSetHandler接口：该接口用于处理java.sql.ResultSet，将数据按要求转换为另一种形式\\n\\n```\\nArrayHandler：把结果集中的第一行数据转成对象数组。\\nArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。\\nBeanHandler：将结果集中的第一行数据封装到一个对应的)avaBean实例中。\\nBeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。\\nColumnListHandler：将结果集中某一列的数据存放到List中。\\nKeyedHandler(name)：将结果集中的每行数据都封装到Map里，再把这些map再存到一个map里，其key为指定的key。\\nMapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。\\nMapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List\\n```\\n\\n### 7. DAO和增删改查通用方法-BasicDao\\n\\n#### 基本说明\\n\\n1. DAO：data access object 数据访问对象\\n2. 这样的通用类，称为BasicDao，是专门和数据库交互的，即完成对数据库（表）的crud操作。\\n3. 在BaiscDao的基础上，实现一张表对应一个Dao，更好的完成功能，比如Customer表-Customer.java(javabean)-CustomerDao.java\\n\\n## 🖇️正则表达式\\n\\n1. `\\\\\\\\d`：表示任意一个数字\\n\\n   ```java\\n   String regstr \\\"(\\\\\\\\d\\\\\\\\d)(\\\\\\\\d\\\\\\\\d)\\\";\\n   //创建模式对象[即正则表达式对象]\\n   Pattern pattern = Pattern.compile(regstr);\\n   //创建匹配器matcher,按照正则表达式的规则去匹配content字符串\\n   Matcher matcher = pattern.matcher(content);\\n   ```\\n\\n2. `\\\\\\\\`：元字符-转义符：在我们使用正则表达式去检索某些特殊字符的时候，需要用到转义符号，否则检索不到结果，甚至会报错的。***<font color=\\\"red\\\">在Java的正则表达式中，两个`\\\\\\\\`代表其他语言中的一个`\\\\`</font>***，需要用到转义符号的字符有：`.*+()$/\\\\？[]^{}`\\n\\n3. `()`：在正则表达式中表示分组，`group(0)`表示匹配到的子字符串，`group(1)`表示子字符串终点第一组的子串...依次类推\\n\\n4. `matcher.find()`：根据指定的规则，定位满足规则的子字符串...\\n\\n5. `int groups[]`：找到后将子字符串的**开始索引**和**结束索引+1**记录到matcher的属性`int groups[]`中...\\n\\n6. `oldLast`：同时记录oldLast的值为子字符串的`结束索引+1`的值，即下次执行find时，就从oldLast的索引开始匹配\\n\\n### 1. 基本介绍\\n\\n如果要想灵活的运用正则表达式，必须了解其中各种元字符的功能，元字符从功能上大致分为：\\n\\n1. 限定符：用于指定其***前面的字符或组合项***连续出现多少次\\n\\n   | 符号  |              解释               |    示例     |                        解释                        |\\n   | :---: | :-----------------------------: | :---------: | :------------------------------------------------: |\\n   |   *   | 指定字符重复0次回或n次（无要求) |   (abc)*    |         仅包含任意个abc的字符串，等效于\\\\w*         |\\n   |   +   | 指定字符重复1次或n次（至少一次) |  m+(abc)*   |       以至少1个m开头，后接任意个abc的字符串        |\\n   |   ?   | 指定字符重复0次或1次（最多一次) |   m+abc?    |         以至少1个m开头，后接ab，c可有可无          |\\n   |  {n}  |         只能输入n个字符         |  [abcd]{3}  |       由abcd中字母组成的任意长度为3的字符串        |\\n   | {n,}  |         指定至少n个匹配         | [abcd]{3,}  |     由abcd中字母组成的任意长度不小于3的字符串      |\\n   | {n,m} |   指定至少n个但不多于m个匹配    | [abcd]{3,5} | 由abcd中字母组成的任意长度不小于3，不大于5的字符串 |\\n\\n   |  ?   | 当此字符紧随任何其他限定符(*、+、？、{n}、{n,}、{n,m})之后时，匹配模式是\\\"非贪心的。\\\"非贪心的\\\"模式匹配搜索到的、尽可能短的字符串，而默认的\\\"贪心的\\\"模式匹配搜索到的、尽可能长的字符串。例如，在字符串\\\"oooo\\\"中，\\\"o+?\\\"只匹配单个\\\"o”,而\\\"o+\\\"匹配所有\\\"o\\\"。 |\\n   | :--: | :----------------------------------------------------------: |\\n\\n   ***Java 默认是贪婪匹配，{n,m}优先匹配 m 个***\\n\\n2. 选择匹配符\\n\\n   | 符号 |            解释            |  示例  |   解释   |\\n   | :--: | :------------------------: | :----: | :------: |\\n   |  \\\\|  | 匹配“\\\\|”之前或之后的表达式 | ab\\\\|cd | ad或者cd |\\n\\n3. 分组组合和反向引用符\\n\\n   | 常用分组构造形式  |                             说明                             |\\n   | :---------------: | :----------------------------------------------------------: |\\n   |     (pattern)     | 非命名捕获。捕获匹配的子字符串。编号为零的第一个捕获是由整个正则表达式模式匹配的文本，其它捕获结果则根据左括号的顺序从1开始自动编号。 |\\n   | (?\\\\<name>pattern) | 命名捕获。将匹配的子字符串捕获到一个组名称或编号名称中。用于name的字符串不能包含任何标点符号，并且不能以数字开头。可以使用单引号替代尖括号，例如(?\'name\') |\\n   |    (?:pattern)    | 匹配pattern但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用\\\"or\\\"字符(\\\\|)组合模式部件的情况很有用。<br/>例如，`industr(?:y|ies)`是比`industry|industries`更经济的表达式。 |\\n   |    (?=pattern)    | 它是一个非捕获匹配。例如，`Windows(?=95|98|NT|2000)`匹配`Windows 2000`中的`Windows`，但不匹配`Windows 3.1`中的`Windows`。 |\\n   |    (?!pattern)    | 该表达式匹配不处于匹配pattern的字符串的起始点的搜索字符串。它是一个非捕获匹配。例如，`Windows(?!95|98|NT|2000)`匹配`Windows 3.1`中的`Windows`，但不匹配`Windows 2000`中的`Windows`。 |\\n\\n3. 特殊字符\\n\\n4. 字符匹配符\\n\\n   | 符号 |                             解释                             |    示例    |                             解释                             |\\n   | :--: | :----------------------------------------------------------: | :--------: | :----------------------------------------------------------: |\\n   | [ ]  |                       可接收的字符列表                       |   [abcd]   |                寻找a、b、c、d中的任意一个字符                |\\n   | [^]  |                       不接收的字符列表                       |  [^abcd]   |    寻找除了a、b、c、d中的任意一个字符，包括数字和特殊字符    |\\n   |  -   |                            连字符                            |    A-Z     |                       任意单个大写字母                       |\\n   |  .   |   匹配除 \\\\n 以外的任何字符，如果需要匹配.自身，需要使用\\\\\\\\.   |   a...b    |     以a开头，b结尾，中间包括3个任意字符的长度为5的字符串     |\\n   |  \\\\d  |             匹配单个数字字符，相当于<br />[0-9]              | \\\\d{3}(\\\\d)? | 包含3个或4个数字的字符串<br />**?的意思是：?前的一个或一组符号可能有也可能没有** |\\n   |  \\\\D  |           匹配单个非数字字符，相当于<br />[\\\\^0-9]            |  \\\\D(\\\\d)*   |   以单个非数字字符开头，后接任意个数字（任意个可以为0个）    |\\n   |  \\\\w  | 匹配单个数字、大小写字母、下划线字符相当于<br />[0-9a-zA-Z]  | \\\\d{3}\\\\w{4} |         以3个数字字符开头的长度为7的数字和字母字符串         |\\n   |  \\\\W  | 匹配单个非数字、大小写字母、下划线字符，相当于<br />\\\\[^0-9a-zA-Z] |  \\\\W+\\\\d{2}  | 以至少1个非数字字母字符开头，2个数字字符结尾的字符串<br />**+指的是：+号前的一个或一组符号至少存在一次** |\\n   |  \\\\s  |              匹配任何空白字符（空格，制表符等）              |            |                                                              |\\n   |  \\\\S  |                     匹配任何非空空白字符                     |            |                                                              |\\n\\n5. 定位符\\n\\n   | 符号 |          解释          |       示例       |                             解释                             |\\n   | :--: | :--------------------: | :--------------: | :----------------------------------------------------------: |\\n   |  ^   |      指定起始字符      |  \\\\^[0-9]+[a-z]*  |        以至少1个数字开头，后接任意个小写字母的字符串         |\\n   |  \\\\$   |      指定结束字符      | \\\\^[0-9]\\\\\\\\-[a-z]+$ | 以1个数字开头后接连字符”-”，并以至少1个小写字母结尾的字符串  |\\n   |  \\\\b  |  匹配目标字符串的边界  |     lxuan\\\\b      | 这里说的字符串的边界指的是子串间有空格，或者是目标字符串的结束位置 |\\n   |  \\\\B  | 匹配目标字符串的非边界 |     lxuan\\\\\\\\B     |                      和b的含义刚刚相反                       |\\n\\n\\n### 2. 分组、捕获、反向引用\\n\\n1. 分组\\n\\n   我们可以用圆括号组成一个比较复杂的匹配模式，那么一个圆括号的部分我们可以看作是一个子表达式/一个分组。\\n\\n2. 捕获\\n\\n   把正则表达式中子表达式/分组匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用，从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。组0代表的是整个正则式\\n\\n3. 反向引用\\n\\n   圆括号的内容被捕获后，可以在这个括号后被使用，从而写出一个比较实用的匹配模式，这个我们称为反向引用，这种引用既可以是在正则表达式内部，也可以是在正则表达式外部，内部反向引用`\\\\\\\\分组号`，外部反向引用`$分组号`\\n\\n   ```正则\\n   1.要匹配两个连续的相同数字：(\\\\d)\\\\1\\n   2.要匹配五个连续的相同数字：(\\\\d)\\\\1{4}\\n   3.要匹配个位与干位相同，十位与百位相同的数5225,1551：(\\\\d)(\\\\d)\\\\2\\\\1\\n   ```\\n\\n\\n### 3. 正则表达式三个常用类\\n\\n1. Pattern类\\n\\n   pattern对象是一个正则表达式对象。Pattern类没有公共构造方法。要创建一个Pattern对象，调用其公共静态方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数，比如：Pattern r = Pattern.compile(pattern);\\n\\n   `Pattern.matches()`：是否为整体匹配\\n\\n2. Matcher类\\n\\n   Matcher对象是对输入字符串进行解释和匹配的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象\\n\\n3. PatternSyntaxException\\n\\n   PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误。\\n\\n---\",\"articleCover\":\"\",\"articleTitle\":\"Java 中级\",\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '152.69.196.109', '美国', '2022-10-11 19:25:52', NULL);
INSERT INTO `tb_operation_log` VALUES (1274, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 📙Java中级\\n\\n## 🖇️原生的equals和hashCode方法。\\n\\n1. **[equals](https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020)**\\n\\n   Object 中的 equals 方法和 == 是相同的，如下代码，比较的都是内存地址。\\n\\n   ```java\\n    public boolean equals(Object obj) {\\n      return (this == obj);\\n   }\\n   ```\\n\\n2. **hashCode**\\n\\n    原生的hashCode方法返回的是一个根据内存地址换算出来的一个值。它的定义是这样的：\\n\\n   ```java\\n   public native int hashCode();\\n   ```\\n\\n   可见这是一个 native 方法，因为 native 方法是并不是由 Java 语言来实现的，所以这个方法的定义中也没有具体的实现。根据 jdk 文档，该方法的实现一般是**“通过将该对象的内部地址转换成一个整数来实现的”**，这个返回值就作为该对象的哈希码值返回。\\n\\n3. **总结**\\n\\n    所以，在不重写equals和hashCode的情况下：\\n\\n   （1）两个对象如果equals相等的情况下，hashCode一定相等。因为equals默认是用“==”来比较，比较的是内存地址，而hashCode是根据内存地址得到哈希值，内存地址一样的话，得到的哈希值肯定是一样的。\\n\\n   （2）两个对象hashCode相等的情况下，equals不一定相等。这是为什么呢，首先我们来说一下哈希表，哈希表结合了直接寻址和链式寻址两个方式，简单来说就是先计算出要插入的数据的哈希值，然后插入到相应的分组当中去，因为哈希函数返回的是一个int类型，所以最多也就只有2的32次方个分组，对象多了，总有分组不够用的时候，这个时候，不同的对象就会产生相同的哈希值，也就是哈希冲突现象，此时就可以通过链地址法把分组用链表来代替，同一个链表上的对象hashCode肯定是相等的，因为是不同的对象，所以内存地址不同，所以他们的equals肯定是不相等的。这的hashCode就相当于是人名，equals就相当于身份证号，同名的人多了去了，但都不是同一个人。\\n\\n---\\n\\n## 🖇️ 类变量和类方法\\n\\n### 1. 类变量\\n\\n类变量也叫静态变量，被 static 修饰的变量会被所有对象实例共享。\\n\\n```java\\npublic static int count = 0;\\n```\\n\\n在jdk8以前，静态变量是放在方法区里的静态域，jdk8以后静态变量是放在堆里的，保存在class实例的尾部。\\n\\n---\\n\\n1. static被所有对象共享，任何一个对象访问的都是同一个值，修改的也是同一个变量。\\n\\n2. static类变量，在类加载的时候就生成了，所以即使没有对象实例也可以访问，如：\\n\\n   ```java\\n   System.out.println(类名.静态变量);\\n   ```\\n\\n   \\n\\n### 2. 类方法\\n\\n类方法与类变量同理\\n\\n我们在调用 Java 中的 Math 工具时，从来都不需要创建一个 Math 对象，就是因为 Math 类中的方法都是静态方法。\\n\\n因此我们可以将静态方法作为一种工具方法，放在工具类中随时调用。\\n\\n---\\n\\n1. 类方法中不允许使用和对象有关的关键字，比如 this 和 super ，普通方法可以。\\n2. 类方法中**只能访问类变量和类方法**，普通方法都可以访问。\\n\\n### 3. 理解 main 方法语法\\n\\n解释 main 方法的形式：\\n\\n```java\\npublic static vod main(String[] ages){}\\n```\\n\\n1. main 方法是虚拟机调用\\n\\n2. Java虚拟机西药调用类的 main() 方法，所以该方法的访问权限必须是public\\n\\n3. java虚拟机在执行 main() 方法时不必创建对象，所以该方法必须是 static \\n\\n4. 该方法接收 String 类型的数组参数，该数组中保存执行 java 命令时传递给所运行的类的参数\\n\\n5. java 源文件执行的方式：java 类名.java 参数1 参数2 参数3\\n\\n   ```java\\n   java hello.java qwe asd zxc\\n   ```\\n\\n\\n\\n## 🖇️代码块\\n\\n1. 代码块主要解决构造器中重复出现的语句。\\n2. 代码块调用的顺序优先于构造器。\\n3. 静态代码块只能调用静态属性和静态方法\\n4. 普通代码块都能调用\\n\\nstatic 代码块也叫静态代码块，作用就是对类进行初始化，伴随着类的加载而执行，且**只会执行一次**\\n\\n类什么时候被加载？\\n\\n* 创建对象实例（new）的时候\\n* 创建子类对象实例，父类也会被加载\\n* 实用类的静态成员时（类方法，类属性）\\n\\n普通代码块每创建一次就执行一次\\n\\n\\n\\n## 🖇️单例设计模式\\n\\n一个类只能同时存在一个实例（对象）\\n\\n1. 饿汉式\\n   1. 构造器私有化\\n   2. 类的内部创建实例（对象）\\n   3. 创建一个公共的 static 方法，返回该实例（对象）\\n2. 懒汉式\\n   1. （与上相同）\\n   2. 与饿汉式不同的是，懒汉式在用户不调用的时候不会加载对象\\n\\n\\n\\n## 🖇️final 关键字\\n\\n1. 定义：\\n\\n   final 修饰的属性又叫**常量**，一般用大写来命名\\n\\n2. 使用 final 的注意事项\\n   1. final 修饰类的时候，**<font color=\\\"red\\\">类不能被继承</font>**\\n   2. final 修饰方法的时候，父类的方法不能被子类**重写/覆盖**（override）\\n   3. final 修饰属性值的时候，**属性值不能被修改**\\n   4. final 修饰的属性在定义时必须赋值，之后就不能再修改（赋值位置：定义时、代码块中、构造器中）。如果 final 修饰的属性是静态的，则初始化位置只能是在定义时，代码块中（不能在构造器中）\\n   5. 虽然被 final 修饰的方法不能被重写，但是可以被继承和使用\\n   6. 如果一个类已经被 final 修饰，那类中的方法就不用 final 修饰了\\n   7. final 不能被修饰构造器\\n   8. final 和 static 搭配使用效率更高，底层代码做了优化（使用 static 会加载整个类，但是加上 final 就不会加载整个类了）\\n\\n\\n\\n## 🖇️ 抽象类\\n\\n1. 抽象类不一定要抽象方法，抽象方法必须为抽象类\\n\\n2. 抽象类不能被实例化\\n\\n3.  abstract 只能修饰类和方法，不能修饰属性和其他\\n\\n4. 如果一个类继承了抽=抽象类，则它必须实现抽象类中的所有方法，除非它自己也声明为抽象类\\n\\n5. 抽象方法不能使用 private、static 和  final 来修饰，因为这些修饰词都和重写相违背\\n\\n   > static：\\n   >\\n   > 被 static修饰的方法在和没有 static 修饰的方法在内存中的位置不一样。。\\n   > 被static修饰的方法属于类，是类自己的东西，不是给子类来继承的。就好像类是个房子，它的静态方法是里面的一面墙，每个人都可已在墙上画画，你画的东西别人也能看到，属于大家共同使用。你想通过继承来把这面墙拿走也不可能拿走，他是从属于类的。\\n   > 而抽象方法本身没有实现，就是用来给子类继承，存在内存中的位置也不是一样的。用 static修饰就不能被子类继承了。同样 你可以这么理解。\\n   > 抽象方法相当于房子中地上的白纸，继承了它的子类就必须从地上拿一张白纸回去画画，你想怎么画怎么画。\\n   > 一个相当于墙，你是拿不走的。一个相当于地上的纸，而且规定你实现了就必须拿走。\\n   >\\n   > final：\\n   >\\n   > final修饰的类不可继承，而抽象类本事是不能被实例化的，是需要让子类去继承，如果父类使用了 final 修饰符修饰方法，子类继承后，也无法重写该方法。\\n   >\\n   > private：\\n   >\\n   > private的访问权限是本类中，子类继承父类后，是无法方法 private 修饰的方法的。\\n\\n访问修饰符 abstract 类名{}\\n\\n\\n\\n## 🖇️模板设计模式\\n\\n1. 共同代码模板，不同代码抽象\\n\\n\\n\\n## 🖇️接口\\n\\n1. jdk8之前，在接口中，抽象方法可以省略 abstract 关键字，也就是说所有方法都是抽象方法，都不能有方法体\\n\\n2. jdk8后，接口中可以有默认方法，但是需要用 default 关键字修饰\\n\\n   ```java\\n   public default void AA(){}\\n   ```\\n\\n3. 也可以有静态方法\\n\\n   ```java\\n   public static void BB(){}\\n   ```\\n\\n4. 一个类可以实现多个接口\\n\\n   ```java\\n   class AA implements BB,CC,DD{}\\n   ```\\n\\n5. 接口中的属性只能是 final 的，而且是 public static final 修饰符\\n\\n6. 接口不能继承其它类，但是可以继承其它接口\\n\\n7. 接口的修饰符只能是 public 或者默认的，这点和类的修饰符是一样的\\n\\n### 1. 接口和继承\\n\\n1. 接口和继承解决的问题不同\\n\\n   接口的价值主要在于：设计、规定好各种方法，让其它类能够实现这些方法（功能）\\n\\n   继承的价值主要在于：解决代码的**复用性**和**可维护性**\\n\\n2. 接口比继承更加灵活\\n\\n   继承是满足 is - a 的关系\\n\\n   接口只需满足 like - a 的关系\\n\\n3. 接口在一定程度上实现代码解耦\\n\\n---\\n\\n## 🖇️四种内部类\\n\\n 类的五大成员：属性、方法、构造器、代码块、内部类\\n\\n内部类的最大特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系\\n\\n***定义在外部类局部位置上（比如方法内）:***\\n\\n### 1. 局部内部类（有类名）\\n\\n1. 定义在方法中 / 代码块中\\n2. 可以直接访问定义在外部类的所有成员（属性和方法），包含私有的\\n3. 不能添加访问修饰符，但是可以私用 final 修饰，被 final 修饰后就可以不被继承\\n4. 作用域：仅仅在定义它的方法或代码块中\\n5. 如果外部类和局部内部类的成员重名时，遵守就近原则。在此基础上访问外部成员可以使用 **`外部类名.this.成员`** 去访问，因为 **`外部类名.this`** 的意思就是访问创建了局部内部类这个方法的对象。\\n\\n### 2. 匿名内部类（没有类名）<font color = \\\"red\\\">重点！！</font>\\n\\n1. 定义在方法中 / 代码块中，并且没有类名\\n\\n2. 使用如下：\\n\\n   ```java\\n   AA aa = new AA(\\\"name\\\"){\\n     @Override\\n     public void A(){\\n     \\t....\\n     }\\n   };\\n   aa.A();\\n   \\n   或者\\n   \\n   new AA(){\\n     @Override\\n     public void B(){\\n     \\t...\\n     }\\n   }.B();\\n   ```\\n\\n   匿名内部类没有类名，(\\\"name\\\")这个形参列表是传给类的构造器的，当然也可以重写构造器。\\n\\n3. 可以访问外部类的所有成员，包含私有\\n\\n4. 不能添加访问修饰符，因为他的地位就是一个局部变量\\n\\n5. 作用域：定义它的方法或者代码块中\\n\\n***定义在外部类的成员位置上：***\\n\\n### 3. 成员内部类（没用 static 修饰）\\n\\n1. 直接定义在外部类的成员位置，而不在方法或代码块中，并且没有 static 修饰\\n2. 可以直接访问外部类的所有成员，包括私有\\n3. 可以添加任意访问修饰符（public、protected、默认、private），因为它本身就是一个成员\\n4. 使用如下：\\n\\n    ```java\\n    第一种方式\\n    main{\\n      Outside outside = new Outside();\\n      Outdise.memberInsideClass memberinsideclass = outside.new memberInsideClass();\\n    }\\n    \\n    第二种方式\\n    main{\\n      Outside.MemberInsideClass menberInsideClass = new Outside().getMenberInsideClass();\\n      memberInsideClass.方法();\\n    }\\n    Outside{\\n      public MemberInsideClass getMenberInsideClass() {\\n        return new MemberInsideClass();\\n      }\\n    }  \\n    ```\\n\\n### 4. 静态内部类（使用 static 修饰）\\n\\n1. 成员内部类添加 static 修饰符\\n2. 可以访问外部类所有静态成员，但不能访问非静态\\n3. 可以添加任意访问修饰符（public、protected、默认、private），因为它本身就是一个成员\\n\\n---\\n\\n## 🖇️枚举和注解 - annotate\\n\\n### 1 自定义枚举类\\n\\n1. 构造器**私有化**：防止被直接 new\\n2. 去掉 set 方法：防止属性被修改\\n3. 在外部类直接创建固定的对象 `public static final 类名 对象名 = new 类名();`\\n\\n### 2. Enum 修饰的枚举类\\n\\n1. 使用 enum 关键字 替代 class，默认继承 Enum 类，而且是一个 final 类\\n2. 将 `public static final 类名 对象名 = new 类名();` 简化成 `对象名();` 形式\\n3. 如果有多个对象使用，使用**逗号**间隔，最后有一个**分号**结尾，如： `SPRING(\\\"春天\\\",\\\"温暖\\\"),WINTER(\\\"冬天\\\",\\\"寒冷\\\");`\\n4. 枚举对象必须放在枚举类的行首\\n5. 如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略\\n\\n#### 2.1 Enum 方法\\n\\n1. 返回该枚举对象的对象名\\n\\n   ```java\\n   name()\\n   ```\\n\\n2. 返回该枚举对象的次序\\n\\n   ```java\\n   ordinal()\\n   ```\\n\\n3. 返回当前枚举类中的所有常量\\n\\n   ```java\\n   values()\\n   ```\\n\\n4. 将字符串转换为枚举对象，要求字符串必须为已有常量名\\n\\n   ```java\\n   valueOf()\\n   ```\\n\\n5. 比较两个枚举常量，比较的是 `ordinal()`\\n\\n   ```java\\n   compareTo()\\n   ```\\n\\n\\n#### 2.2 Enum 实现接口\\n\\n1. 使用 enum 关键字后，就不能继承其他类了，因为已经继承了 enum 类，而 java 是单继承机制。\\n2. 但是可以实现接口\\n\\n### 3. 注解\\n\\n1. 注解也被称之为元数据，用于修饰解释（包、类、方法、属性、构造器、局部变量）等数据信息\\n2. 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息\\n3. @Target 是修饰注解的注解，称为元注解\\n\\n#### 3.1 三个基本的 Annotation：\\n\\n1. @Override：限定某个方法，是重写父类方法\\n2. @Deprecated：用于表示某个程序元素（类，方法）已过时\\n3. @SuppressWarnings：抑制编辑器警告\\n\\n#### 3.2 常用的注解\\n\\n1. **@Data** ： 注在类上，提供类的get、set、equals、hashCode、canEqual、toString方法\\n2. **@AllArgsConstructor** ： 注在类上，提供类的**全参构造**\\n3. **@NoArgsConstructor** ： 注在类上，提供类的无参构造\\n4. @Setter ： 注在属性上，提供 set 方法\\n5. @Getter ： 注在属性上，提供 get 方法\\n6. @EqualsAndHashCode ： 注在类上，提供对应的 equals 和 hashCode 方法\\n7. @Log4j/@Slf4j ： 注在类上，提供对的 Logger 对象，变量名为 log\\n\\n---\\n\\n## 🖇️异常 - Exception\\n\\n### 1. 异常的概念\\n\\n```java\\nint a = 10;\\nint b = 0;\\nint c = a / b;\\n```\\n\\n如上代码，如果执行到第三行程序就会报错（ArithmeticException），导致整个程序的中断，这显然是不合理的，所以需要**异常处理机制**来解决该问题，如下。\\n\\n```java\\ntry{\\n  int c = num1 /num2;\\n}catch (Exception e){\\n  e.printStackTrace();\\n}\\n```\\n\\n**程序执行过程中所发生的异常事件可分为两大类：**\\n\\n1. Error（错误）：Java 虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError[栈溢出] 和 OOM(out of memory)，Error是严重错误，程序会崩溃\\n2. Exceptio：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等，Exception分为两大类：**运行时异常**和**编译时异常**。（如上述例子 ArithmeticException 就属于运行时异常，写代码时编译器不会报错）\\n\\n### 2. 常见的异常\\n\\n1. NullPointerException：空指针异常\\n2. ArithmeticException：数学运算异常\\n3. ArrayIndexOutOfBoundsException：数组下标越界异常\\n4. ClassCastException：类型转换异常\\n5. NumberFormatException：数字格式不正确异常\\n\\n### 3. 异常处理❗\\n\\n#### 3.1 异常处理方式\\n\\n1. **try-catch-finally**：程序员在代码中捕获发生的异常，自行处理\\n\\n   ```java\\n   try {\\n     //代码可能有异常\\n   } catch (Exception e) {\\n     // 捕获到异常\\n     // 1. 当异常发生时\\n     // 2. 系统将异常封装成Exception对象e, 传递给catch\\n     // 3 得到异常对象后，程序员，自己处理\\n     // 4 注意，如果没有发生异常catch代码块不执行\\n   } finally {\\n     // 1. 不管try代码块是否有异常发生，始终要执行finally\\n     // 2. 所以，通常将释放资源的代码，放在finally\\n   }\\n   ```\\n\\n   可以有**多个 catch 语句**，捕获不同的异常（进行不同的业务处理），要求**父类异常在后，子类异常在前。**比如（Exception 在后，NullPointerException 在前），如果发生异常，只会匹配前面的 catch，如下。\\n\\n   ```java\\n   try {\\n     //代码\\n   } catch (NullPointerException e) {\\n   } catch (Exception e) {\\n   } finally {\\n   }\\n   ```\\n\\n   也可以只使用 **try-finally**，相当于没有捕获异常，无论是否发生异常 finally 都要执行，**catch 即使是return，执行完成后也不会返回，而是执行 finally 后再返回**\\n\\n   ```java\\n   try {\\n     //代码\\n   } finally { //总是执行\\n     //代码\\n   }\\n   ```\\n\\n   **<font color = \\\"red\\\">注意：如果 catch 中有 return，finally 没有 return，则将 catch 的返回值保存在临时变量中，并不会受到 finally 的影响</font>**\\n\\n2. **throws**：将发生的异常抛出，交给调查者（方法）来处理，最顶级的处理者就是JVM\\n\\n   ![[assets/Java/throws机制处理图.png]]\\n\\n   如下代码，将错误抛给 Exception 处理，或者也可以用一个异常列表代替 `FileNotFoundException,NullPointerException,ArithmeticException`\\n\\n   ```java\\n   public void f1() throws Exception{\\n     FileInputStream fis = new FileInputStream(\\\"d://a.txt\\\");\\n   }\\n   ```\\n\\n\\n**<font color = \\\"red\\\">注意：</font>**\\n\\n**<font color = \\\"red\\\">1. 对于编译时异常，程序必须处理，比如：try-catch 和 throws </font>**\\n\\n**<font color = \\\"red\\\">2. 对于运行时异常，程序中如果没有处理，默认就是 throws </font>**\\n\\n**<font color = \\\"red\\\">3. 子类重写父类方法时，对抛出的异常有所规定：子类重写的方法，抛出的异常要么和父类保持一致，要么为父类抛出异常的子类型 </font>**\\n\\n**<font color = \\\"red\\\">4. 如果有 try-catch 就不用 throws </font>**\\n\\n### 4. 自定义异常\\n\\n自定义异常的步骤：\\n\\n1. 定义类：自定义异常类名（程序员自己写）继承 Exception 或 RuntimeException\\n\\n2. 如果继承 Exception，属于编译异常\\n\\n3. 如果继承 RuntimeException，属于运行异常（一般来说，继承 RuntimeException)\\n\\n```java\\n//自定义异常\\nclass xxxException extends RuntimeException {\\n    public xxxException(String message) { //构造器\\n        super(message);\\n    }\\n}\\n//使用\\npublic class Exception_ {\\n    public static void main(String[] args) {\\n        throw new xxxException(\\\"发生异常\\\");\\n    }\\n}\\n```\\n\\n**<font color = \\\"red\\\">一般情况下，我们自定义异常是继承 RuntimeException。也就是把自定义异常做成运行时异常，可以使用默认的处理机制，比较方便 </font>**\\n\\n### 5. throw 和 throws 的对比\\n\\n|        | 意义                     | 位置       | 后面跟的的东西 |\\n| ------ | ------------------------ | ---------- | -------------- |\\n| throws | 异常处理的一种方式       | 方法声明处 | 异常类型       |\\n| throw  | 手动生成异常对象的关键字 | 方法体中   | 异常对象       |\\n\\n### 6. 异常体系图❗\\n\\n![异常体系图](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE-69c.png)\\n\\n---\\n\\n## 🖇️包装类（Wrapper）\\n\\n### 1. 包装类的分类\\n\\n1. 针对八种基本数据类型相应的引用类型一包装类\\n2. **有了类的特点，就可以调用类中的方法**\\n\\n| 基本数据类型 |   包装类    |\\n| :----------: | :---------: |\\n|   boolean    |   Boolean   |\\n|     char     |  Character  |\\n|     byte     |  ==Byte==   |\\n|    short     |  ==Short==  |\\n|     int      | ==Integer== |\\n|     long     |  ==Long==   |\\n|    float     |  ==Float==  |\\n|    double    | ==Double==  |\\n\\n其中标记的六个包装类的父类是 Number（继承 Object），而 Boolean 和 Character 则直接继承 Object\\n\\n```java\\nInteger i = 200;\\nInteger i2 = 200;\\ni==i2 //false，不同对象\\n  \\nInteger i = 20;\\nInteger i2 = 20;\\ni==i2 //true，-128~127不会生成对象\\n```\\n\\n### 2. 包装类和基本数据类型的转换\\n\\n```java\\n//jdk5 之前的转换方式\\nint a = 0;\\nInteger integer = Integer.valueOf(a);\\nint b = integer.intValue();\\n\\n//jdk5 之后的转换方式\\nint a1 = 0;\\nInteger integer1 = a1;\\nint b1 = integer1;\\n```\\n\\n**<font color = \\\"red\\\">其本质也是 jdk5 之前的方式，只不过简化了而已</font>**\\n\\n#### 2.1 包装类和 String 类型的相互转换\\n\\n1. 包装类（Integer） -> String\\n\\n   ```java\\n   //包装类（Integer） -> String\\n   Integer a = 100;\\n   //方式一\\n   String str1 = a + \\\"\\\";\\n   //方式二\\n   String str2 = a.toString();\\n   //方式三\\n   String str3 = String.valueOf(a);\\n\\n2. String -> 包装类（Integer）\\n\\n   ```java\\n   //String -> 包装类（Integer）\\n   String str4 = \\\"123\\\";\\n   //方法一\\n   Integer a1 = Integer.parseInt(str4); //自动装箱\\n   //方法二\\n   Integer a2 = new Integer(str4); //构造器\\n\\n### 3. 包装类方法\\n\\n```java\\nSystem.out.printIn(Integer.MIN_VALUE);//返回最小值\\nSystem.out.println(Integer.MAX_VALUI);//返回最大值\\n  \\nSystem.out.println(Character.isDigit(\'a\'));//判断是不是数字\\nSystem.out.println(Character.isLetter(\'a\'));//判断是不是字母\\nSystem.out.printIn(Character.isUpperCase(\'a\'));//判断是不是大写\\nSystem.out.println(Character.isLowerCase(\'a\'));//判断是不是小写\\n                   \\nSystem.out.println(Character.isWhitespace(\'a\'));//判断是不是空格\\nSystem.out.println(Character.toUpperCase(\'a\'));//转成大写\\nSystem.out.println(Character.toLowerCase(\'A\'));//转成小写\\n```\\n\\n### 4. int[] 和 Integer[] 的转换\\n\\n```java\\n//int数组转Integer数组\\nInteger newNums[] = Arrays.stream(nums).boxed().toArray(Integer[]::new);\\n//Integer数组转int数组\\nint[] num = Arrays.stream(newNums).mapToInt(Integer::valueOf).toArray();\\n```\\n\\n\\n\\n---\\n\\n## 🖇️String 类\\n\\n1. String对象用于保存字符串，也就是一组字符序列\\n\\n2. 字符串常量对象是用双引号括起的字符序列。例如：\\\"你好\\\"、\\\"1297\\\"、\\\"boy\\\" 等\\n\\n3. 字符串的字符使用 Unicode 字符编码，一个字符（不区分字母还是汉字）占两个字节。\\n\\n   ==char 占两个字节==\\n\\n4. String 有属性 private final char[] **value**; 用于存放字符串内容，==其地址不可修改==\\n\\n5. String 类实现了接口  Serializable（String 可以串行化：可以在网络传输）\\n\\n6. String 类实现了接口  Comparable（String 对象可以比较大小）\\n\\n### 1. 两种创建 String 对象的区别\\n\\n1. 方式一：直接赋值 String a = \\\"a\\\";\\n\\n   先从常量池查看是否有 \\\"a\\\" 数据空间，如果有，直接指向；\\n\\n   如果没有则重新创建，然后指向；\\n\\n   a 最终指向的是常量池的空间地址\\n\\n2. 方式二：调用构造器 String b = new String(\\\"b\\\");\\n\\n   先在堆中创建空间，里面维护了 value 属性，指向常量池的 \\\"b\\\" 空间；\\n\\n   如果常量池没有 \\\"b\\\"，重新创建；\\n\\n   如果有，直接通过value指向。最终指向的是堆中的空间地址\\n\\n画出两种方式的内存分布图\\n\\n![String 内存分布图](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/String%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%9B%BE-4ad.png)\\n\\n### 2. String 对象特性❗\\n\\n1. String 是一个 final 类，代表不可变的字符序列\\n\\n   ```java\\n   // 以下语句创建了几个对象\\n   String s1 = \\\"hello\\\";\\n   s1 = \\\"haha\\\";\\n   // 答：两个\\n   ```\\n\\n   **<font color = \\\"red\\\">一个字符串一旦被分配，其内容是不可变的，只能重新创建一个新的字符串，赋一个新的地址</font>**\\n\\n   ---\\n\\n   ```java\\n   // 以下语句创建了几个对象\\n   String s2 = \\\"hello\\\" + \\\"abc\\\";\\n   // 答：一个\\n   // 优化等价于 String s2 = \\\"helloabc\\\";\\n   ```\\n\\n   ---\\n\\n   ```java\\n   // 以下语句创建了几个对象\\n   String a=\\\"hello\\\";\\n   String b=\\\"abc\\\";\\n   String c=a+b;\\n   // 答：三个\\n   // 1. 先创建一个 StringBuilder sb = StringBuilder()\\n   // 2. 执行sb.append(\\\"hello\\\"); \\n   // 3. sb.append(\\\"abc\\\");\\n   // 4. String c=sb.tostring()\\n   // 最后其实c是指向堆中的对象(String)value[] -> 池中 \\\"helloabc\\\"\\n   ```\\n\\n2. String 中的 == 和 equals\\n\\n   == 是用来判断地址是否相同\\n\\n   equals 的父类是 Object，在 String 中重写，用于判断字符串内容是否相等\\n\\n3. String 类常见方法\\n\\n   ```java\\n   equals //区分大小写，判断内容是否相等\\n   equalslgnoreCase //忽略大小写的判断内容是否相等\\n   length //获取字符的个数，字符串的长度\\n   indexOf //获取字符在字符串中第1次出现的索引，索引从0开始，如果找不到，返回-1\\n   lastIndexOf //获取字符在字符串中最后1次出现的索引，索引从0开始，如找不到，返回-1\\n   substring //截取指定范围的子串\\n   trim //去前后空格\\n   charAt //获取某索引处的字符，注意不能使用Str[index]这种方式\\n   replaceall //替换某处子字符串，可以使用正则表达式\\n   matches //验证子字符串是否按照某种要求，使用正则表达式\\n   split //分割字符串，\\n   ```\\n\\n### 3. StringBuffer❗\\n\\n1. 代表可变的字符序列，可以对字符串内容进行增删\\n2. StringBuffer是可变长度的。\\n\\n**<font color=\\\"red\\\">StringBuffer 比 String 效率更高</font>**\\n\\n### 4. StringBuilder❗\\n\\n1. 一个可变的字符序列，但不保证同步（**<font color=\\\"red\\\">不是线程安全</font>**），**用在字符串缓冲区被单个线程使用的时候**，在大多数实现中，它比 StringBuffer 要快\\n2. 在 StringBuilder 上的主要操作是 append 和 insert 方法，可重载这些方法以接受任意类型的数据。\\n\\n```java\\n//String可以通过append()方法转换成StringBuilder或StringBuffer类型\\nStringBuilder a = new StringBuilder(\\\"123\\\");\\n\\n//StringBuilder和StringBuffer 可以通过toString()方法转换成String类型\\nStringBuilder a1 = new StringBuilder(\\\"123\\\");\\nString a1 = a.toString();\\n```\\n\\n### 5. 三者比较和选择❗\\n\\n比较：\\n\\n1. StringBuilder 和 StringBuffer 非常类似，均代表可变的字符序列，而且方法也一样\\n2. String：字符串常量，不可变字符序列，效率低，但是复用率高。\\n3. StringBuffer：字符串变量，可变字符序列、效率较高（增删）、线程安全\\n4. StringBuilder：字符串变量，可变字符序列、效率最高、线程不安全\\n\\n选择：\\n\\n1. 如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder\\n2. 如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder\\n3. 如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer\\n4. 如果我们字符串很少修改，被多个对象引用，使用String,比如配置信息等\\n\\nString使用注意说明：   \\nstring s:=\\\"a\\\"; //创建了一个字符串  \\ns+=\\\"b\\\"; //实际上原来的\\\"a\\\"字符串对象已经丢弃了，现在又产生了一个字符串s+\\\"b\\\"(也就是\\\"ab\\\")。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。**<font color=\\\"red\\\">如果我们对String做大量修改，不要使用 String</font>**\\n\\n**<font color=\\\"red\\\">StringBuilder 和 StringBuffer 的使用方法是一样的</font>**\\n\\n---\\n\\n## 🖇️Math\\n\\n### 1. abs 绝对值\\n\\n### 2. pow 求幂\\n\\n### 3. ceil 向上取整\\n\\n### 4. floor 向下取整\\n\\n### 5. round 四舍五入\\n\\n### 6. sqrt 求开方\\n\\n### 7. random 求随机数\\n\\n获取一个a-b之间的一个随机整数\\n\\n```java\\nint num = (int)(a + Math.random()*(b - a + 1));\\n```\\n\\n### 8. max 求两个数的最大值\\n\\n### 9. min 求两个数的最小值\\n\\n## 🖇️Arrays 类\\n\\n### 1. toString 返回数组的字符串形式\\n\\n```java\\nArrays.toString(arr);\\n```\\n\\n### 2. sort 排序（自然排序和定制排序）\\n\\n```java\\nArrays.sort(a);\\n```\\n\\n```java\\nArrays.sort(a, new Comparator() {\\n  \\t\\t\\t@Override\\n  \\t\\t\\tpublic int compare(Object o1, Object o2) {\\n   \\t\\t\\treturn 0;\\n  \\t\\t\\t}\\n\\t\\t}\\n);\\n```\\n\\n### 3. binarySearch 通过二分搜索法进行查找\\n\\n返回对应数组下标（要求必须排好序，如果数组是无序的，则不能使用。如果数组中不存在搜索的数字，会返回与之相近的、偏大的数字的、下标数字加一的负数。如下）\\n\\n```java\\nInteger[] a = {-5, -4, 5, 31, 79, 100};\\n//查找6，但是6并不存在\\nSystem.out.println(Arrays.binarySearch(a, 6));//输出-4\\nSystem.out.println(Arrays.binarySearch(a, -3));//输出-3\\n```\\n\\n### 4. copyOf 数组元素的复制\\n\\n### 5. fill 数组元素的填充\\n\\n```java\\nArrays.fill(arr,1);//将数组元素全部用1替换\\n```\\n\\n### 6. equals 比较两个数组元素内容是否完全一致\\n\\n### 7. asList 将一组值，转换成list\\n\\n---\\n\\n## 🖇️System 类\\n\\n### 1. exit 退出当前程序\\n\\n### 2. arraycopy 复制数组元素\\n\\n```java\\nSystem.arraycopy(arr1, 0, arr2, 0, 3);\\n//源数组\\n//源数组的第几个位置\\n//目标数组\\n//目标数组的第几个位置\\n//拷贝几个元素\\n```\\n\\n一般不用它，一般用 Arrays.copyOf() ，它的底层就是 System.arraycopy()\\n\\n### 3. currenTimeMillens 返回当前时间距离 1970-1-1 的毫秒数\\n\\n### 4. gc 运行垃圾回收机制\\n\\n---\\n\\n## 🖇️BigInteger 和 BigDecimal 类\\n\\n1. 初始化的时候需要用字符串\\n\\n   ```java\\n   BigInteger bigInteger = new BigInteger(\\\"123456789123456789123456789\\\");\\n   BigDecimal bigDecimal = new BigDecimal(\\\"123.123456789123456789\\\");\\n   ```\\n\\n**<font color=\\\"red\\\">计算的时候不能用普通的运算符（+ - * /），需要使用以下的方法</font>**\\n\\n2. add 加\\n\\n3. subtract 减\\n\\n4. multiply 乘\\n\\n5. divide 除\\n\\n   **<font color=\\\"red\\\">小数除法的时候有可能除不尽，然后报错，需要添加一个参数，就可以保留到分子的精度</font>**\\n\\n   ```java\\n   bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING);\\n   ```\\n\\n---\\n\\n## 🖇️Date、Calendar、LocalDate 类\\n\\n### 1. Date\\n\\n1. Date 精确到毫秒，代表特定的瞬间\\n\\n   ```java\\n   Date date = new Date();\\n   ```\\n\\n2. SimpleDateFormat 格式和解析日期的类。它允许进行格式化（日期->文本）解析（文本->日期）和规范化\\n\\n   ```java\\n   //格式化日期\\n   SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy年MM月dd日 HH:mm:ss E\\\");\\n   System.out.println(dateFormat.format(date));\\n   //输出：2022年09月11日 15:41:37 周日\\n   ```\\n\\n   ```java\\n   //文本转日期\\n   String s = \\\"2022年09月11日 15:41:37 周日\\\";\\n   Date date1 = dateFormat.parse(s);\\n   System.out.println(dateFormat.format(date1));\\n   //字符串转日期\\n   String s = \\\"2022年09月11日 15:41:37 周日\\\";\\n   Date date1 = dateFormat.parse(s);\\n   System.out.println(dateFormat.format(date1));\\n   ```\\n\\n### 2. Calendar\\n\\n```java\\n//创建日历类对象\\nCalendar c = Calendar..getlnstance(); \\n\\n//获取日历对象的某个日历字段\\nSystem.out.printIn(\\\"年:\\\" + c.get(Calendar.YEAR));\\nSystem.out.println(\\\"月:\\\" + (c.get(Calendar.MONTH) + 1));\\nSystem.out.println(\\\"日:\\\" + c.get(Calendar.DAY_OF_MONTH));\\nSystem.out.println(\\\"小时：，\\\" + c.get(Calendar.HOUR));\\nSystem.out.printIn(\\\"分钟：\\\" + c.get(Calendar.MINUTE);\\nSystem.out.println(\\\"秒:\\\" + c.get(Calendar.SECOND));\\n                   \\n//Calender没有专门的格式化方法，所以需要程序员自己来组合显示\\nSystem.out.println(c.get(Calendar.YEAR) + \\\"年\\\" + (c.get(Calendar.MONTH) + 1) + \\\"月\\\" + c.get(Calendar.DAY_OF_MONTH) + \\\"日\\\");\\n```\\n\\nCalendar 中存在以下问题：\\n\\n1. 可变性：像日期和时间这样的类应该是不可变的。\\n2. 偏移性：Date中的年份是从1900开始的，而月份都从0开始。\\n3. 格式化：格式化只对Date有用，Calendar则不行。\\n4. 此外，它们也不是线程安全的；不能处理闰秒等（每隔2天，多出1s)。\\n\\n### 3. LocalDate - 第三代日期\\n\\n1. LocalDate（日期/年月日）\\n\\n2. LocalTime（时间/时分秒）\\n\\n3. LocalDateTime（日期+时间）\\n\\n   ```java\\n   LocalDateTime ldt = LocalDateTime.now();\\n                     getYear(); //年      \\n                     getMonth();  //月    \\n                     getMonthValue(); //月 \\n                     getDayofMonth(); //日\\n                     getHour(); //时     \\n                     getMinute(); //分   \\n                     getSecond(); //秒\\n   //使用now()返回表示当前日期时间的对象\\n   LocalDate now=LocalDate.now();//可以获取当前年月日\\n   LocalTime now2=LocalTime.now();//获取到当前时分秒\\n   ```\\n\\n4. DateTimeFormatter 日期格式化\\n\\n   ```java\\n   DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\\\"yyyy-MM-dd hh:mm:ss\\\");\\n   LocalDateTime localDateTime = LocalDateTime.now();\\n   String format = dateTimeFormatter.format(localDateTime);\\n   ```\\n\\n5. Instant 时间戳\\n\\n   ```java\\n   //通过静态方法now()获取表示当前时间戳的对象\\n   Instant instant = Instant.now();\\n   //通过from可以把Instant转成Date\\n   Date date = Date.from(instant);\\n   //通过date的toInstant()可以把date转成instant \\n   ```\\n\\n\\n---\\n\\n## 🖇️集合\\n\\n### 1. 集合框架体系\\n\\n数组的不足之处： \\n1. 长度开始时必须指定，不能更改\\n2. 保存的数据为同一种类型\\n3. 使用数组增加/删除元素的时候比较麻烦\\n\\n集合的好处： \\n1. 可以动态保存任意多个对象\\n2. 提供了一系列方便的操作对象的方法\\n3. 使用集合添加/删除元素比较方便\\n\\n### 2. Collection - 单列集合\\n\\n1. collection.实现子类可以存放多个元素，每个元素可以是Object\\n\\n2. 有些Collection的实现类，可以存放重复的元素，有些不可以\\n\\n3. 有些Collection的实现类，有些是有序的(List),有些不是有序(Set)\\n\\n4. Collection接口没有直接的实现子类，是通过它的子接口Set和List来\\n   实现的\\n\\n   ```java\\n   add:添加单个元素\\n   remove:删除指定元素\\n   contains:查找元素是否存在\\n   size:获取元素个数\\n   isEmpty:判断是香为空\\n   clear:清空\\n   addALl:添加多个元素\\n   containsAll:查找多个元素是否都存在\\n   removeAll:删除多个元素\\n   ```\\n\\n#### List\\n\\nList集合类中元素有序（即添加顺序和取出顺序一致）、且可重复\\n\\nList集合中的每个元素都有其对应的顺序索引，即支持索引\\n\\nList容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。\\n\\n1. 迭代器\\n\\n   ```java\\n   ArrayList arrayList = new ArrayList();\\n   //新建一个迭代器对象，并重置迭代器\\n   Iterator iterator = arrayList.iterator();\\n   //迭代元素\\n   while (iterator.hasNext()) {\\n     Object next = iterator.next();\\n     System.out.println(next);\\n   }\\n   ```\\n\\n2. 增强 for 循环\\n\\n   ```java\\n   for (Object obj : arrayList) {\\n   \\tSystem.out.println(obj);\\n   }\\n   ```\\n\\n**<font color=\\\"red\\\">增强for循环在普通数组中也能使用。</font>**\\n\\n**<font color=\\\"red\\\">增强for循环其实是简化版的迭代器，底层仍然是hasNext()</font>**\\n\\n##### ArrayList❗\\n\\n1. ArrayList是由数组来实现数据存储的\\n2. ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高）。在多线程情况下，不建议使用ArrayList\\n3. ArrayListr中维护了一个Object类型的数组elementData.  \\n   `transient Object[] elementData;`  \\n   transient 表示瞬间，短暂的，表示该属性不会被序列化 ^9da737\\n4. 当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容elementData为10，如需要再次扩容，则扩容elementData为1.5倍。\\n5. 如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍。\\n\\n##### Vector❗\\n\\n1. Vector底层也是一个对象数组，`protected Object[] elementData;`\\n2. Vector 是线程同步的，也就是线程安全\\n\\n##### Vector 和 ArrayList 的比较\\n\\n|           | 底层结构 | 版本   | 线程安全       | 扩容倍数                                                     |\\n| --------- | -------- | ------ | -------------- | ------------------------------------------------------------ |\\n| ArrayList | 可变数组 | jdk1.2 | 不安全，效率高 | 1. 无参默认0，第一次10，之后1.5倍<br />2. 有参第一次及之后都1.5倍 |\\n| Vector    | 可变数组 | jdk1.0 | 安全，效率不高 | 1. 无参默认为10，第一次及之后为2倍<br />2. 有参第一次及之后都2倍 |\\n\\n##### LinkedList\\n\\n1. LinkedList底层实现了**双向链表**和**双端队列**特点\\n2. 可以添加任意元素（元素可以重复），包括null\\n3. 线程不安全，没有实现同步\\n4. LinkedList底层维护了一个双向链表\\n5. LinkedList中维护了两个属性 first 和 last 分别指向首节点和尾节点\\n6. 每个节点(Node对象)，里面又维护了prev、next、item三个属性，其中通过\\n   prev指向前一个，通过next指向后一个节点。最终实现双向链表\\n7. 所以LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高。\\n![双向链表](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-5c3.png)\\n\\n##### LinkedList 和 ArrayList 的比较\\n\\n|            | 底层结构 | 增删的效率         | 改查的效率 |\\n| ---------- | -------- | ------------------ | ---------- |\\n| ArrayList  | 可变数组 | 较低，数组扩容     | 较高       |\\n| LinkedList | 双向链表 | 较高，通过链表追加 | 较低       |\\n\\n如何选择ArrayList和LinkedList:\\n\\n1. 如果我们改查的操作多，选择ArrayList\\n2. 如果我们增删的操作多，选择LinkedList\\n3. 一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList\\n4. 在一个项目中，根据业务灵活选择，也可能这样：一个模块使用的是ArrayList，另外一个模块是LinkedList\\n\\n#### Set\\n\\n1. Set 接口基本介绍\\n   1. 无序（添加和取出的顺序不一致），没有索引\\n   2. 不允许重复元素，所以最多包含一个null\\n   3. JDK APIE中Set接口的实现类有：HashSrt、TreeSet等\\n\\n2. Set 遍历方式\\n\\n   同Collection 的遍历方式一样，因为 Set 接口是 Collection 接口的子接口\\n\\n   1. 可以使用迭代器\\n   2. 增强 for\\n   3. 不能使用索引的方式来获取\\n\\n##### HashSet❗\\n\\n1. HashSet 的底层其实就是 HashMap\\n2. HashMap的底层是（数组+链表+红黑树）\\n\\nHashSet 添加元素底层是如何实现的：\\n\\n1. 添加一个元素时，**先得到 hash 值，然后转成索引值**（**<font color=\\\"red\\\">注意：不同对象 hashcode 值不一定不同，由 hashcode 转成的索引值也不一定不同。如果想要索引值相同，可以重写 hashcode() 方法</font>**）\\n\\n   ```java\\n   static final int hash(Object key) {\\n     int h;\\n     return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\\n   }\\n   ```\\n\\n2. 找到你想添加元素的存储数据表，看这个索引位置是否已经存放有元素\\n\\n3. 如果没有，直接加入。如果有，**调用 equals 比较**，如果相同就放弃添加，**如果不相同，则添加到这个索引的链表的最后**（**<font color=\\\"red\\\">注意：equals 可以重写，不再比较引用地址，而是比较内容：当对象的属性值相同时，返回相同的 hashcode 值 ，从而使得[不同对象但属性值相同的]对象，只能添加一个</font>**）\\n\\n4. 在 jdk8以后，如果一条链表的对象个数达到 TREEIFY_THRESHOLD（**默认是8**），并且 table 的大小达到 MIN_TREEIFY_CAPACITY （**默认是64**），就会进行**树化**（红黑树）\\n\\nHashSet 扩容机制：\\n\\n1. **第一次添加时，table 数组扩容到 16**，临界值（threshold）是16\\\\*加载因子（loadFactor）是0.75 = 12\\n2. 如果 table 数组使用到了**临界值12**（**<font color=\\\"red\\\">注意：这里是指整个 table 数组中的对象达到12个，并非仅仅一个链表</font>**），就会扩容到 16\\\\*2 = 21，新的临界值就是 32\\\\*0.75 = 24，依次类推\\n\\n##### TreeSet\\n\\n1. TreeSet 拥有一个可以传入两个参数的构造器，一个是存入的对象，一个是比较器（Comparator）\\n2. 如果没有传入比较器，就会在底层 `Comparator<? super k>k = (Comparable<?super K>)key;` 把存入的对象转成 Comparator类型 \\n\\n##### LinkedHashSet\\n\\n1. LinkedHashSet 底层是一个 LinkedHashMap，底层维护了一个 数组+双向链表\\n2. LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的。\\n3. LinkedHashSet 也不能添加重复元素\\n\\n### 3. Map - 双列集合\\n\\n1. 用于保存具有映射关系的数据：Key-Value（双列元素）\\n\\n2. Map中的key和value可以是任何引用类型的数据，会封装到HashMap:$Node对象中\\n\\n3. Map中的key不允许重复，原因和HashSet一样，当有相同的k，就等价于替换。\\n\\n4. Map 中的value是可以重复的\\n\\n   ```java\\n   Map map = new HashMap();\\n   map.put(key, value);\\n   ```\\n\\n5. Map 体系的继承图\\n\\n   ![Map体系图](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/Map%E4%BD%93%E7%B3%BB%E5%9B%BE-249.png)\\n\\n6. Map 接口常用方法\\n\\n   - put:添加\\n   - remove:根据键删除映射关系\\n   - get:根据键获取值\\n   - size获取元素个数\\n   - isEmpty:判断个数是否为0\\n   - clear:清除\\n   - containsKey:查找键是否存在\\n   - getOrDefault(a,0)：查看a是否存在，如果存在返回a的value，如果不存在就返回0\\n\\n#### HashMap❗\\n\\n1. Map接口的常用实现类：HashMap、Hashtable和Properties。\\n2. HashMap是Map接口使用频率最高的实现类。\\n3. HashMap是以key-val对的方式来存储数据（HashMap$Node类型）\\n4. key不能重复，但是值可以重复，允许使用nul键和nul值。\\n5. 如果添加相同的key，则会覆盖原来的key-val，等同于修改。(key不会替换，val会替换)\\n6. 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的。（jdk8的\\n   hashMap底层数组+链表+红黑树，之前是数组+链表）\\n7. HashMap没有实现同步，因此是线程不安全的\\n\\n#### Hashtable\\n\\n1. Hashtable 线程安全\\n\\n#### LinkedHashMap\\n\\n#### TreeMap\\n\\n1. TreeSet 的底层就是 TreeMap\\n\\n#### Properties\\n\\n1. Properties 类继承自 Hashtable 类并且实现了 Map 接口，也是使用一种键值对的形式来保存数据。\\n2. 他的使用特点和Hashtable类似\\n3. Properties 还可以用于从 xxx.properties 文件中，加载数据到 Properties 类对像，\\n   并进行读取和修改\\n\\n### Collections 工具类\\n\\n1. Collections工具类介绍\\n\\n   Collections是一个操作 Set、List 和 Map 等集合的工具类\\n\\n   Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作\\n\\n2. 排序操作：(均为 static 方法)\\n\\n   reverse(List)：反转 List 中元素的顺序\\n\\n   shuffle(List)：对 List 集合元素进行随机排序\\n\\n   sot(List)：根据元素的自然顺序对指定List集合元素按升序排序\\n\\n   sort(List, Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序\\n\\n   swap(List,int,int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换\\n\\n3. 查找、替换：\\n\\n   Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素\\n\\n   Object max(Collection, Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素\\n\\n   Object min(Collection)\\n\\n   Object min(Collection, Comparator)\\n\\n   int frequency(Collection, Object)：返回指定集合中指定元素的出现次数\\n\\n   void copy(List dest, List src)：将 src 中的内容复制到 dest 中\\n\\n   boolean replaceAll(List list, Object oldVal, Object newVal)：新值替换 List 对象的所有旧值\\n\\n**<font color=\\\"red\\\">自然排序是指按首字母A-Z、a-z排序</font>**\\n\\n### 总结-开发中如何选择集合实现类\\n\\n在开发中，选择什么集合实现类，主要取决于务操作特点，然后根据集合实现类特性进行\\n选择，分析如下：\\n\\n1. 先判断存储的类型（一组对象[单列]或一组键值对[双列]）\\n\\n2. 一组对象：Collection接口\\n\\n   - 允许重复：List\\n\\n     增删多：LinkedList [底层维护了一个双向链表]\\n\\n     改查多：ArrayList [底层维护Object类型的可变数组]\\n\\n   - 不允许重复：Set\\n\\n     无序：HashSet [底层是HashMap,维护了一个哈希表，即（数组+链表+红黑树）]\\n\\n     排序：TreeSet\\n\\n     插入和取出顺序一致：LinkedHashSet，维护数组+双向链表\\n\\n3. 一组键值对：Map\\n\\n   - 键无序：HashMap [底层是：哈希表 jdk7:数组+链表，jdk8:数组+链表+红黑树]\\n   - 键排序：TreeMap\\n   - 键插入和取出顺序一致：LinkedHashMap\\n   - 读取文件：Properties\\n\\n---\\n\\n## 🖇️泛型\\n\\n### 1. 泛型的理解和好处\\n\\n使用传统方法的问题分析\\n\\n1. 不能对加入到集合ArrayList中的数据类型进行约束（不安全）\\n2. 遍历的时候，需要进行类型转换，如果集合中的数据量较大，对效率有影响\\n\\n泛型介绍\\n\\n1. 泛型又称参数化类型，是Jdk5.0出现的新特性，解决数据类型的安全性问题\\n2. 在类声明或实例化时只要指定好需要的具体的类型即可\\n3. Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生 ClassCastException 异常。同时，代码更加简洁、健壮\\n4. 泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型或者是某个方法的返回值的类型，或者是参数类型\\n\\n### 2. 泛型基本语法\\n\\n1. 给泛型指向数据类型时，**要求是引用类型**，**不能是基本类型**\\n2. 在给泛型指定具体类型后，可以传入**该类型或者其子类类型**\\n3. 如果没有指定泛型，默认是object类型\\n4. 使用泛型的数组，不能初始化\\n5. 静态方法中不能使用类的泛型\\n\\n### 3. 自定义泛型\\n\\n#### 4. 泛型的继承和通配符\\n\\n1. 泛型不具备继承性\\n2. \\\\<?>：支持任意泛型类型\\n3. \\\\<? extends A>： 支持A类以及A类的子类，规定了泛型的上限\\n4. \\\\<?super A>：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限\\n\\n---\\n\\n## 🖇️Java 绘图坐标体系\\n\\n下图说明了Java坐标系。坐标原点位于左上角，以像素为单位。  \\n第一个是x坐标，表示当前位置为水平方向，距离坐标原点x个像素  \\n第二个是y坐标，表示当前位置为垂直方向，距离坐标原点y个像素。\\n\\n![Java 绘图坐标体系](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/Java%20%E7%BB%98%E5%9B%BE%E5%9D%90%E6%A0%87%E4%BD%93%E7%B3%BB-870.png)\\n\\n绘图原理：\\n\\n1. paint(Graphics g)绘制组件的外观\\n\\n2. repaint()刷新组件的外观。\\n3. 当组件第一次在屏幕显示的时候，程序会自动的调用paint()方法来绘制组件。\\n4. 窗口最小化，再最大化、窗口的大小发生变化、repaint函数被调用的时候pain()将会被调用\\n\\n```java\\n//JFrame 就是一个画框\\npublic class DrawCricle extends JFrame {\\n    private MyPanel mp = null;\\n\\n    public static void main(String[] args) {\\n        DrawCricle drawCricle = new DrawCricle();\\n    }\\n\\n    public DrawCricle() {\\n        mp = new MyPanel();\\n        this.add(mp);\\n        this.setSize(400, 300);\\n        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\\n        this.setVisible(true);\\n    }\\n}\\n//Mypanel 对象就是一个画板\\n//Graphics g 就是一个画笔\\nclass MyPanel extends JPanel {\\n    @Override\\n    public void paint(Graphics g) {\\n        super.paint(g);\\n        g.drawOval(10, 10, 100, 100);\\n    }\\n}\\n```\\n\\n---\\n\\n## 🖇️Java 事件处理机制\\n\\nKeyListener 是监听器，可以监听键盘事件\\n\\n```java\\nclass MyPanel extends JPanel implements KeyListener {\\n    @Override\\n    public void paint(Graphics g) {\\n        super.paint(g);\\n        g.fillOval(10, 10, 100, 100);\\n    }\\n\\t\\t//有字符输出时，该方法就会触发\\n    @Override\\n    public void keyTyped(KeyEvent e) {\\n        \\n    }\\n\\t\\t//当某个键按下，该方法会触发\\n    @Override\\n    public void keyPressed(KeyEvent e) {\\n        if (e.getKeyCode() == KeyEvent.VK_DOWN) {\\n            y++;\\n        } else if (e.getKeyCode() == KeyEvent.VK_UP) {\\n            y--;\\n        } else if (e.getKeyCode() == KeyEvent.VK_LEFT) {\\n            x--;\\n        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {\\n            x++;\\n        }\\n        this.repaint();\\n    }\\n\\t\\t//当某个键释放，该方法会触发\\n    @Override\\n    public void keyReleased(KeyEvent e) {\\n\\n    }\\n}\\n```\\n\\n![Java事件处理机制](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/Java%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6-aa3.png)\\n\\n1. 事件源：事件源是一个产生事件的对象，比如按钮，窗口等。\\n2. 事件：事件就是承载事件源状态改变时的对象，比如当键盘事件、鼠标事件、窗口事件等等，会生成一个事件对像，该对象保存着当前事件很多信息，比如KeyEvent对像有含义被按下键的Code值。java.awt.event包和javax.swing.event包中定义了各种事件类型\\n\\n## 🖇️线程\\n\\n### 1. 线程项关概念\\n\\n1. 进程：是指运行中的程序\\n\\n2. 线程：线程是由进程创建的，是进程的一个实体；一个进程可以拥有多个线程\\n   - 单线程：同一个时刻，只允许执行一个线程\\n   - 多线程：同一个时刻，可以执行多个线程\\n   - **并发**：同一个时刻，多个任务**交替执行**，造成一种“貌似同时”的错觉，简单的说，单核cpu实现的多任务就是并发\\n   - **并行**：同一时刻，多个任务**同时执行**，多核cpu可以实现并行；并发和并行可以同时存在\\n\\n3. 当一个类继承了 Thread 类，该类就可以当作线程使用\\n\\n   ```java\\n   at cat = new Cat();\\n   cat.start();\\n   //start()方法会启动一个线程，main线程和该线程会同时进行，\\n   //而单纯使用一个方法没有真正启动一个线程，而是会在方法执行完后再继续执行main方法\\n   ```\\n\\n4. 当一个类实现了 Runnable 接口，该类就可以当作线程使用\\n\\n   ```java\\n   class Cat implements Runnable {\\n     @Override\\n       public void run() {\\n           while (true) {\\n               System.out.println(\\\"miao~\\\");\\n           }\\n       }\\n   }\\n   ```\\n\\n5. 继承 Thread 和实现 Runnable 的区别\\n\\n   1. 从java的设计来看，通过继承Thread或者实现Runnable接口来创建线程本质上没有区别，而且Thread类本身就实现了Runnable接口\\n   2. 实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了java**单继承的限制**\\n\\n当main线程启动一个子线程，主线程不会阻塞，会继续交替执行\\n\\n***start()方法调用start0()方法后，该线程并不一定会立马执行，只是将线程变成了可运行状态。具体什么时候执行，取决于CPU,，由CPU统一调度。***\\n\\n### 2. 线程常用方法\\n\\n1. setName //设置线程名称，使之与参数name相同\\n\\n2. getName //返回该线程的名称\\n\\n3. start //使该线程开始执行；Java虚拟机底层调用该线程的start0方法\\n\\n4. run //调用线程对像run方法；\\n\\n5. setPriority //更改线程的优先级\\n\\n6. getPriority //获取线程的优先级\\n\\n   优先级有三种：\\n\\n   * MIN_PRIORITY = 1\\n   * NORM_PRIORITY = 5\\n   * MAX_PRIORITY = 10\\n\\n7. sleep //在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）\\n\\n8. interrupt //中断线程，没有真正的结束线程，一般用于中断正在休眠的线程\\n\\n9. yield //线程的礼让。让出cpu，让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功\\n\\n10. join //线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务\\n\\n### 3. 用户线程和守护线程：\\n\\n1. 用户线程：也叫工作线程，当线程的任务执行完或通知方式结束\\n\\n2. 守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束\\n\\n   ```java\\n   子线程对象.setDeamon(true) //将该对象设置为守护线程\\n   ```\\n\\n   * 常见的守护线程：**垃圾回收机制**\\n\\n### 4. 线程的生命周期\\n\\n\\n线程可以处于以下状态之一：\\n\\n1. NEW：尚未启动的线程处于此状态。\\n2. RUNNABLE：在Java虚拟机中执行的线程处于此状态。\\n3. BLOCKED：被阻塞等待监视器锁定的线程处于此状态。\\n4. WAITING：正在等待另一个线程执行特定动作的线程处于此状态。\\n5. TIMED WAITING：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。\\n6. TERMINATED：己退出的线程处于此状态。\\n\\n**<font color=\\\"red\\\">有些文章或者资料中标注有七种状态，其实是 Runable 状态下细分出两个子状态 Ready 和 Running 状态</font>**\\n\\n![Java线程状态转换图](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE-778.jpg)\\n\\n### 5. 线程同步机制\\n\\n在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，***保证数据在任何同一时刻，最多有一个线程访问，以保证数据的完整性***。  \\n也可以这里理解：线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，***直到该线程完成操作，其他线程才能对该内存地址进行操作***\\n\\n1. 同步具体方法 - **Synchronized**\\n\\n   * 同步代码块\\n\\n     ```java\\n     synchronized (同一个对象){//得到对像的锁，才能操作同步代码\\n     \\t//需要被同步代码;\\n     }\\n     ```\\n\\n   * synchronized 还可以放在方法声明中，表示整个方法-为同步方法\\n\\n     ```java\\n     public synchronized void run(){\\n     \\t//需要被同步的代码\\n     }   \\n     ```\\n\\n### 6. 互斥锁\\n\\n基本介绍：\\n\\n1. Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。\\n\\n2. 每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。\\n\\n3. 关键字 synchronized 来与对象的互斥锁联系。当某个对象用 synchronized 修饰时，表明该对象在任一时刻只能由一个线程访问\\n\\n4. 同步的局限性：导致程序的执行效率要降低\\n\\n5. 非静态的同步方法的锁可以是this，也可以是其他对象（要求是同一个对象）\\n\\n   如下，这就是一个同步方法，锁在this对象\\n\\n   ```java\\n   public synchronized void method(){\\n   \\t//需要被同步的代码\\n   }   \\n   ```\\n\\n   ```java\\n   synchronized (this){//得到对像的锁，才能操作同步代\\n   \\t//需要被同步代码;\\n   }\\n   ```\\n\\n6. 静态的同步方法的锁为当前类本身。\\n\\n   ```java\\n   public synchronized static void method(){\\n   \\t//需要被同步的代码\\n   }\\n   ```\\n\\n   ```java\\n   synchronized (类.class){//得到对像的锁，才能操作同步代码\\n   \\t//需要被同步代码;\\n   }\\n   ```\\n\\n7. 注意事项：\\n\\n   1. 同步方法如果没有使用static修饰：默认锁对象为this\\n   2. 如果方法使用static修饰，默认锁对象：当前类.class\\n   3. 实现步骤：\\n      * 需要先分析上锁的代码\\n      * 选择==同步代码块==或同步方法\\n      * 要求***多个线程的锁对象为同一个***\\n\\n### 7. 线程的死锁\\n\\n基本介绍：  \\n多个线程都占用了对方的锁资源，但不肯相让，导致了死锁，在编程是一定要避免死锁的发生\\n\\n### 8. 释放锁\\n\\n1. 当前线程的同步方法、同步代码块**执行结束**\\n2. 当前线程在同步代码块，同步方法中遇到**break、return**\\n3. 当前线程在同步代码块、同步方法中出现了**未处理的Error或Exception**，导致异常结束\\n4. 当前线程在同步代码块、同步方法中执行了线程对象的**wite()方法**，**当前线程暂停，并释放锁。**\\n\\n下面操作不会释放锁：\\n\\n1. 线程执行同步代码块或同步方法时，程序调用**Thread.sleep()、Thread.yield() 方法暂停当前线程的执行，不会释放锁**\\n2. 线程执行同步代码块时，其他线程调用了该线程的 **suspend() 方法**将该线程挂起，该线程不会释放锁。\\n\\n---\\n\\n## 🖇️IO\\n\\n### 1. 文件\\n\\n1. 文件流\\n\\n   文件在程序中是以流的形式来操作的\\n\\n   ![文件流](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E6%96%87%E4%BB%B6%E6%B5%81-938.png)\\n\\n   流：数据在数据源（文件）和程序（内存）之间经历的路径\\n\\n   输入流：数据从数据源（文件）到程序（内存）的路径\\n\\n   输出流：数据从程序（内存）到数据源（文件）的路径\\n\\n2. 创建文件对象相关构造器和方法\\n\\n   ```java\\n   File file = new File(String pathname)//根据路径构建一个File对象\\n   File file = new File(File parent,String child)//根据父目录文件+子路径构建\\n   File file = new File(String parent,String child)//根据父目录+子路径构建\\n     \\n   file.createNewFile(); //创建文件  \\n   ```\\n\\n   * getName //获取文件名\\n   * getAbsolutePath //文件绝对路径\\n   * getParent //文件的父级目录\\n   * length //文件内容大小（**一个字母占一个字节，一个汉字占三个字节**）\\n   * exists //文件是否存在\\n   * isFile //判断是否是一个文件\\n   * isDirectory //判断是否是一个目录\\n\\n3. 目录的操作和文件删除\\n\\n   * mkdir() //创建一级目录\\n   * mkdirs() //创建多级目录\\n   * delete() //删除空目录或文件\\n\\n### 2. IO流原理及流的分类\\n\\n#### 2.1 Java IO流原理\\n\\n1. IO是Input/Output的缩写，I/O技术是非常实用的技术，用于处理数据传输。如读/写文件，网络通讯等。\\n2. Java程序中，对于数据的输入/输出操作以”流(stream)”的方式进行。\\n3. java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过方法输入或输出数据\\n\\n#### 2.2 流的分类\\n\\n* 按操作数据单位不同分为：字节流(8bt)，字符流（按字符）\\n* 按数据流的流向不同分为：输入流，输出流\\n* 按流的角色的不同分为：节点流，处理流/包装流\\n\\n| （抽象基类） | 字节流       | 字符流 |\\n| ------------ | ------------ | ------ |\\n| 输入流       | InputStream  | Reader |\\n| 输出流       | OutputStream | Writer |\\n\\n### 3. 节点流和处理流\\n\\n#### 3.1 介绍\\n\\n1. 节点流可以从一个特定的数据源读写数据，如 FileReader、FileWriter\\n2. 处理流（也叫包装流）是“连接”在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，如 BufferedReader、BufferedWriter\\n\\n![节点流和处理流](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81-636.png)\\n\\nBufferedReader 类中，有属性 Reader，即可以封装一个节点流，该节点流可以是任意的，只要是Reader 的子类\\n\\n#### 3.2 节点流和处理流的区别和联系\\n\\n1. 节点流是底层流/低级流，**直接跟数据源相接**。\\n2. 处理流（包装流）包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出。\\n3. 处理流（也叫包装流）对节点流进行包装，使用了修饰器设计模式，**不会直接与数据源相连**\\n\\n#### 3.3 处理流的功能主要体现在以下两个方面：\\n\\n1. 性能的提高：主要以增加缓冲的方式来提高输入输出的效率。\\n2. 操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便\\n\\n#### 3.4 对象流-ObjectInputStream 和 ObjectOutputStream\\n\\n序列化和反序列化\\n\\n1. 序列化就是在保存数据时，保存**数据的值**和**数据类型**\\n2. 反序列化就是在恢复数据时，**恢复数据的值**和**数据类型**\\n3. 需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：\\n   * Serializable //这是一个标记接口，\\n   * Externalizable //该接口有方法需要实现，因此我们一般实现上面的 Serializable 接口\\n4. 序列化对象时，默认将里面所有属性都进行序列化，但除了 Static 或 [transient](java#^9da737) 修饰的成员\\n5. 序列化对象时，要求里面属性的类型也需要实现序列化接口\\n\\n```java\\n//序列化\\nObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(dirsrc));\\nobjectOutputStream.writeObject(dog);\\nobjectOutputStream.close();\\n//反序列化\\nObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(dirsrc1));\\nDog dog1 = (Dog) objectInputStream.readObject();\\nSystem.out.println(dog1);\\nobjectInputStream.close();\\n```\\n\\n![序列化和反序列化](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-484.png)\\n\\n**<font color=\\\"red\\\">存储对象数据的时候，要求该对象也要实现 Serializable 接口</font>** \\n\\n**<font color=\\\"red\\\">反序列化的顺序需要和序列化的顺序保持一致</font>** \\n\\n#### 3.5 标准输入输出流\\n\\n|                     | 类型         | 默认设备 |\\n| ------------------- | ------------ | -------- |\\n| System.in 标准输入  | InputStream  | 键盘     |\\n| System.out 标准输出 | OutputStream | 显示器   |\\n\\n#### 3.6 转换流-InputStreamReader 和 OutputStreamWriter\\n\\n1. InputStreamReader：\\n\\n   Readerl的子类，可以将 InputStream(字节流)包装成Reader(字符流)\\n\\n2. OutputStreamWriter：\\n\\n   Writer的子类，实现将OutputStream(字节流)包装成Vriter(字符流)\\n\\n3. 当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换成字符流\\n\\n4. 可以在使用时指定编码格式（比如 utf-8、gbk、gb2312、ISO8859-1 等）\\n\\n#### 3.7 打印流-PrintStream 和 PrintWriter\\n\\n**<font color=\\\"red\\\">打印流只有输出流，没有输入流</font>**\\n\\n### 4. 输入流\\n\\n#### 4.1 InputStream：字节输入流\\n\\n1. FilelnputStream：文件输入流\\n   * read()：一次读取一个字符\\n   * read(byte[] b)：一次读取b长度的字符\\n2. BufferedInputStream：缓冲字节输入流\\n3. ObjectInputStream：对像字节输入流\\n\\n#### 4.2 Reader：字符输入流\\n\\n1. FileReader\\n   * new FileReader(File/String)\\n   * read：每次读取单个字符，返回该字符，如果到文件末尾返回-1\\n   * read(char[])：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1\\n   * new String(char[])：将char[]转换成String\\n   * new String(char[],off,len)：将char[]的指定部分转换成String\\n\\n### 5. 输出流\\n\\n#### 5.1 OutputStream：字节输出流\\n\\n1. FileOutputStream：文件输出流\\n   * wirte(byte[] b)：一次写入b长度的字符\\n   * wirte(byte[] b, int off, int len)：将 b 的 len 字节从此文件的第 off 字节开始写入\\n   * write(int b)：将指定的字节写入此文件输出流。\\n\\n#### 5.2 Writer：字符输出流\\n\\n1. FileWriter\\n\\n   * new FileWriter(File/String)：覆盖模式，相当于流的指针在首端\\n   * new FileWriter(File/String,true)：追加模式，相当于流的指针在尾端\\n   * write(int)：写入单个字符\\n   * write(char[])：写入指定数组\\n   * write(char[],off,len)：写入指定数组的指定部分\\n   * write(string)：写入整个字符串\\n   * write(string,off,len)：写入字符串的指定部分\\n\\n   **<font color=\\\"red\\\">FileWriter使用后，必须要关闭(close)或刷新(flush)，否则要写入的数据还在内存中，没有写入到指定的文件！</font>**\\n\\n### 6. Properties类\\n\\n1. 专门用于读写配置文件的集合类\\n\\n   配置文的格式：`键=值`\\n\\n2. 键值对不需要有空格，值不需要用引号一起来。默认类型是String\\n\\n3. Properties 的常见方法\\n\\n   * load：加载配置文件的键值对到 Properties 对象\\n   * list：将数据显示到指定设备\\n   * getProperty(key)：根据键获取值\\n   * setProperty(key,value)：设置键值对到 Properties 对象\\n   * store：将 Properties 中的键值对存储到配置文件，在 idea中，保存信息到配置文件，如果含有中文，会存储为 unicode 码\\n\\n---\\n\\n## 🖇️网络编程\\n\\n### 1. 网络相关概念\\n\\n网络通信\\n\\n1. 概念：两台设备之间通过网络实现数据传输\\n2. 网络通信：将数据通过网络从一台设备传输到另一台设备\\n3. java.net包下提供了一系列的类或接口，供程序员使用，完成网络通信\\n\\nIP地址\\n\\n1. 概念：用于唯一标识网络中的每台计算机/主机\\n2. 查看ip地址：ipconfig\\n3. ip地址的表示形式：点分十进制 xx.xx.xx.xx\\n4. 每一个十进制数的范围：0~255\\n5. ip 地址的组成 = 网络地址 + 主机地址，比如：192.168.16.69\\n6. iIPV6是互联网工程任务组设计的用于替代IPV4的下一代IP协议，其地址数量号称可以\\n   为全世界的每一粒沙子编上一个地址\\n7. 由于IPV4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPV6\\n   的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联\\n   的障碍\\n\\n域名\\n\\n1. www.baidu.com\\n2. 好处：为了方便记忆，解决记ip的困难\\n3. 概念：将ip地址映射成域名\\n\\n端口号\\n\\n1. 概念：用于标识计算机上某个特定的网络程序\\n2. 表示形式：以整数形式，范围0~65535\\n3. 0~1024已经被占用，比如ssh22、ftp21、smtp25、http80\\n4. 常见的网络程序端口号：\\n   * tomcat 8080\\n   * mysql:3306\\n   * oracle:1521\\n   * sqlserver:1433\\n\\nTCP 和 UDP\\n\\n1. TCP 协议：传输控制协议\\n   1. 使用TCP协议前，须先建立TCP连接，形成传输数据通道\\n   2. 传输前，采用“三次握手”方式，是**<font color=\\\"red\\\">可靠的</font>**\\n   3. TCP协议进行通信的两个应用进程：客户端、服务端\\n   4. 在连接中可进行大数据量的传输\\n   5. 传输完毕，需释放已建立的连接，**效率低**\\n2. UDP协议：\\n   1. 将数据、源、目的封装成数据包，不需要建立连接\\n   2. ***<font color=\\\"red\\\">每个数据报的大小限制在64K内</font>***\\n   3. 因无需连接，故是**<font color=\\\"red\\\">不可靠的</font>**\\n   4. 发送数据结束时无需释放资源（因为不是面向连接的），速度快\\n\\n### 2. InetAddress 类\\n\\n相关方法\\n\\n1. 获取本机 InetAddress对象 getLocalHost\\n2. 根据指定主机名/域名获取ip地址对象getByName\\n3. 获取 InetAddress对象的主机名 getHostName\\n4. 获取 InetAddress 对象的地址 getHostAddress\\n\\n### 3. Socket\\n\\n基本介绍\\n\\n1. 套接字(Socket)开发网络应用程序被广泛采用，以至于成为事实上的标准。\\n2. 通信的两端都要有Socket，是两台机器间通信的端点\\n3. 网络通信其实就是Socket间的通信。\\n4. Socket:允许程序把网络连接当成一个流，数据在两个 Socket 间通过IO传输。\\n5. 一般主动发起通信的应用程序属客户端，等待通信请求的为服务端\\n\\n当我们需要通讯时（读写数据）\\n\\n1. socket.getOutputStream() //读取通道数据\\n\\n2. socket.getlnputStream() //写入通道数据\\n\\n   以上都是字符流，可以使用转换流转换成字节流\\n\\n3. socket.shutdownOutput() //写完数据后需要告知服务器，服务器才会继续执行\\n\\n   writer.newLine() //插入一个换行符，同样表示写入结束标记，但服务器也需要用 read.newLine() 读取\\n\\n### 4. TCP网络通信编程\\n\\n基本介绍\\n\\n1. 基于客户端--服务端的网络通信\\n2. 底层使用的是TCP/IP协议\\n3. 应用场景举例客户端发送数据，\\n4. 服务端接受并显示\\n5. 基于Socket的TCP编程\\n\\n![socket-TCP](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/socket-TCP-6d9.png)\\n\\n```java\\n//监听9999端口\\nServerSocket serverSocket =  new ServerSocket(9999);\\n//如果有客户端连接，则会返回Socket对象，程序继续\\nSocket socket = serverSocket.accept();\\n//连接本机9999端口\\nSocket socket = new Socket(InetAddress.getLocalHost(), 9999);\\n//得到和socket对象关联的输出流对象\\nOutputstream outputstream =  socket.getoutputstream();\\n//通过输出流，写入数据到数据通道\\noutputstream.write(\\\"hello,server\\\".getBytes());\\n//4.关闭流对象和socket,必须关闭\\noutputstream.close();\\nsocket.close();\\nserverSocket.close();\\n```\\n\\n***当客户端连接到服务端后，实际上客户端也是通过一个端口和服务端进行通讯的，这个端口是TCP/IP来分配的，是不确定的，是随机的***\\n\\n### 5. UDP网络通信编程[了解]\\n\\n基本介绍\\n\\n1. 类 DatagramSocket[数据报套接字] 和 DatagramPacket[数据包/数据报] 实现了基于UDP协议网络程序。\\n2. UDP数据报通过数据报套接字 DatagramSocket 发送和接收，***系统不保证 UDP 数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。***\\n3. DatagramPacket 对象封装了 UDP 数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。\\n4. UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接\\n5. UDP一个数据包最大为64k\\n\\n基本流程\\n\\n1. 核心的两个类/对象 DatagramSocket 与 DatagramPacket\\n2. 建立发送端，接收端（没有服务端和客户端概念）\\n3. 发送数据前，建立 数据包/报DatagramPacket 对象\\n4. 调用DatagramSocket的发送、接收方法\\n5. 关闭DatagramSocket\\n\\n```java\\n//监听9999端口\\nDatagramSocket datagramSocket = new DatagramSocket(9999);\\nbyte[] bytes = new byte[1024];\\nDatagramPacket datagramPacket = new DatagramPacket(bytes, bytes.length);\\n//收到的数据传给datagramPacket\\ndatagramSocket.receive(datagramPacket);\\n//转成char[]\\nint length = datagramPacket.getLength();\\nbyte[] data = datagramPacket.getData();\\n//转成字符串\\nString s = new String(data);\\ndatagramSocket.close();\\n\\n//监听9998端口\\nDatagramSocket datagramSocket = new DatagramSocket(9998);\\nbyte[] bytes = \\\"你好，大傻逼\\\".getBytes();\\nDatagramPacket datagramPacket = new DatagramPacket(bytes, bytes.length, InetAddress.getLocalHost(), 9999);\\n//发送数据\\ndatagramSocket.send(datagramPacket);\\n```\\n\\n---\\n\\n## 🖇️反射\\n\\n### 1. 反射机制❗\\n\\n***<font color=\\\"red\\\">设计模式的 ocp 原则，也就是开闭原则：也就是不修改源码，扩容功能</font>***\\n\\n1. 反射机制允许程序在执行期借助于 ReflectionAPI 取得任何类的内部信息（比如成员变量，构造器，成员方法等等)，并能操作对象的属性及方法。反射在设计模式和框架底层都会用到\\n2. 加载完类之后，在堆中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，形象的称之为反射\\n\\n![Java程序计算机有三个阶段](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/Java%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%89%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5-07e.png)\\n\\n#### Java 反射机制可以完成\\n\\n1. 在运行时判断任意一个对象所属的类\\n2. 在运行时构造任意一个类的对象\\n3. 在运行时得到任意一个类所具有的成员变量和方法\\n4. 在运行时调用任意一个对象的成员变量和方法\\n5. 生成动态代理\\n\\n#### 反射相关的主要类：\\n\\n1. java.lang.Class：代表一个类，Class对像表示某个类加载后在堆中的对象\\n2. java.lang.reflect.Method：代表类的方法，Method对象表示某个类的方法\\n3. java.lang.reflect.Field：代表类的成员变量，Field对像表示某个类的成员变量\\n4. java.lang.reflect.Constructor：代表类的构造方法，Constructor 对象表示构造器\\n\\n#### 反射优点和缺点\\n\\n1. 优点：可以动态的创建和使用对象（也是框架底层核心），使用灵活，没有反射机制，框架技术就失去底层支撑。\\n2. 缺点：使用反射基本是解释执行，对执行速度有影响\\n\\n#### 反射调用优化-关闭访问检查\\n\\n1. Method和Field、Constructor)对象都有setAccessible()方法，setAccessible作用是启动和禁用访问安全检查的开关 \\n\\n   ***<font color=\\\"red\\\">可以获取私有成员，不安全但能提升效率，慎用</font>***\\n\\n2. 参数值为true表示反射的对象在使用时取消访问检查，提高反射的效率。参数值为falsel则表示反射的对象执行访问检查\\n\\n### 2. Class类❗\\n\\n#### 基本介绍\\n\\n1. Class也是类，因此也继承Object类\\n2. Class类对象不是new出来的，而是系统创建的\\n3. 对于某个类的Cass类对象，在内存中只有一份，因为类只加载一次\\n4. 每个类的实例都会记得自己是由哪个Class实例所生成\\n5. 通过Class可以完整地得到一个类的完整结构，通过一系列API\\n6. Classi对象是存放在堆的\\n7. 类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码，变量名，方法名，访问权限等等\\n\\n#### 常用方法\\n\\n```java\\nString str = \\\"com.hspedu.reflection.Person\\\";\\n//获取到Class类对象，?表示不确定的java类型\\nClass<?> clazz = Class.forName(str);\\nSystem.out.println(clazz);//显示该clazzi对象是哪个类的Class对象\\nSystem.out.printIn(clazz.getClass());//运行类型\\nSystem.out.println(clazz.getPackage().getName());\\nSystem.out.println(clazz.getName());\\nObject obj = clazz.newlnstance();//通过反射创建对象\\nField field = clazz.getField(\\\"name\\\");//通过反射获取属性\\nfield.set(obj,\\\"hspedu\\\");//通过字段对象赋值\\nObject obj22=field.get(obj);//获取值\\nSystem.out.println(obj2);//输出\\n```\\n\\n#### 获取Class类对象的方式\\n\\n1. 前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName0获取，可能抛出ClassNotFoundException,实例：Class cls1=Class.forName(\\\"java.lang.Cat\\\")\\n\\n   应用场景：多用于配置文件，读取类全路径，加载类。\\n\\n2. 前提：若已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高实例：Class cls2 = Cat.class;\\n\\n   应用场景：多用于参数传递，比如通过反射得到对应构造器对象\\n\\n3. 前提：已知某个类的实例，调用该实例的getClass0方法获取Class对像，实例：Class clazz=对象.getClass()；\\n\\n   应用场景：通过创建好的对象，获取Class对象\\n\\n4. 其他方式\\n\\n   ClassLoader cl = 对象.getClass().getClassLoader();\\n\\n   Class clazz4 = cl.loadClass(\\\"类的全类名\\\");\\n\\n5. 基本数据(int,char,boolean,float,double,byte,long,short)按如下方式得到Class类对象\\n\\n   `Class cls = 基本数据类型.class`\\n\\n6. 基本数据类型对应的包装类，可以通过.TYPE得到Class类对象\\n\\n   `Class cls = 包装类.TYPE`\\n\\n#### 哪些类型有Class对象\\n\\n1. 外部类，成损内部类，静态内部类，局部内部类，匿名内部类\\n2. interface:接口\\n3. 数组\\n4. enum:枚举\\n5. annotation:注解\\n6. 基本数据类型\\n7. void\\n\\n### 3. 类加载❗\\n\\n#### 1. 基本说明\\n\\n反射机制是java实现动态语言的关键，也就是**通过反射实现类动态加载**。\\n\\n1. 静态加载：编译时加载相关的类，如果没有则报错，依赖性太强\\n2. 动态加载：运行时加载需要的类，如果运行时不用该类，则不报错，降低了依赖性\\n\\n#### 2. 类加载时机\\n\\n1. 当创建对象时(new)  （静态加载）\\n2. 当子类被加载时（静态加载）\\n3. 调用类中的静态成员时（静态加载）\\n4. 通过反射（动态加载）\\n\\n![类加载过程图](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%9B%BE-310.png)\\n\\n![类加载各阶段完成任务](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%90%84%E9%98%B6%E6%AE%B5%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1-890.png)\\n\\n#### 3. 类加载五个阶段\\n\\n##### 3.1 加载阶段\\n\\nJVM在该阶段的主要目的是将字节码从不同的数据源（可能是class文件、也可能是jar包，甚至网络)转化为***二进制字节流加载到内存中***，并生成一个代表该类的java.lang.Class对象\\n\\n##### 3.2 连接阶段-验证\\n\\n1. 目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全\\n2. 包括：文件格式验证（是否以魔数 oxcafebabe 开头）、元数据验证、字节码验证和符号引用验证\\n3. 可以考虑使用-Xverify:none 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间\\n\\n##### 3.3 连接阶段-准备\\n\\nJVM会在该阶段对静态变量，分配内存并默认初始化（对应数据类型的默认初始值，如：int是0、String是null、boolean是false等)。这些变量所使用的内存都将在方法区中进行分配\\n\\n```java\\npublic int n1 = 10;//是实例属性，不是静态变量，因此在准备阶段是不会分配内存的\\npublic static int n2 = 20;//静态变量，会分配内存，但默认是0，在初始化的时候才会重新赋值为20\\npublic static final int n3 = 30;//常量，和静态变量不同，一旦赋值就不会变，所以在准备阶段就赋值为30\\n```\\n\\n##### 3.4 连接阶段-解析\\n\\n虚拟机将常量池内的符号引用替换为直接引用的过程。\\n\\n##### 3.5 初始化\\n\\n1. 到初始化阶段，才真正开始执行类中定义的 java 程序代码，此阶段是执行\\\\<clinit>() 方法的过程。\\n\\n2. \\\\<clinit>()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并进行合并。\\n\\n   ***<font color=\\\"red\\\">加载顺序：加载类 --> 静态变量、静态代码块(先后顺序加载) --> 成员变量、普通代码块 --> 构造方法</font>***\\n\\n3. 虚拟机会保证一个类的\\\\<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的\\\\<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行\\\\<clinit>()方法完毕\\n\\n### 4. 反射获取类的结构信息❗\\n\\n#### 1. java.lang.Class 类\\n\\n1. getName：获取全类名\\n2. getSimpleName：获取简单类名\\n3. getFields：获取所有public修饰的属性，包含本类以及父类的\\n4. getDeclaredFields：获取本类中所有属性\\n5. getMethods：获取所有public修饰的方法，包含本类以及父类的\\n6. getDeclaredMethods：获取本类中所有方法\\n7. getConstructors：获取所有public修饰的构造器，包含本类\\n8. getDeclaredConstructors：获取本类中所有构造器\\n9. getPackage：以Package形式返回包信息\\n10. getSuperClass：以Class形式返回父类信息\\n11. getInterfaces：以Class[]形式返回接口信息\\n12. getAnnotations：以Annotation[]形式返回注解信息\\n\\n#### 2. java.lang.reflect.Field 类\\n\\n1. getModifiers：以int形式返回修饰符\\n\\n   ***说明：默认修饰符是0，public是1，private是2，protected是4，static是8，final是16***\\n\\n2. getType：以Class形式返回类型\\n\\n3. getName：返回属性名\\n\\n#### 3.java.lang.reflect.Method 类\\n\\n1. getModifiers:以int形式返回修饰符\\n\\n   ***说明：默认修饰符是0，public是1，private是2，protected是4，static是8，final是16***\\n\\n2. getReturnType：以Class形式获取返回类型\\n\\n3. getName：返回方法名\\n\\n4. getParameterTypes：以Class[]返回参数类型数组\\n\\n#### 4. java.lang.reflect.Constructor 类\\n\\n1. getModifiers：以int形式返回修饰符\\n2. getName：返回构造器名（全类名）\\n3. getParameterTypes：以Class[]返回参数类型数组\\n\\n### 5. 反射爆破\\n\\n#### 1. 通过反射创建实例\\n\\n1. 调用类中的 public 修饰的无参构造器或者有参构造器\\n\\n2. Class 类相关方法\\n\\n   * newlnstance：调用类中的无参构造器，获取对应类的对象getConstructor(Class...clazz)：根据参数列表，获取对应的 public 构造器对象\\n   * getDecalaredConstructor(Class..clazz)：根据参数列表，获取对应的所有构造器对象\\n\\n3. Constructor 类相关方法\\n\\n   * setAccessible：暴破\\n\\n     ```java\\n     setAccessible(true);\\n     ```\\n\\n     ***<font color=\\\"red\\\">使用反射可以访问private构造器/方法/属性</font>***\\n\\n   * newlnstance(Object...obj)：调用构造器\\n\\n#### 2. 反射访问类中的属性\\n\\n1. 根据属性名获取Fieldi对象\\n\\n   ```java\\n   Field f = clazz对象.getDeclaredField(\\\"属性名\\\");\\n   ```\\n\\n2. 暴破\\n\\n   ```java\\n   f.setAccessible(true); //f是Field\\n   ```\\n\\n3. 访问\\n\\n   ```java\\n   f.set(o,值); //o表示对象\\n   f.get(o); \\n   ```\\n\\n   ***注意：如果是静态属性，则set和get中的参数o，\\t可以写成null***\\n\\n#### 3. 反射访问类中的方法\\n\\n1. 根据方法名和参数列表获取Method方法对象\\n\\n   ```java\\n   //得到本类指定的方法，xxx.class是指方法中的形参类型\\n   Method m = clazz.getDeclaredMethod(方法名，XX.class); \\n   ```\\n\\n2. 获取对象\\n\\n   ```java\\n   Object o = clazz.newlnstance();\\n   ```\\n\\n3. 暴破\\n\\n   ```java\\n   m.setAccessible(true);\\n   ```\\n\\n4. 访问\\n\\n   ```java\\n   //如果方法有返回值，那么统一返回Object，Object只是编译类型，运行类型还是返回类型\\n   Object returnValue = m.invoke(o,实参列表);\\n   ```\\n\\n   ***注意：如果是静态方法，则 invokel 的参数 o ,可以写成 null!***\\n\\n---\\n\\n## 🖇️JDBC 和 连接池\\n\\n### 1. 基本介绍\\n\\n1. JDBC为访问不同的数据库提供了统一的接口，为使用者屏蔽了细节问题。\\n2. Java程序员使用JDBC，可以连接任何提供了JDBC驱动程序的数据库系统，从而完成对数据库的各种操作。\\n\\n```java\\nClass.forName(\\\"com.mysql.cj.jdbc.Driver\\\"); //可以省略，但是不建议\\nConnection connection = DriverManager.getConnection(\\\"jdbc:mysql://localhost:3306/demo\\\", \\\"root\\\", \\\"lx*0+0-0\\\");\\nStatement statement = connection.createStatement();\\nString sql = \\\"insert into student values(006,\'lxuan\',\'男\',\'123456\')\\\";\\nstatement.executeUpdate(sql);\\nstatement.close();\\nconnection.close();\\n```\\n\\n### 2. Statement\\n\\n1. Statement对象用于执行静态SQL语句并返回其生成的结果的对象\\n2. 在连接建立后，需要对数据库进行访问，执行命名或是SQL语句，可以通过\\n   - Statement [存在SQL注入的问题]\\n   - ***PreparedStatement*** [预处理]\\n   - CallableStatement [存储过程]\\n3. Statementi对象执行SQL语句，存在SQL注入风险\\n4. SQL注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的SQL语句段或命令，恶意攻击数据库。\\n5. 要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了\\n\\n***<font color=\\\"red\\\">为避免产生 sql 注入问题，正常程序中我们不使用 Statement，而使用 PrepareStatement</font>***\\n\\n[JDBC API](assets/Java/JDBC%20API.md)\\n\\n### 3. 事务\\n\\n1. JDBC程序中当一个Connection对象创建时，***默认情况下是自动提交事务***，每次执行一个SQL语句时，如果执行成功，就会向数据库自动提交，而不能回滚。\\n2. JDBC程序中为了让多个SQL语句作为一个整体执行，需要使用事务\\n3. 调用`Connection的setAutoCommit(false)`可以取消自动提交事务\\n4. 在所有的SQL语句都成功执行后，调用 Connection 的 `commit()` 方法提交事务\\n5. 在其中某个操作失败或出现异常时，调用 Connection  的 `rollback()` 方法回滚事务\\n\\n### 4. 批处理\\n\\n1. 当需要成批插，入或者更新记录时。可以采用)va的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。\\n2. JDBC的批量处理语句包括下面方法：\\n   - `addBatch()`：添加需要批量处理的SQL语句或参数\\n   - `executeBatch()`：执行批量处理语句\\n   - `clearBatch()`：清空批处理包的语句\\n3. JDBC连接MySQL时，如果要使用批处理功能，请再 url 中加参数`?rewriteBatchedStatements = true`\\n4. 批处理往往和 PreparedStatement 一起搭配使用，可以既减少编译次数，又减少运行次数，效率大大提高\\n\\n### 5. 数据库连接池\\n\\n#### 5.1 基本介绍\\n\\n1. 预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。\\n2. 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序**重复使用**一个现有的数据库连接，而不是重新建立一个。\\n3. 当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列\\n\\n![数据库连接池](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0-3ef.png)\\n\\n#### 5.2 数据库连接池种类\\n\\n1. JDBC的数据库连接池使用javax.sql.DataSource来表示，DataSource 只是一个接口，该接口通常由第三方提供实现\\n2. **C3P0** 数据库连接池，速度相对较慢，稳定性不错（hibernate,spring）\\n3. DBCP 数据库连接池，速度相对c3p0较快，但不稳定\\n4. Proxool 数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点\\n5. BoneCP 数据库连接池，速度快\\n6. ***Druid***(德鲁伊)是阿里提供的数据库连接池，集DBCP、C3P0、Proxool 优点于一身的数据库连接池\\n\\n#### 5.3 C3P0\\n\\n1. 裸连\\n\\n    ```java\\n    ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();\\n    comboPooledDataSource.setDriverClass(\\\"com.mysql.cj.jdbc.Driver\\\");\\n    comboPooledDataSource.setJdbcUrl(\\\"jdbc:mysql://localhost:3306/demo\\\");\\n    comboPooledDataSource.setUser(\\\"root\\\");\\n    comboPooledDataSource.setPassword(\\\"lx*0+0-0\\\");\\n    //初始化连接数\\n    comboPooledDataSource.setInitialPoolSize(10);\\n    //最大连接数\\n    comboPooledDataSource.setMaxPoolSize(50);\\n    Connection connection = comboPooledDataSource.getConnection();\\n    System.out.println(\\\"连接成功\\\");\\n    connection.close();\\n    ```\\n\\n2. c3p0-config.xml\\n\\n    ```c3p0-config.xml\\n    <?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n    \\n    <c3p0-config>\\n       <!-- 使用默认的配置读取连接池对象 -->\\n       <default-config>\\n          <!--  连接参数 -->\\n          <property name=\\\"driverClass\\\">com.mysql.cj.jdbc.Driver</property>\\n          <property name=\\\"jdbcUrl\\\">jdbc:mysql:///bd2?serverTimezone=UTC&amp;useSSL=false</property>\\n          <property name=\\\"user\\\">root</property>\\n          <property name=\\\"password\\\">xxxxxxx</property>\\n    \\n          <!-- 连接池参数 -->\\n          <!--初始化申请的连接数量-->\\n          <property name=\\\"initialPoolSize\\\">5</property>\\n          <!--最大的连接数量(池子中最大的数量是10个)-->\\n          <property name=\\\"maxPoolSize\\\">10</property>\\n          <!--超时时间3000表示，如果出错，3s后报错-->\\n          <property name=\\\"checkoutTimeout\\\">3000</property>\\n       </default-config>\\n    \\n        <named-config name=\\\"mysql\\\">\\n            <!-- 配置数据库用户名 -->\\n            <property name=\\\"user\\\">root</property>\\n            <!-- 配置数据库密码 -->\\n            <property name=\\\"password\\\"></property>\\n            <!-- 配置数据库链接地址 -->\\n            <property name=\\\"jdbcUrl\\\">jdbc:mysql://localhost:3306/cdcol?useUnicode=true&amp;characterEncoding=UTF-8</property>\\n            <!-- 配置数据库驱动 -->\\n            <property name=\\\"driverClass\\\">com.mysql.jdbc.Driver</property>\\n            <!-- 数据库连接池一次性向数据库要多少个连接对象 -->\\n            <property name=\\\"acquireIncrement\\\">20</property>\\n            <!-- 初始化连接数 -->\\n            <property name=\\\"initialPoolSize\\\">10</property>\\n            <!-- 最小连接数 -->\\n            <property name=\\\"minPoolSize\\\">5</property>\\n            <!--连接池中保留的最大连接数。Default: 15 -->\\n            <property name=\\\"maxPoolSize\\\">30</property>\\n            <!--JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量。但由于预缓存的statements 属于单个connection而不是整个连接池。所以设置这个参数需要考虑到多方面的因素。如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default:0 -->\\n            <property name=\\\"maxStatements\\\">0</property>\\n            <!--maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数。Default: 0 -->\\n            <property name=\\\"maxStatementsPerConnection\\\">0</property>\\n            <!--c3p0是异步操作的，缓慢的JDBC操作通过帮助进程完成。扩展这些操作可以有效的提升性能 通过多线程实现多个操作同时被执行。Default:3 -->\\n            <property name=\\\"numHelperThreads\\\">3</property>\\n            <!--用户修改系统配置参数执行前最多等待300秒。Default: 300 -->\\n            <property name=\\\"propertyCycle\\\">3</property>\\n            <!-- 获取连接超时设置 默认是一直等待单位毫秒 -->\\n            <property name=\\\"checkoutTimeout\\\">1000</property>\\n            <!--每多少秒检查所有连接池中的空闲连接。Default: 0 -->\\n            <property name=\\\"idleConnectionTestPeriod\\\">3</property>\\n            <!--最大空闲时间,多少秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 -->\\n            <property name=\\\"maxIdleTime\\\">10</property>\\n            <!--配置连接的生存时间，超过这个时间的连接将由连接池自动断开丢弃掉。当然正在使用的连接不会马上断开，而是等待它close再断开。配置为0的时候则不会对连接的生存时间进行限制。 -->\\n            <property name=\\\"maxIdleTimeExcessConnections\\\">5</property>\\n            <!--两次连接中间隔时间，单位毫秒。Default: 1000 -->\\n            <property name=\\\"acquireRetryDelay\\\">1000</property>\\n            <!--c3p0将建一张名为Test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数那么属性preferredTestQuery将被忽略。你不能在这张Test表上进行任何操作，它将只供c3p0测试使用。Default: null -->\\n            <property name=\\\"automaticTestTable\\\">Test</property>\\n            <!-- 获取connnection时测试是否有效 -->\\n            <property name=\\\"testConnectionOnCheckin\\\">true</property>\\n        </named-config>\\n    </c3p0-config>\\n    ```\\n\\n#### 5.4 Druid(德鲁伊)\\n\\n```java\\nProperties properties = new Properties();\\nproperties.load(new FileReader(\\\"src\\\\\\\\druid.properties\\\"));\\nDataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\\nConnection connection = dataSource.getConnection();\\nSystem.out.println(\\\"Connection Success!\\\");\\nconnection.close();\\n```\\n\\n```druid.properties\\n# druid.properties文件的配置\\n#驱动加载\\ndriverClassName=com.mysql.cj.jdbc.Driver\\n#注册驱动\\nurl=jdbc:mysql://localhost:3306/demo?characterEncoding=utf-8\\n#连接数据库的用户名\\nusername=root\\n#连接数据库的密码\\npassword=lx*0+0-0\\n#属性类型的字符串，通过别名的方式配置扩展插件， 监控统计用的stat 日志用log4j 防御sql注入:wall\\nfilters=stat\\n#初始化时池中建立的物理连接个数。\\ninitialSize=2\\n#最大的可活跃的连接池数量\\nmaxActive=300\\n#获取连接时最大等待时间，单位毫秒，超过连接就会失效。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降， 如果需要可以通过配置useUnfairLock属性为true使用非公平锁。\\nmaxWait=60000\\n#连接回收器的运行周期时间，时间到了清理池中空闲的连接，testWhileIdle根据这个判断\\ntimeBetweenEvictionRunsMillis=60000\\nminEvictableIdleTimeMillis=300000\\n#用来检测连接是否有效的sql，要求是一个查询语句。\\nvalidationQuery=SELECT 1\\n#建议配置为true，不影响性能，并且保证安全性。 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis， 执行validationQuery检测连接是否有效。\\ntestWhileIdle=true\\n#申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。设置为false\\ntestOnBorrow=false\\n#归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能,设置为flase\\ntestOnReturn=false\\n#是否缓存preparedStatement，也就是PSCache。\\npoolPreparedStatements=false\\n#池中能够缓冲的preparedStatements语句数量\\nmaxPoolPreparedStatementPerConnectionSize=200\\n```\\n\\n### 6. Apache-DBUtils\\n\\njavaBean 一定要有无参构造器，底层使用了反射\\n\\n1. commons-dbutils是Apache组织提供的一个开源JDBC工具类库，它是对JDBC的封装，使用dbutils能极大简化jdbc编码的工作量\\n\\n* DbUtils类\\n  1. QueryRunner类：该类封装了SQL的执行，是线程安全的。可以实现增、删、改、查、批处理\\n  2. 使用QueryRunner类实现查询\\n  3. ResultSetHandler接口：该接口用于处理java.sql.ResultSet，将数据按要求转换为另一种形式\\n\\n```\\nArrayHandler：把结果集中的第一行数据转成对象数组。\\nArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。\\nBeanHandler：将结果集中的第一行数据封装到一个对应的)avaBean实例中。\\nBeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。\\nColumnListHandler：将结果集中某一列的数据存放到List中。\\nKeyedHandler(name)：将结果集中的每行数据都封装到Map里，再把这些map再存到一个map里，其key为指定的key。\\nMapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。\\nMapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List\\n```\\n\\n### 7. DAO和增删改查通用方法-BasicDao\\n\\n#### 基本说明\\n\\n1. DAO：data access object 数据访问对象\\n2. 这样的通用类，称为BasicDao，是专门和数据库交互的，即完成对数据库（表）的crud操作。\\n3. 在BaiscDao的基础上，实现一张表对应一个Dao，更好的完成功能，比如Customer表-Customer.java(javabean)-CustomerDao.java\\n\\n## 🖇️正则表达式\\n\\n1. `\\\\\\\\d`：表示任意一个数字\\n\\n   ```java\\n   String regstr \\\"(\\\\\\\\d\\\\\\\\d)(\\\\\\\\d\\\\\\\\d)\\\";\\n   //创建模式对象[即正则表达式对象]\\n   Pattern pattern = Pattern.compile(regstr);\\n   //创建匹配器matcher,按照正则表达式的规则去匹配content字符串\\n   Matcher matcher = pattern.matcher(content);\\n   ```\\n\\n2. `\\\\\\\\`：元字符-转义符：在我们使用正则表达式去检索某些特殊字符的时候，需要用到转义符号，否则检索不到结果，甚至会报错的。***<font color=\\\"red\\\">在Java的正则表达式中，两个`\\\\\\\\`代表其他语言中的一个`\\\\`</font>***，需要用到转义符号的字符有：`.*+()$/\\\\？[]^{}`\\n\\n3. `()`：在正则表达式中表示分组，`group(0)`表示匹配到的子字符串，`group(1)`表示子字符串终点第一组的子串...依次类推\\n\\n4. `matcher.find()`：根据指定的规则，定位满足规则的子字符串...\\n\\n5. `int groups[]`：找到后将子字符串的**开始索引**和**结束索引+1**记录到matcher的属性`int groups[]`中...\\n\\n6. `oldLast`：同时记录oldLast的值为子字符串的`结束索引+1`的值，即下次执行find时，就从oldLast的索引开始匹配\\n\\n### 1. 基本介绍\\n\\n如果要想灵活的运用正则表达式，必须了解其中各种元字符的功能，元字符从功能上大致分为：\\n\\n1. 限定符：用于指定其***前面的字符或组合项***连续出现多少次\\n\\n   | 符号  |              解释               |    示例     |                        解释                        |\\n   | :---: | :-----------------------------: | :---------: | :------------------------------------------------: |\\n   |   *   | 指定字符重复0次回或n次（无要求) |   (abc)*    |         仅包含任意个abc的字符串，等效于\\\\w*         |\\n   |   +   | 指定字符重复1次或n次（至少一次) |  m+(abc)*   |       以至少1个m开头，后接任意个abc的字符串        |\\n   |   ?   | 指定字符重复0次或1次（最多一次) |   m+abc?    |         以至少1个m开头，后接ab，c可有可无          |\\n   |  {n}  |         只能输入n个字符         |  [abcd]{3}  |       由abcd中字母组成的任意长度为3的字符串        |\\n   | {n,}  |         指定至少n个匹配         | [abcd]{3,}  |     由abcd中字母组成的任意长度不小于3的字符串      |\\n   | {n,m} |   指定至少n个但不多于m个匹配    | [abcd]{3,5} | 由abcd中字母组成的任意长度不小于3，不大于5的字符串 |\\n\\n   |  ?   | 当此字符紧随任何其他限定符(*、+、？、{n}、{n,}、{n,m})之后时，匹配模式是\\\"非贪心的。\\\"非贪心的\\\"模式匹配搜索到的、尽可能短的字符串，而默认的\\\"贪心的\\\"模式匹配搜索到的、尽可能长的字符串。例如，在字符串\\\"oooo\\\"中，\\\"o+?\\\"只匹配单个\\\"o”,而\\\"o+\\\"匹配所有\\\"o\\\"。 |\\n   | :--: | :----------------------------------------------------------: |\\n\\n   ***Java 默认是贪婪匹配，{n,m}优先匹配 m 个***\\n\\n2. 选择匹配符\\n\\n   | 符号 |            解释            |  示例  |   解释   |\\n   | :--: | :------------------------: | :----: | :------: |\\n   |  \\\\|  | 匹配“\\\\|”之前或之后的表达式 | ab\\\\|cd | ad或者cd |\\n\\n3. 分组组合和反向引用符\\n\\n   | 常用分组构造形式  |                             说明                             |\\n   | :---------------: | :----------------------------------------------------------: |\\n   |     (pattern)     | 非命名捕获。捕获匹配的子字符串。编号为零的第一个捕获是由整个正则表达式模式匹配的文本，其它捕获结果则根据左括号的顺序从1开始自动编号。 |\\n   | (?\\\\<name>pattern) | 命名捕获。将匹配的子字符串捕获到一个组名称或编号名称中。用于name的字符串不能包含任何标点符号，并且不能以数字开头。可以使用单引号替代尖括号，例如(?\'name\') |\\n   |    (?:pattern)    | 匹配pattern但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用\\\"or\\\"字符(\\\\|)组合模式部件的情况很有用。<br/>例如，`industr(?:y|ies)`是比`industry|industries`更经济的表达式。 |\\n   |    (?=pattern)    | 它是一个非捕获匹配。例如，`Windows(?=95|98|NT|2000)`匹配`Windows 2000`中的`Windows`，但不匹配`Windows 3.1`中的`Windows`。 |\\n   |    (?!pattern)    | 该表达式匹配不处于匹配pattern的字符串的起始点的搜索字符串。它是一个非捕获匹配。例如，`Windows(?!95|98|NT|2000)`匹配`Windows 3.1`中的`Windows`，但不匹配`Windows 2000`中的`Windows`。 |\\n\\n3. 特殊字符\\n\\n4. 字符匹配符\\n\\n   | 符号 |                             解释                             |    示例    |                             解释                             |\\n   | :--: | :----------------------------------------------------------: | :--------: | :----------------------------------------------------------: |\\n   | [ ]  |                       可接收的字符列表                       |   [abcd]   |                寻找a、b、c、d中的任意一个字符                |\\n   | [^]  |                       不接收的字符列表                       |  [^abcd]   |    寻找除了a、b、c、d中的任意一个字符，包括数字和特殊字符    |\\n   |  -   |                            连字符                            |    A-Z     |                       任意单个大写字母                       |\\n   |  .   |   匹配除 \\\\n 以外的任何字符，如果需要匹配.自身，需要使用\\\\\\\\.   |   a...b    |     以a开头，b结尾，中间包括3个任意字符的长度为5的字符串     |\\n   |  \\\\d  |             匹配单个数字字符，相当于<br />[0-9]              | \\\\d{3}(\\\\d)? | 包含3个或4个数字的字符串<br />**?的意思是：?前的一个或一组符号可能有也可能没有** |\\n   |  \\\\D  |           匹配单个非数字字符，相当于<br />[\\\\^0-9]            |  \\\\D(\\\\d)*   |   以单个非数字字符开头，后接任意个数字（任意个可以为0个）    |\\n   |  \\\\w  | 匹配单个数字、大小写字母、下划线字符相当于<br />[0-9a-zA-Z]  | \\\\d{3}\\\\w{4} |         以3个数字字符开头的长度为7的数字和字母字符串         |\\n   |  \\\\W  | 匹配单个非数字、大小写字母、下划线字符，相当于<br />\\\\[^0-9a-zA-Z] |  \\\\W+\\\\d{2}  | 以至少1个非数字字母字符开头，2个数字字符结尾的字符串<br />**+指的是：+号前的一个或一组符号至少存在一次** |\\n   |  \\\\s  |              匹配任何空白字符（空格，制表符等）              |            |                                                              |\\n   |  \\\\S  |                     匹配任何非空空白字符                     |            |                                                              |\\n\\n5. 定位符\\n\\n   | 符号 |          解释          |       示例       |                             解释                             |\\n   | :--: | :--------------------: | :--------------: | :----------------------------------------------------------: |\\n   |  ^   |      指定起始字符      |  \\\\^[0-9]+[a-z]*  |        以至少1个数字开头，后接任意个小写字母的字符串         |\\n   |  \\\\$   |      指定结束字符      | \\\\^[0-9]\\\\\\\\-[a-z]+$ | 以1个数字开头后接连字符”-”，并以至少1个小写字母结尾的字符串  |\\n   |  \\\\b  |  匹配目标字符串的边界  |     lxuan\\\\b      | 这里说的字符串的边界指的是子串间有空格，或者是目标字符串的结束位置 |\\n   |  \\\\B  | 匹配目标字符串的非边界 |     lxuan\\\\\\\\B     |                      和b的含义刚刚相反                       |\\n\\n\\n### 2. 分组、捕获、反向引用\\n\\n1. 分组\\n\\n   我们可以用圆括号组成一个比较复杂的匹配模式，那么一个圆括号的部分我们可以看作是一个子表达式/一个分组。\\n\\n2. 捕获\\n\\n   把正则表达式中子表达式/分组匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用，从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。组0代表的是整个正则式\\n\\n3. 反向引用\\n\\n   圆括号的内容被捕获后，可以在这个括号后被使用，从而写出一个比较实用的匹配模式，这个我们称为反向引用，这种引用既可以是在正则表达式内部，也可以是在正则表达式外部，内部反向引用`\\\\\\\\分组号`，外部反向引用`$分组号`\\n\\n   ```正则\\n   1.要匹配两个连续的相同数字：(\\\\d)\\\\1\\n   2.要匹配五个连续的相同数字：(\\\\d)\\\\1{4}\\n   3.要匹配个位与干位相同，十位与百位相同的数5225,1551：(\\\\d)(\\\\d)\\\\2\\\\1\\n   ```\\n\\n\\n### 3. 正则表达式三个常用类\\n\\n1. Pattern类\\n\\n   pattern对象是一个正则表达式对象。Pattern类没有公共构造方法。要创建一个Pattern对象，调用其公共静态方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数，比如：Pattern r = Pattern.compile(pattern);\\n\\n   `Pattern.matches()`：是否为整体匹配\\n\\n2. Matcher类\\n\\n   Matcher对象是对输入字符串进行解释和匹配的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象\\n\\n3. PatternSyntaxException\\n\\n   PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误。\\n\\n---\",\"articleCover\":\"http://figurebed-1311634249.cos.ap-beijing.myqcloud.com/articles/181fc31919c955d8e1cfb958ab132e18.jpg\",\"articleTitle\":\"Java 中级\",\"categoryName\":\"学习和技术总结\",\"id\":74,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '152.69.196.109', '美国', '2022-10-11 19:41:18', NULL);
INSERT INTO `tb_operation_log` VALUES (1275, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 📙Java基础\\n\\n## 1. 类与对象\\n\\n![对象在内存中的存在形式](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/Java/%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%9C%A8%E5%BD%A2%E5%BC%8F-cd2.jpg)\\n\\n\\n\\n### 1.1 作用域\\n\\n|  作用域   | 当前类 | 同一包 | 子类 | 不同包 |\\n| :-------: | :----: | :----: | :--: | :----: |\\n|  public   |   √    |   √    |  √   |   √    |\\n| protected |   √    |   √    |  √   |   x    |\\n|  default  |   √    |   √    |  x   |   x    |\\n|  private  |   √    |   x    |  x   |   x    |\\n\\n全局变量（属性）可以不赋值，直接使用，因为有默认值，局部变量必须赋值后才能使用，因为没有默认值。\\n\\n1. 属性和局部变量可以重名，访问时遵循就近原则。\\n2. 同一个作用域中，两个局部变量不能重名。\\n3. 全局变量可以加修饰符，局部变量不行。\\n\\n### 1.2 构造器\\n\\n  构造方法又叫构造器（constructor），是类的一种特殊方法，它的主要作用是完成对<u>*新对象的初始化*</u>。\\n\\n1. 构造器修饰符可以默认，也可以是public protected private\\n\\n2. <u>构造器没有返回值</u>\\n\\n3. <u>方法名和类名必须一样</u>\\n\\n4. 参数列表和成员方法一样的规则\\n\\n5. 构造器的调用，由系统完成\\n\\n6. <u>构造器可以重载</u>\\n\\n   new 一个新对象的时候，会自动执行构造器，因此new时可以直接赋值，如：\\n\\n   Person p1 = new Person (\\\"梁渲\\\"， 20);\\n\\n### 1.3 this关键字\\n\\nthis(参数列表)只能在构造器中使用，也就是在一个构造器中访问另一个构造器，必须放在第一条语句，即同一给构造器中只能出现一次\\n\\n### 1.4 对象可以为空，也就是说返回值可以为null\\n\\n### 1.5 数组可以为空\\n\\n### 1.6 方法中的变量称为局部变量，之外的变量称为全局变量，this.是全局变量\\n\\n### 1.7 一个Java源文件中可以有多个主类，但是只能有一个公共类或者没有公共类\\n\\njava源文件在运行后会被编译成一个个class文件，但public类只能有一个，而主类main()方法可以有多个，main()方法是程序执行的入口\\n\\n## 2. 包\\n\\n作用：\\n\\n1. 区分相同名字的类\\n2. 当类很多时，可以很好的管理类[看Java API 文档]\\n3. 控制访问范围\\n\\n---\\n\\n\\n\\n## 3. 继承\\n\\n1. 如果子类有这个属性，则输出，如果子类没有这个属性，则依次往上找父类的属性。\\n\\n2. 私有属性不能直接在子类中访问，需要用父类提供的公共方法去访问，如下。\\n\\n   ```java\\n   class A {\\n     private name = \\\"张三\\\";\\n     \\n     public String getName () {\\n       return name;\\n     }\\n   }\\n   class B extends A {\\n     \\n   }\\n   main{\\n     B b1 = new B;\\n     System.out.print(b1.name); // 报错\\n     System.out.print(b1.getName); // 返回张三\\n   }\\n   ```\\n\\n3. 子类的任何方法的第一行都存在一个 super() 方法，该方法用于执行父类的无参构造器；但 this(); 和 super() 不能共存，若是子类的构造器中存在 this(); 方法，则super(); 也就不会存在了。\\n\\n---\\n\\n## 4. 多态\\n\\n1. 一个对象的编译类型和运行类型可以不一致\\n2. 编译类型在定义对象时，就确定了，不能改变\\n3. 运行类型是可以变化的\\n4. 编译类型是看定义时 = 的左边，运行类型看 = 右边\\n\\n### 4.1 Java的动态绑定机制\\n\\n1. 当调用对象方法的时候，该方法会和该对象的**内存地址/运行类型**绑定\\n2. 当调用对象的属性时，没有动态绑定机制，哪里声明就在哪里使用\\n\\n\\n\\n## 5 == 和 equals\\n\\n1. == 是一个比较运算符\\n\\n   1. 既可以判断基本类型，又可以判断引用类型\\n   2. 如果判断基本类型，判断的是值是否相等。\\n   3. 如果判断引用类型，判断的是地址是否相同，即判断是否是同一个对象。\\n\\n   **<font color = \\\"red\\\">如果 == 两边一个是基本类型，一个是引用类型，则只要存在基本类型就是判断两边的值是否相等</font>**\\n\\n2. equal 是 Object 类中的方法，只能判断引用类型，默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等\\n\\n   **<font color = \\\"red\\\">字符串对象的比较不能使用 == ，而应该使用 String 类的 equals 方法</font>**\\n\\n| 名称  | 概念                             | 用于基本数据类型     | 用于引用类型                                                 |\\n| ----- | -------------------------------- | :------------------- | ------------------------------------------------------------ |\\n| ==    | 比较运算符                       | 可以，判断值是否相等 | 可以，判断两个对象是否相等                                   |\\n| equal         | object类的方法，Java类都可以使用 | 不可以               | 可以，默认是判断两个对象是否相等，但是子类往往重写该方法，比较对象的属性是否相等，比如（String,Integer) |\\n\\n## 6. javap 反编译\\n\\n![javap](assets/Java/javap.md)\\n\\n## 7. 三目运算符\\n\\n```java\\npublic static void main(String[] args) {\\n  Object obj1 = true ? new Integer(1) : new Double(2.0);\\n  System.out.println(obj1);\\n}\\n//输出结果：1.0\\n```\\n\\n1. 三目运算符只能使用基本数据类型，所以编译自动拆箱为 int、double\\n2. 三目运算符是一个整体，要求数据类型一致，所以编译 int 自动提升为精度更高的 double\\n\\n## 8. Java 中只有值传递，没有引用传递\\n\\n这里涉及到值传递和引用传递两种传递机制：\\n\\n1. **值传递(pass by value)：** 是指在调用方法(或者函数)时，将实际参数复制一份传递到方法(或者函数)中，这样在函数中如果对形式参数进行修改，将不会影响到实参。\\n\\n2. **引用传递(pass by reference)：** 在调用方法(函数)时，将实参的地址直接传递到函数中，那么在函数中对形参进行修改，将影响到实参。\\n\\n**<font color = \\\"red\\\">Java 中只有值传递，始终是传值的。参数是基本数据类型，复制的是具体值；如果参数是引用类型，把地址当成值，复制的是地址；还有String类是一个非常特殊的类，它是不可变的。</font>**\\n\\n## 9. equals 和 hashCode\\n\\n**<font color = \\\"red\\\">equals 相等 hashCode 一定相等，hashCode 相等 equals不一定相等</font>**\\n\\n---\",\"articleCover\":\"http://figurebed-1311634249.cos.ap-beijing.myqcloud.com/articles/62902b7bd74a3d1cb06e3aafd354e0c8.png\",\"articleTitle\":\"Java 基础\",\"categoryName\":\"学习和技术总结\",\"id\":73,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '152.69.196.109', '美国', '2022-10-11 19:43:45', NULL);
INSERT INTO `tb_operation_log` VALUES (1276, '文章模块', '修改', '/admin/articles/top', 'com.minzheng.blog.controller.ArticleController.updateArticleTop', '修改文章置顶', '[{\"id\":72,\"isTop\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '152.69.196.109', '美国', '2022-10-11 19:44:06', NULL);
INSERT INTO `tb_operation_log` VALUES (1277, '相册模块', '删除', '/admin/photos/albums/11', 'com.minzheng.blog.controller.PhotoAlbumController.deletePhotoAlbumById', '根据id删除相册', '[11]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.102', '山西省太原市 移动', '2022-10-22 22:48:32', NULL);
INSERT INTO `tb_operation_log` VALUES (1278, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 1 选择题\\n\\n1. 下列工作中不属于项目的是\\n   - [ ] A.策划一场婚礼\\n   - [ ] B.开发一款软件\\n   - [x] C.为人民服务\\n   - [ ] D.主持一场会议\\n\\n2. 下列不属于项目特性的是\\n   - [ ] A.一次性  \\n   - [x] B.新颖性 \\n   - [ ] C.目标性  \\n   - [ ] D.约束性\\n\\n3. 项目管理的对象集中在对3P的管理，下列不属于3P的是\\n   - [ ] A.人员  \\n   - [ ] B.问题  \\n   - [ ] C.过程  \\n   - [x] D.保证\\n\\n4. 项目管理需要在互相间有冲突的要求中找到平衡，除了以下哪个\\n   - [x] A.甲方和乙方的利益          \\n   - [ ] B.范围、时间、成本、质量\\n   - [ ] C.有不同项目需求和期望的项目干系人 \\n   - [ ] D.明确和未明确表达的需求\\n\\n5. 项目管理中的三种组织结构，哪一种沟通最为复杂\\n   - [ ] A.职能型  \\n   - [ ] B.纯项目 \\n   - [x] C.矩阵型  \\n   - [ ] D.都一样\\n\\n6. 项目经理的职责不包括以下哪项内容\\n   - [ ] A.开发计划   \\n   - [ ] B.组织实施  \\n   - [ ] C.项目控制  \\n   - [x] D.系统支持\\n\\n7. 可以构建一部分系统的模型，通过用户试用提出优缺点，最好选择（）生存期模型 \\n   - [ ] A.增量式模型  \\n   - [x] B.原型    \\n   - [ ] C.螺旋型    \\n   - [ ] D.v模型\\n\\n8. 乙方在项目初始阶段的主要任务不包含以下哪一项\\n   - [ ]   A.项目分析   \\n   - [ ] B.招投标   \\n   - [x] C.合同管理   \\n   - [ ] D.合同签署\\n\\n10. 需求分析完成的标志是\\n    - [ ] A.开发出初步模型   \\n    - [x] B.提交一份完整的软件需求规格说明书\\n    - [ ] C.提交一份工作称述  \\n    - [ ] D.提交项目章程\\n\\n11. WBS中的每一个具体细目通常都指定唯一的\\n    - [x] A.编码  \\n    - [ ] B.责任人  \\n    - [ ] C.功能模块  \\n    - [ ] D.提交日期\\n\\n12. 项目计划方法中，（）是能直观的表达软件开发众多工序之间的逻辑关系与时间关系。 \\n    - [ ] A.滚动计划法  \\n    - [ ] B.工作结构分解 \\n    - [x] C.网络计划技术 \\n    - [ ] D.构造性成本法\\n\\n13. 代码行估算方法属于以下基本估算方法中的哪一种。（）\\n    - [x] A.分解法    \\n    - [ ] B.算数模型    \\n    - [ ] C.专家判断   \\n    - [ ] D.比例法\\n\\n14. 在项目估算的基本内容中，（）是软件项目量化的结果，很大程度上代表了项目范围的大小。\\n\\n    - [ ] A.风险估算  \\n\\n    - [ ] B.工作量估算 \\n\\n    - [x] C.规模估算  \\n\\n    - [ ] D.其他估算\\n\\n15. 下列不属于按照详细情况划分的3个等级构造性成本模型的是（）\\n    - [ ] A.基本 COCOMO    \\n    - [ ] B.中间 COCOMO \\n    - [x] C.发展 COCOMO    \\n    - [ ] D.详细 COCOMO\\n\\n16. 项目管理人员根据个人能力、是否有空闲时间进行项目活动人员分配时有A、P、R、S 四种类别，其中A表示（）\\n    - [x] A.负责    \\n    - [ ] B.参与   \\n    - [ ] C.检查    \\n    - [ ] D.批准\\n\\n17. 压缩软件项目的工期时，你应该关注（）\\n    - [x] A.关键路径  \\n    - [ ] B.非关键路径  \\n    - [ ] C.准关键活动  \\n    - [ ] D.活动缓冲期\\n\\n18. “软件编码完成之后，我才可以对它进行软件测试”这句话体现了项目活动之间的哪种关系\\n    - [ ] A.开始-开始   \\n    - [x] B.结束-开始   \\n    - [ ] C.结束-结束   \\n    - [ ] D.开始-结束\\n\\n19. 在成本管理过程中，项目经理确定的每个时间段，各个工作单元的成本是\\n    - [ ] A.估算    \\n    - [ ] B.预算     \\n    - [x] C.直接成本   \\n    - [ ] D.间接成本\\n\\n20. 估算文件不属于以下哪一项\\n    - [x] A.功能模块  \\n    - [ ] B.质量标准  \\n    - [ ] C.资源及数量   \\n    - [ ] D.估算成本\\n\\n21. 下列不属于软件评审方法的是\\n    - [ ] A.同行评审   \\n    - [ ] B.走查     \\n    - [ ] C.会议审查    \\n    - [x] D.测试\\n\\n22. 软件项目质量的组织保证是\\n    - [ ]  A.顾客     \\n    - [ ] B.用户     \\n    - [ ] C.提供者     \\n    - [x] D.SEPG组\\n\\n23. 项目质量管理的最终责任由谁来承担\\n    - [ ] A.项目开发经理        \\n    - [ ] B.质量经理\\n    - [ ] C.采购经理          \\n    - [x] D.项目经理\\n\\n24. “质量成本”是一个项目管理概念，它说明了下列哪项成本\\n    - [x] A.额外需求的成本      \\n    - [ ] B.需求变更的成本\\n    - [ ] C.确保符合需求的成本    \\n    - [ ] D.固定成本\\n\\n25. 软件项目的一个重要特点是需求变更频繁，在项目管理中缺乏有效的需求变更控制流程就极有可能引起项目风险。若按照风险来源的阶段对风险进行分类，这种项目风险属于\\n    - [x] A.需求风险  \\n    - [ ] B.设计风险   \\n    - [ ] C.编程风险    \\n    - [ ] D.维护风险\\n\\n26. 在风险分析过程中，确定已经识别的一个风险事件是无法避免的，也是不能减轻的，也不能投保，这是一个关键的风险事件，一旦发生可能造成项目的失败，项目经理最佳的选择是\\n    - [ ] A.降低风险的级别，项目团队将找到一个克服故障的方法\\n    - [x] B.特别关注，加强管理该风险事件和所有的相关事件\\n    - [ ] C.让风险评估小组继续分析该风险事件，直到降低预期影响\\n    - [ ] D.忽略风险评估，因为不管赋予什么值，都只是一个估算\\n\\n27. 风险的三个属性是\\n    - [ ] A.风险发生的时间、地点、责任人 \\n    - [ ] B.风险事件、时间、影响\\n    - [x] C.风险事件、概率、影响 \\n    - [ ] D.风险数量、风险影响程度、概率\\n\\n28. 下列哪项不是风险管理的过程\\n    - [ ] A.风险评估  \\n    - [ ] B.风险识别   \\n    - [ ] C.风险规划   \\n    - [x] D.风险收集\\n\\n29. 由于政府的一项新规定，某项目的项目经理必须变更该项目的范围。项目目标已经做了若干变更，项目经理已经对项目的技术和管理文件做了必要的修改，他下一步应该\\n    - [x] A.及时通知项目干系人     \\n    - [ ] B.修改公司的知识管理体系\\n    - [ ] C.获取客户的正式认可    \\n    - [ ] D.获得政府认可\\n\\n30. 小王负责一个管理信息系统项目，最近在与客户共同进行的质量审查中发现一个程序模块不符合客户的需求，进行追溯时，也未发现相应的变更请求。最终小王被迫对这一模块进行再设计并重新编程，造成此项返工的原因可解是\\n    - [ ] A.未进行需求变更      \\n    - [x] B.未进行范围确认 \\n    - [ ] C.未进行变更管理      \\n    - [ ] D.质量管理过严\\n\\n31. 客户已经正式接收了项目，该项目的项目经理下一步工作将是\\n    - [x] A.适当的将接收文件分发给其他项目干系人\\n    - [ ] B.将项目总结向项目档案库归档\\n    - [ ] C.记录你与小组成员获得的经验 \\n    - [ ] D.进行项目审计\\n\\n32. 在某个信息系统项目中，存在新老系统切换问题，在设置项目计划网络图时，新系统上线和老系统下线之间应设置成（）的关系。\\n    - [ ] A.结束—开始(FS型)      \\n    - [ ] B.结束—结束(FF型)\\n    - [x] C.开始—结束(SF型)     \\n    - [ ] D.开始一开始(ss型)\\n\\n33. 质量控制是\\n    - [ ] A.对每个工作包增加工作时间 \\n    - [x] B.项目生存期的各个阶段都要实施的\\n    - [ ] C.只需要做一次         \\n    - [ ] D.只有大的项目才需要\\n\\n34. 采用网络模型反向遍历的目的在于决定（）\\n    - [ ] A.关键路径          \\n    - [ ] B.最早完工日期\\n    - [x] C.最迟开始日期        \\n    - [ ] D.赶工日期\\n\\n35. 激励中的期望理论认为\\n    - [ ] A.相信付出的努力很可能会产生成功的结果\\n    - [ ] B.管理者不应对工人寄望过高\\n    - [x] C.激励应与期望中具有价值的产出相关联\\n    - [ ] D.管理者不应期望薪水高的雇员工作更努力\\n\\n36. 制定项目计划时，首先应该关注的是\\n    - [x] A.项目范围说明书        \\n    - [ ] B.工作分解结构 \\n    - [ ] C.风险管理计划        \\n    - [ ] D.质量计划\\n\\n37. 在进度可视化监控方法中，哪一种方法能简单、清除地展示项目整体进度\\n    - [ ] A.延迟图  \\n    - [ ] B.时间线   \\n    - [x] C.甘特图   \\n    - [ ] D.计划与实际对比图\\n\\n38. 在项目进行过程中，一个开发人员接到某个用户的电话，用户要求更改系统中存在的一个问题，这个开发人员应该\\n    - [ ] A.马上改正问题   \\n    - [x] B.记录问题并提交项目经理\\n    - [ ] C.不予理睬     \\n    - [ ] D.通过测试部经理，要求确认问题是否存在\\n\\n39. 下面哪一种质量改进方法最不可能产生积极结果\\n    - [ ] A.持续改进   \\n    - [ ] B.统计质量过程   \\n    - [ ] C.客户跟踪过程   \\n    - [x] D.增加检验\\n\\n40. 项目的项目范围已经发生变更，因此成本基线也将发生变更，项目经理需要尽快\\n    - [ ] A.进行范围变更策略     \\n    - [ ] B.更新预算\\n    - [ ] C.记录获得经验      \\n    - [x] D.执行得到批准的范围变更\\n\\n# 2 填空题\\n\\n1.  项目管理的基本内容是计划、组织和（**监控**）\\n\\n2. 根据项目管理方法论可以将项目管理分为阶段化管理、（**量化管理**）和优化管理，\\n\\n3. 影响项目可行性的因素可分为:经济可行性、技术可行性、（**风险和不确定性**）。\\n\\n4. 由于项目的组织结构中职能型和纯项目型的两个极端代表，为了综合它们各自的优势,（**矩阵型**）应用而生，他是职能型和纯项目型的结合体。\\n\\n5. 滚动计划法是一种迭代方法，它具有分而治之、（**逐步求精**）、动态规划、和谐过渡的特点。\\n\\n6. （**WBS 工作分解结构**）是一种将复杂问题分解为简单问题，然后再根据分解的结果进行计划的方法。\\n\\n7. WBs 最低层次的项目可交付成果称为（**工作包**）。\\n\\n8. （**德尔菲法**）是一种专家评估技术，适用于在没有或者没有足够历史数据的情况下，来评定软件采用不同的技术或新技术带来的差异，但专家的水平及对项目的理解程度是工作中的关键点。\\n\\n9. 里程碑事件的工期一般设置为（**零**）\\n\\n10. 在ADM 网络图中，有时为了表示逻辑关系，需要设置一个虚活动，虚活动是不需要时间和资源的，一般用（**虚箭线**）表示:\\n\\n11. （**里程碑**）定义了当前阶段完成的标准和下阶段启动的前提或条件。\\n\\n12. （**质量计划**）是进行项目质量管理、实现项目质量方针和目标的具体体现。\\n\\n13. （度量）提供了对项目进度评估、质量状况的洞察力和用于决策的有关数据。\\n\\n14. （**风险评审技术**）是为了适应某些有高度不确定性和风险性的决策问题而开发一种网络仿真系统。\\n\\n15. 外包是（**风险转移**）类型的风险处理策略。\\n\\n16. 涉及多个领域工作的复杂项目最好采用（**矩阵型组织**）来管理。\\n\\n17. 软件开发中大多数的变更都是来源于（**需求变更**）。\\n\\n18. （**收尾**）是项目生命周期的最后一个阶段，也是形成产品闭环的关键步骤。\\n\\n19. 马斯洛需求层次论把需求分为生理需求、安全需求、社会需求、尊重需求、（自我实现需求）。\\n\\n20. 良好的工作氛围概括起来就是：开放、（**真诚**）、平等、信任。\\n\\n# 3 判断题\\n\\n1. 受控环境中的项目是组织、管理和控制项目的方法，强调通过管理方法使项目环境得到控制。      （√）\\n\\n2. 软件不同于一般的传统的产品，它是对物理世界的一种抽象，是逻辑性、知识性的产物。        （√）\\n\\n3. 项目管理的核心是成本。  （×）\\n\\n4. 根据项目管理方法论可以将项目管理分为阶段化管理、量化管理和优化管理，其中量化管理是项目管理的基本方法。 （×）\\n\\n5. 项目建议书必须尽可能的详细。（×） \\n\\n6. 项目可行性分析是项目启动阶段的关键活动，旨在判断一个项目是否值得做或者是挑选许多待选项目中的最佳项目。 （√）\\n\\n7. 投资回收期分析法是经济可行性分析中最可靠的方法。（×）\\n\\n8. 极限编程的基本思想是“沟通、简单、反馈、勇气”。（√）\\n\\n9. WBS最底层的项目只能由一人负责。（√）\\n\\n10. 在软件项目管理中，计划编制是最复杂的阶段，却经常不受重视。（√）\\n\\n11. 软件项目的项目计划可以由一个人独立完成，不需要与项目干系人沟通。（×）12. PMBOK 将项目计划过程分为核心过程和辅助过程两个部分。（√）\\n\\n13. 软件估算的方法有许多，可以分为直接方法和间接方法，如功能点估算方法就是软件规模估算中的直接方法。（×）\\n\\n14. 软件项目的估算结果都是比较准确地。（×）\\n\\n15. 在进行软件项目估算时，可以参照其他企业的估算模型。（√）\\n\\n16. 成本估算一般情况下都可能不是非常精确，尤其是软件项目更是如此。（√）\\n\\n17. 甘特图可以显示任务的基本信息，使用甘特图能方便地查看任务的工期，开始和结束时间以及资源的信息。（√）\\n\\n18. 为了得到一个相对准确的估算结果，项目管理者应该系统的学习相关的成本（√）\\n\\n19. IT项目尤其是软件项目的成本管理一直没有一个好的口碑，但成本超支很少见。()错\\n\\n20. 成本估算不准确有很多原因，有主观原因也有客观原因。（√）\\n\\n21. PSP 指软件工程过程组，其要质量目标是编译和单元测试之前发现和修复缺陷。()错\\n\\n22. 产品的缺陷密度或者测试阶段的缺陷率是概括性指标。（√）\\n\\n23. 软件度量主要包括3部分:项目度量、产品度量和过程度量（√）\\n\\n24. 鱼骨图分析方法要完成从小刺到主刺的思维和分析过程。（×）\\n\\n25. TOP风险清单中的条目越多越好。（×）\\n\\n26. 风险识别、风险评估、风险规划、风险控制是风险管理的四个过程。（√）\\n\\n27. 当风险发生的概率极高、风险后果影响很严重时，才可以考虑采用回避风险策略。（×）\\n\\n28. 风险是损失发生的不确定性，是对潜在的、未来可能发生损害的一种度量。（√）\\n\\n29. 在当今高科技环境下，x理论和期望理论可以用来激励一个团队员工的工作士气。（×）\\n\\n30. 在项目早期和信息不足的时候，可以采用自下而上的估算方法进行成本估算。（×）\\n\\n31. 需求分析过程是确定项目如何实现的过程，并确定项目的技术方案（×）\\n\\n31. 软件项目的估算结果是比较准确的。（×）\\n\\n32. 基线产品是不能修改的。（×）\\n\\n33. 在 IT 项目中，许多专家都认为：对于成功，威胁最大的就是沟通的失败。（√）\\n\\n34. 采购是为了换行项目而从项目团队外部采购或者获取产品、服务或者结果的过程。（√）\\n\\n35. 进度和成本是关系最为老切的两个目的，几乎成了对立关系，进度的缩短一定依靠增加成本实现，而成本的降低也一定牺牲工期进度为代价的。（×）\\n\\n36. 项目早期和信息不足的时候，可以采用自下而上的估算方法进行成本估算（×）\\n\\n37. 统计需求变更请求的数量是配置审核过程。（√）\\n\\n38. 质量保证属于检查职能，而质量控制属于管理职能。（×）\\n\\n39. 采用德尔菲方法来标识风险可以减少人为的偏差，以便作出正确决定（√）\\n\\n40. 取消采用具有高风险的新技术，而采用原来热悉的技术\\\"是一种转移风险的规划策略（√）\\n\\n# 4 简答题\\n\\n1. **项目生命周期分为5个阶段，请简要概述（P6）**\\n\\n   1. 启动。项目获得授权正式被立项，并成立项目组，宣告项目开始。启动是一种认可过程，用来正式认可一个新项目或新阶段的存在。\\n   2. 计划。明确项目范围，定义和评估项目目标，选择实现项目目标的最佳策略，制订项目计划。\\n   3. 执行。调动资源，完成项目管理计划中确定的工作。\\n   4. 控制。监控和评估项目偏差，必要时采取纠正行动，以保证项自计划的执行，实现项目目标。\\n   5. 结束。完成项目验收，使其按程序结束。\\n\\n2. **简述 WBS 制定的原则。**\\n\\n   1. 某项具体的任务应该在一个工作包且只能在一个工作包中出现\\n   2. WBS中某项任务的内容是其下所有WBS项的总和\\n   3. 一个工作包只能由一个人负责\\n   4. 任务的分解，尽量与实际执行方式保持一致。\\n   5. 分解合理，具有良好的稳定性和适应性\\n   6. 鼓励项目团队成员积极参与创建WBS\\n   7. 所有成果需要文档化\\n\\n3.  **什么是质量管理，软件质量管理的保证组织有哪些?** \\n\\n   质量管理是指：确定质量方针、目标和职责并在质量体系中通过质量计划、质量控制、质量保证和质量改进使其实施的全部管理职能的所有活动。\\n\\n   1、采用技术手段和工具；2、组织正式技术平时；3、加强软件测试；4、推行软件工程规范（标准）；5、对软件的变更进行控制；6对软件质量进行度量。\\n\\n4. **简述应对风险的基本措施?**\\n\\n   1. 规避。通过变更项目计划消除风险或风险的触发条件，使目标免受影响。\\n   2. 转移。不能消除风险，而是将项目风险的结果连同应对的权利转移给第三方。\\n   3. 弱化。将风险时间的概率或结果降低到一个可以接受的程度，其中降低发生的概率更为有效。\\n   4. 接受。不改变项目计划，而考虑发生后如何应对\\n\\n5. **风险监控的措施有哪些?**\\n\\n   1. 风险识别\\n   2. 风险估计 \\n   3. 风险管理策略 \\n   4. 风险解决 \\n   5. 风险监控\\n\\n6. **如何确保知识经验共享?**\\n\\n   1. 企业角度\\n\\n      要先提倡和强调重要性。\\n\\n      其次要确立正确而鼓舞人心的知识管理愿景和战略目标。\\n\\n      再次要建立指导监督团队来提供足够的推动力。\\n\\n      激励知识共享的贡献者。\\n\\n   2. 个人角度\\n\\n      做到无私奉献，无偿分享。\\n\\n      积极参与知识的分享和讨论，在讨论中不断学习、相互提高，真正实现从知识到能力的跨越。\\n\\n7. 什么是绩效管理？如何做好绩效管理？\\n\\n   所谓绩效管理就是企业为了持续发展及保持良好的发展趋势，为了提高业绩与效率，制定一定的激励方式，让员工可以按时完成任务，整体提高员工工作积极性和提高企业产能。\\n\\n    1、绩效管理准备工作\\n\\n    2、明确绩效分工流程\\n\\n   3、做好绩效管理方案\\n\\n   4、绩效管理的反馈\\n\\n   5、绩效管理的改进\\n\\n   6、绩效管理的维护及存档\\n\\n8. 如何在项目监控阶段，区分缺陷的优先级和重要性？\\n\\n​\\t\\t\\t1. 缺陷跟踪\\n\\n​\\t\\t\\t2. 技术检查\\n\\n​\\t\\t\\t3. 源代码追踪\\n\\n​\\t\\t\\t4. 测试\\n\\n9. 简述项目验收的内容\\n\\n​\\t\\t\\t1. 软件系统验收\\n\\n​\\t\\t\\t2. 质量验收\\n\\n​\\t\\t\\t3. 资料验收\\n\\n10. 在进行项目总结时，应该注意哪些问题？\\n\\n​\\t\\t\\t1. 项目概况，质量结果分析；\\n\\n​\\t\\t\\t2. 项目进展情况；\\n\\n​\\t\\t\\t3. 好的经验；\\n\\n​\\t\\t\\t4. 不足之处；\\n\\n​\\t\\t\\t5. 改进方案和建议。\\n\\n# 5 计算器\\n\\n一、一个软件企业现在面对两个项目的选择\\n\\n一个软件企业现在面对两个项目的选择。他们经过分析得得出这样的结论:如果做项目A，盈利的概率是20%，可以盈利30万元，但是同时亏损的概既率是80%，亏损4万元;如果做项目B.盈利的概率是70%，盈利6万元，但同时有两种亏损的可能，其一是10%的概率亏损2万，其二是20%的概率亏损5万。请用决策树的方法计计算出两个项目的预期收益，并判断哪个项目是比较有利的选择。\\n\\n（1）：该企业两个项目的决策树如下：\\n\\n![image-20221101235338174](assets/软件项目管理考试/image-20221101235338174.png)\\n\\n---\\n\\n一、阅读以下说明，回答问题1至问题3。\\n\\n某信息系统集成企业承担了甲方的信息系统集成项目，在项目的采购过程中，某项采购合同是在甲方的授意下签订的，然而在项目进展过程中，项目经理发现该采购产品高于市场价格，而且有些性能指标也没有能够完全满足合同规定要求。当项目经理发现此类问题进行调查时，发现该供应商的资质和声誉都存在问题，并且就在不久前已经被其他公司并购，最麻烦的是合同的付款条件是提前支付相关款项，合同的大部分采购款已经支付。\\n\\n在项目的中期验收中，甲方发现了部分采购产品存在的问题，并要求项目组进行返工和更换相关产品。项目经理则以采购供应商是由甲方推荐为由，拒绝进行返工和更换。而甲方则认为，项目合同里面并没有规定由甲方承担采购责任，甲方只是为项目组推荐了部分供应商，而供应商已被收购，原先的公司已经不存在，原先的责任人已经离职为由，拒绝根据合同相关条款更换产品，项目经理对此束手无策。项目经理和甲方就该问题相持不下，项目处于停滞状态。\\n\\n1. 问题1结合案例，请指出项目组在采购合同管理中存在什么问题?\\n\\n   **合同签订有问题，不应轻易采用甲方的推荐。 2)合同支付条款不合理。 3)合同执行有问题，设备指标不满足要求时，未能及时有效的管控。4)合同变更问题，供应商被并购以后，合同没有及时变更相应条款。**\\n\\n2. 问题2在采购合同中，支付方式的规定一般包括哪些方面的内容?甲方的做法是否妥当，是分散否该为此承担主要责任?\\n\\n   **支付方式的内容:1)支付货款的条件;2)结算支付的时限、方式;3)拒付货款。发包方有权部分或全部拒付货款。4)甲方的做法不妥当。不应该承担主要责任。**\\n\\n3. 问题3供应商是否可以以公司变更、负责人离职为由，拒绝履行公司变更前签订的协议?为什么?对此而日经那该加何外开?\\n\\n   **不可以。因为供应商公司变更不影响其对已经售出的货物的质量保证义务，新公司需要继续履行原供应商签订的协议。项目经理可以启动索赔程序。先进行调解，调解不成，由经济合同仲裁委员会进行调解或仲裁。**\\n\\n---\\n\\n二、在项目的中期验收中，甲方发现了部分采购产品存在的问题，并要求项目组选行返工和更换相关产 品。项目经理则以采购供应商是由甲方推荐为由，拒绝送行返工和更换。而甲方则认为，项目合同里 面并没有规定由甲方系担采购责任，甲方只是为项目组推荐了部分供应商，而供应南己枝收购，原先 的公司己经不存在，原先的责任人已经高职为由，拒绝根据合同相关条款更换产品，项目经理对此束 手无策。项目经理和甲方就该问题相持不下，项目处手停滞状态。 \\n\\n问题 1 结合案例，请指出项目组在采购合同管理中存在什么问题？ \\n\\n**1）合同签订有问题，不应经易采用甲方的推荐。2）合同支付条款不合理。3）合同执行有问题，设备 指标不满足要求时，未能及时有放的管拉。4）合同支更问题，供应商被并购以后，合同没有及时变更 相应条款。** \\n\\n问题 2 在采购合同中，交付方式的规定一般包括哪些方面的内容？甲方的做法是否妥当，是否该为比 承担主要贡任？ \\n\\n**支付方式的内容：1）支付货款的条件：2）结算支付的时限、方式：3）拒付货款。发包方存权部分或 全部柜付货款。4）平方的做法不妥当，不应该承担主要责任。**\\n\\n问题 3 供应商是否可以以公司变更、众责人离职为由，拒绝履行公司变更前签订的协议？为什么？对 此项目经理该如何处理？ \\n\\n**不可以。因为供应商公司变更不影响其对己经售出的货物的质量保证义务，新公司需要继续履行原供 应商签订的协议。 项目经理可以启动索赔程序。先进行调解，阔解不成，由经济合同仲教委员会选行调解或仲裁。**\\n\\n---\\n\\n三、软件项目需求变更\\n\\n1. 提出变更\\n2. 评估变更\\n3. 决策变更\\n4. 实施变更\\n5. 验证变更\\n\\n---\\n\\n四、阅读以下说明，回答问题1至问题 3。\\n\\n某创业型公司乙在2015年1月，凭借着报价低的优势中标承接了一个信息系统工程项目。项目建设内容主要包括建设方甲公司的北京总公司ERP信息系统建设，以及甲公司成都分公司的机房改造项目。甲乙两公司协商签订了工程额为100万元的总价合同，工期为一年。乙公司指派有过ERP项目经验的张工承担项目经理，因公司还处于创业期间，所以公司管理层非常注重成本的控制，要求项目经理严格控制成本，每周汇报项目的实际花费。为了满足\\n\\n低成本的要求，考虑到北京、成都两地的材料、差旅费用等问题，在征得甲公司与管理层的同意后，张工将机房改造工程外包给成都当地的丙公司，并在合同中要求丙公司必须在2015年底之前完工。\\n\\n项目执行期间。张工指派了一名成本控制专员，负责每周统计该项目ERP 部分所发生的费用。同时向管理层提交费用统计报告。项目进展到6月份。项目 ERP 部分实际发生的总费用为30 万元。成都赶上了梅雨季节，丙公司反馈因机房处于某大厦的低层，太潮湿，机房改造工程被迫暂停。待梅雨季节过后继续施工。\\n\\n项目执行到2015年底，机房改造项目已确定无法在2016年1月如期完工，ERP部分虽然基本到了后期的测试阶段，但其总费用也已经达到了 60 万元。\\n\\n问题1根据案例，2016年1月机房改造工程无法如期完工，请指出乙公司是否可以向丙公司索赔?如可以，请说明可以申请什么索赔?如不可以，请说明理由。\\n\\n**可以索赔。可以申请延长工期索赔。 (机房改造属于室内施工，雨季不是进度延期的不可抗因素)**\\n\\n问题2结合以上案例，请帮助张工提出成本管理及成本控制方面的改进措施。\\n\\n**1.根据项目实际情况，制定成本管理计划，并得到公司高层批准。2、采用科学方法对项目进行成本估算和预算。 3、按计划掌握项目实际成本支出情况(包括北京、成都两地)。4将实际成本与成本计划进行比较，掌握项目成本绩效。 5、如果实际成本不符合计划，则进行偏差分析，制定相关纠偏措施。 6、做好相关文档的记录和存档。**\\n\\n问题 3结合以上案例，在项目后期，请帮助项目经理张工提出一些可以弥补工期耽误的方法。\\n\\n**1.要求丙方采取措施进行赶工。 2.对丙方工程进度严格控制。3.与甲方进行沟通，必要时，修改进度计划。**\\n\\n---\\n\\n五、已知某信息工程项目由A到G7个活动组成，项目根据项目目标特别施工期要求，经过分析、定义及评审，给出了该项目的活动历时。活动资源及活动逻辑关系如下表所示:\\n\\nA:需求分析 10 2\\n\\nB:软件设计 10 2 A\\n\\nC:测试案例编写 12 3 A\\n\\nD:编程实现 15 4 B\\n\\nE:软件测试 15 3 C、D\\n\\nF:编写用户手册 5 1 A\\n\\nG:调试软件系统 3 2 E\\n\\n \\n\\n问题 1:绘制该项目活动的前导网络图问题\\n\\n问题2:指出该项目的关键路径和工期问题\\n\\n问题3:指出其他路径的项目缓冲期\\n\\n问题4:为了配合甲方公司成立庆典，甲方要求该项目提前10天完工，并同意支付额外费用。承建单位经过论证，同意了甲方要求并按规范执行了审批流程。为了保质保量按期完工，\\n\\n![image-20221102005159821](assets/软件项目管理考试/image-20221102005159821.png)\\n\\n---\\n\\n\\n\",\"articleCover\":\"\",\"articleTitle\":\"软件项目管理\",\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.100', '山西省太原市 移动', '2022-11-02 01:44:28', NULL);
INSERT INTO `tb_operation_log` VALUES (1279, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 1 选择题\\n\\n1. 下列工作中不属于项目的是\\n   - [ ] A.策划一场婚礼\\n   - [ ] B.开发一款软件\\n   - [x] C.为人民服务\\n   - [ ] D.主持一场会议\\n\\n2. 下列不属于项目特性的是\\n   - [ ] A.一次性  \\n   - [x] B.新颖性 \\n   - [ ] C.目标性  \\n   - [ ] D.约束性\\n\\n3. 项目管理的对象集中在对3P的管理，下列不属于3P的是\\n   - [ ] A.人员  \\n   - [ ] B.问题  \\n   - [ ] C.过程  \\n   - [x] D.保证\\n\\n4. 项目管理需要在互相间有冲突的要求中找到平衡，除了以下哪个\\n   - [x] A.甲方和乙方的利益          \\n   - [ ] B.范围、时间、成本、质量\\n   - [ ] C.有不同项目需求和期望的项目干系人 \\n   - [ ] D.明确和未明确表达的需求\\n\\n5. 项目管理中的三种组织结构，哪一种沟通最为复杂\\n   - [ ] A.职能型  \\n   - [ ] B.纯项目 \\n   - [x] C.矩阵型  \\n   - [ ] D.都一样\\n\\n6. 项目经理的职责不包括以下哪项内容\\n   - [ ] A.开发计划   \\n   - [ ] B.组织实施  \\n   - [ ] C.项目控制  \\n   - [x] D.系统支持\\n\\n7. 可以构建一部分系统的模型，通过用户试用提出优缺点，最好选择（）生存期模型 \\n   - [ ] A.增量式模型  \\n   - [x] B.原型    \\n   - [ ] C.螺旋型    \\n   - [ ] D.v模型\\n\\n8. 乙方在项目初始阶段的主要任务不包含以下哪一项\\n   - [ ]   A.项目分析   \\n   - [ ] B.招投标   \\n   - [x] C.合同管理   \\n   - [ ] D.合同签署\\n\\n10. 需求分析完成的标志是\\n    - [ ] A.开发出初步模型   \\n    - [x] B.提交一份完整的软件需求规格说明书\\n    - [ ] C.提交一份工作称述  \\n    - [ ] D.提交项目章程\\n\\n11. WBS中的每一个具体细目通常都指定唯一的\\n    - [x] A.编码  \\n    - [ ] B.责任人  \\n    - [ ] C.功能模块  \\n    - [ ] D.提交日期\\n\\n12. 项目计划方法中，（）是能直观的表达软件开发众多工序之间的逻辑关系与时间关系。 \\n    - [ ] A.滚动计划法  \\n    - [ ] B.工作结构分解 \\n    - [x] C.网络计划技术 \\n    - [ ] D.构造性成本法\\n\\n13. 代码行估算方法属于以下基本估算方法中的哪一种。（）\\n    - [x] A.分解法    \\n    - [ ] B.算数模型    \\n    - [ ] C.专家判断   \\n    - [ ] D.比例法\\n\\n14. 在项目估算的基本内容中，（）是软件项目量化的结果，很大程度上代表了项目范围的大小。\\n\\n    - [ ] A.风险估算  \\n\\n    - [ ] B.工作量估算 \\n\\n    - [x] C.规模估算  \\n\\n    - [ ] D.其他估算\\n\\n15. 下列不属于按照详细情况划分的3个等级构造性成本模型的是（）\\n    - [ ] A.基本 COCOMO    \\n    - [ ] B.中间 COCOMO \\n    - [x] C.发展 COCOMO    \\n    - [ ] D.详细 COCOMO\\n\\n16. 项目管理人员根据个人能力、是否有空闲时间进行项目活动人员分配时有A、P、R、S 四种类别，其中A表示（）\\n    - [x] A.负责    \\n    - [ ] B.参与   \\n    - [ ] C.检查    \\n    - [ ] D.批准\\n\\n17. 压缩软件项目的工期时，你应该关注（）\\n    - [x] A.关键路径  \\n    - [ ] B.非关键路径  \\n    - [ ] C.准关键活动  \\n    - [ ] D.活动缓冲期\\n\\n18. “软件编码完成之后，我才可以对它进行软件测试”这句话体现了项目活动之间的哪种关系\\n    - [ ] A.开始-开始   \\n    - [x] B.结束-开始   \\n    - [ ] C.结束-结束   \\n    - [ ] D.开始-结束\\n\\n19. 在成本管理过程中，项目经理确定的每个时间段，各个工作单元的成本是\\n    - [ ] A.估算    \\n    - [ ] B.预算     \\n    - [x] C.直接成本   \\n    - [ ] D.间接成本\\n\\n20. 估算文件不属于以下哪一项\\n    - [x] A.功能模块  \\n    - [ ] B.质量标准  \\n    - [ ] C.资源及数量   \\n    - [ ] D.估算成本\\n\\n21. 下列不属于软件评审方法的是\\n    - [ ] A.同行评审   \\n    - [ ] B.走查     \\n    - [ ] C.会议审查    \\n    - [x] D.测试\\n\\n22. 软件项目质量的组织保证是\\n    - [ ]  A.顾客     \\n    - [ ] B.用户     \\n    - [ ] C.提供者     \\n    - [x] D.SEPG组\\n\\n23. 项目质量管理的最终责任由谁来承担\\n    - [ ] A.项目开发经理        \\n    - [ ] B.质量经理\\n    - [ ] C.采购经理          \\n    - [x] D.项目经理\\n\\n24. “质量成本”是一个项目管理概念，它说明了下列哪项成本\\n    - [x] A.额外需求的成本      \\n    - [ ] B.需求变更的成本\\n    - [ ] C.确保符合需求的成本    \\n    - [ ] D.固定成本\\n\\n25. 软件项目的一个重要特点是需求变更频繁，在项目管理中缺乏有效的需求变更控制流程就极有可能引起项目风险。若按照风险来源的阶段对风险进行分类，这种项目风险属于\\n    - [x] A.需求风险  \\n    - [ ] B.设计风险   \\n    - [ ] C.编程风险    \\n    - [ ] D.维护风险\\n\\n26. 在风险分析过程中，确定已经识别的一个风险事件是无法避免的，也是不能减轻的，也不能投保，这是一个关键的风险事件，一旦发生可能造成项目的失败，项目经理最佳的选择是\\n    - [ ] A.降低风险的级别，项目团队将找到一个克服故障的方法\\n    - [x] B.特别关注，加强管理该风险事件和所有的相关事件\\n    - [ ] C.让风险评估小组继续分析该风险事件，直到降低预期影响\\n    - [ ] D.忽略风险评估，因为不管赋予什么值，都只是一个估算\\n\\n27. 风险的三个属性是\\n    - [ ] A.风险发生的时间、地点、责任人 \\n    - [ ] B.风险事件、时间、影响\\n    - [x] C.风险事件、概率、影响 \\n    - [ ] D.风险数量、风险影响程度、概率\\n\\n28. 下列哪项不是风险管理的过程\\n    - [ ] A.风险评估  \\n    - [ ] B.风险识别   \\n    - [ ] C.风险规划   \\n    - [x] D.风险收集\\n\\n29. 由于政府的一项新规定，某项目的项目经理必须变更该项目的范围。项目目标已经做了若干变更，项目经理已经对项目的技术和管理文件做了必要的修改，他下一步应该\\n    - [x] A.及时通知项目干系人     \\n    - [ ] B.修改公司的知识管理体系\\n    - [ ] C.获取客户的正式认可    \\n    - [ ] D.获得政府认可\\n\\n30. 小王负责一个管理信息系统项目，最近在与客户共同进行的质量审查中发现一个程序模块不符合客户的需求，进行追溯时，也未发现相应的变更请求。最终小王被迫对这一模块进行再设计并重新编程，造成此项返工的原因可解是\\n    - [ ] A.未进行需求变更      \\n    - [x] B.未进行范围确认 \\n    - [ ] C.未进行变更管理      \\n    - [ ] D.质量管理过严\\n\\n31. 客户已经正式接收了项目，该项目的项目经理下一步工作将是\\n    - [x] A.适当的将接收文件分发给其他项目干系人\\n    - [ ] B.将项目总结向项目档案库归档\\n    - [ ] C.记录你与小组成员获得的经验 \\n    - [ ] D.进行项目审计\\n\\n32. 在某个信息系统项目中，存在新老系统切换问题，在设置项目计划网络图时，新系统上线和老系统下线之间应设置成（）的关系。\\n    - [ ] A.结束—开始(FS型)      \\n    - [ ] B.结束—结束(FF型)\\n    - [x] C.开始—结束(SF型)     \\n    - [ ] D.开始一开始(ss型)\\n\\n33. 质量控制是\\n    - [ ] A.对每个工作包增加工作时间 \\n    - [x] B.项目生存期的各个阶段都要实施的\\n    - [ ] C.只需要做一次         \\n    - [ ] D.只有大的项目才需要\\n\\n34. 采用网络模型反向遍历的目的在于决定（）\\n    - [ ] A.关键路径          \\n    - [ ] B.最早完工日期\\n    - [x] C.最迟开始日期        \\n    - [ ] D.赶工日期\\n\\n35. 激励中的期望理论认为\\n    - [ ] A.相信付出的努力很可能会产生成功的结果\\n    - [ ] B.管理者不应对工人寄望过高\\n    - [x] C.激励应与期望中具有价值的产出相关联\\n    - [ ] D.管理者不应期望薪水高的雇员工作更努力\\n\\n36. 制定项目计划时，首先应该关注的是\\n    - [x] A.项目范围说明书        \\n    - [ ] B.工作分解结构 \\n    - [ ] C.风险管理计划        \\n    - [ ] D.质量计划\\n\\n37. 在进度可视化监控方法中，哪一种方法能简单、清除地展示项目整体进度\\n    - [ ] A.延迟图  \\n    - [ ] B.时间线   \\n    - [x] C.甘特图   \\n    - [ ] D.计划与实际对比图\\n\\n38. 在项目进行过程中，一个开发人员接到某个用户的电话，用户要求更改系统中存在的一个问题，这个开发人员应该\\n    - [ ] A.马上改正问题   \\n    - [x] B.记录问题并提交项目经理\\n    - [ ] C.不予理睬     \\n    - [ ] D.通过测试部经理，要求确认问题是否存在\\n\\n39. 下面哪一种质量改进方法最不可能产生积极结果\\n    - [ ] A.持续改进   \\n    - [ ] B.统计质量过程   \\n    - [ ] C.客户跟踪过程   \\n    - [x] D.增加检验\\n\\n40. 项目的项目范围已经发生变更，因此成本基线也将发生变更，项目经理需要尽快\\n    - [ ] A.进行范围变更策略     \\n    - [ ] B.更新预算\\n    - [ ] C.记录获得经验      \\n    - [x] D.执行得到批准的范围变更\\n\\n# 2 填空题\\n\\n1.  项目管理的基本内容是计划、组织和（**监控**）\\n\\n2. 根据项目管理方法论可以将项目管理分为阶段化管理、（**量化管理**）和优化管理，\\n\\n3. 影响项目可行性的因素可分为:经济可行性、技术可行性、（**风险和不确定性**）。\\n\\n4. 由于项目的组织结构中职能型和纯项目型的两个极端代表，为了综合它们各自的优势,（**矩阵型**）应用而生，他是职能型和纯项目型的结合体。\\n\\n5. 滚动计划法是一种迭代方法，它具有分而治之、（**逐步求精**）、动态规划、和谐过渡的特点。\\n\\n6. （**WBS 工作分解结构**）是一种将复杂问题分解为简单问题，然后再根据分解的结果进行计划的方法。\\n\\n7. WBs 最低层次的项目可交付成果称为（**工作包**）。\\n\\n8. （**德尔菲法**）是一种专家评估技术，适用于在没有或者没有足够历史数据的情况下，来评定软件采用不同的技术或新技术带来的差异，但专家的水平及对项目的理解程度是工作中的关键点。\\n\\n9. 里程碑事件的工期一般设置为（**零**）\\n\\n10. 在ADM 网络图中，有时为了表示逻辑关系，需要设置一个虚活动，虚活动是不需要时间和资源的，一般用（**虚箭线**）表示:\\n\\n11. （**里程碑**）定义了当前阶段完成的标准和下阶段启动的前提或条件。\\n\\n12. （**质量计划**）是进行项目质量管理、实现项目质量方针和目标的具体体现。\\n\\n13. （度量）提供了对项目进度评估、质量状况的洞察力和用于决策的有关数据。\\n\\n14. （**风险评审技术**）是为了适应某些有高度不确定性和风险性的决策问题而开发一种网络仿真系统。\\n\\n15. 外包是（**风险转移**）类型的风险处理策略。\\n\\n16. 涉及多个领域工作的复杂项目最好采用（**矩阵型组织**）来管理。\\n\\n17. 软件开发中大多数的变更都是来源于（**需求变更**）。\\n\\n18. （**收尾**）是项目生命周期的最后一个阶段，也是形成产品闭环的关键步骤。\\n\\n19. 马斯洛需求层次论把需求分为生理需求、安全需求、社会需求、尊重需求、（自我实现需求）。\\n\\n20. 良好的工作氛围概括起来就是：开放、（**真诚**）、平等、信任。\\n\\n# 3 判断题\\n\\n1. 受控环境中的项目是组织、管理和控制项目的方法，强调通过管理方法使项目环境得到控制。      （√）\\n\\n2. 软件不同于一般的传统的产品，它是对物理世界的一种抽象，是逻辑性、知识性的产物。        （√）\\n\\n3. 项目管理的核心是成本。  （×）\\n\\n4. 根据项目管理方法论可以将项目管理分为阶段化管理、量化管理和优化管理，其中量化管理是项目管理的基本方法。 （×）\\n\\n5. 项目建议书必须尽可能的详细。（×） \\n\\n6. 项目可行性分析是项目启动阶段的关键活动，旨在判断一个项目是否值得做或者是挑选许多待选项目中的最佳项目。 （√）\\n\\n7. 投资回收期分析法是经济可行性分析中最可靠的方法。（×）\\n\\n8. 极限编程的基本思想是“沟通、简单、反馈、勇气”。（√）\\n\\n9. WBS最底层的项目只能由一人负责。（√）\\n\\n10. 在软件项目管理中，计划编制是最复杂的阶段，却经常不受重视。（√）\\n\\n11. 软件项目的项目计划可以由一个人独立完成，不需要与项目干系人沟通。（×）12. PMBOK 将项目计划过程分为核心过程和辅助过程两个部分。（√）\\n\\n13. 软件估算的方法有许多，可以分为直接方法和间接方法，如功能点估算方法就是软件规模估算中的直接方法。（×）\\n\\n14. 软件项目的估算结果都是比较准确地。（×）\\n\\n15. 在进行软件项目估算时，可以参照其他企业的估算模型。（√）\\n\\n16. 成本估算一般情况下都可能不是非常精确，尤其是软件项目更是如此。（√）\\n\\n17. 甘特图可以显示任务的基本信息，使用甘特图能方便地查看任务的工期，开始和结束时间以及资源的信息。（√）\\n\\n18. 为了得到一个相对准确的估算结果，项目管理者应该系统的学习相关的成本（√）\\n\\n19. IT项目尤其是软件项目的成本管理一直没有一个好的口碑，但成本超支很少见。()错\\n\\n20. 成本估算不准确有很多原因，有主观原因也有客观原因。（√）\\n\\n21. PSP 指软件工程过程组，其要质量目标是编译和单元测试之前发现和修复缺陷。()错\\n\\n22. 产品的缺陷密度或者测试阶段的缺陷率是概括性指标。（√）\\n\\n23. 软件度量主要包括3部分:项目度量、产品度量和过程度量（√）\\n\\n24. 鱼骨图分析方法要完成从小刺到主刺的思维和分析过程。（×）\\n\\n25. TOP风险清单中的条目越多越好。（×）\\n\\n26. 风险识别、风险评估、风险规划、风险控制是风险管理的四个过程。（√）\\n\\n27. 当风险发生的概率极高、风险后果影响很严重时，才可以考虑采用回避风险策略。（×）\\n\\n28. 风险是损失发生的不确定性，是对潜在的、未来可能发生损害的一种度量。（√）\\n\\n29. 在当今高科技环境下，x理论和期望理论可以用来激励一个团队员工的工作士气。（×）\\n\\n30. 在项目早期和信息不足的时候，可以采用自下而上的估算方法进行成本估算。（×）\\n\\n31. 需求分析过程是确定项目如何实现的过程，并确定项目的技术方案（×）\\n\\n31. 软件项目的估算结果是比较准确的。（×）\\n\\n32. 基线产品是不能修改的。（×）\\n\\n33. 在 IT 项目中，许多专家都认为：对于成功，威胁最大的就是沟通的失败。（√）\\n\\n34. 采购是为了换行项目而从项目团队外部采购或者获取产品、服务或者结果的过程。（√）\\n\\n35. 进度和成本是关系最为老切的两个目的，几乎成了对立关系，进度的缩短一定依靠增加成本实现，而成本的降低也一定牺牲工期进度为代价的。（×）\\n\\n36. 项目早期和信息不足的时候，可以采用自下而上的估算方法进行成本估算（×）\\n\\n37. 统计需求变更请求的数量是配置审核过程。（√）\\n\\n38. 质量保证属于检查职能，而质量控制属于管理职能。（×）\\n\\n39. 采用德尔菲方法来标识风险可以减少人为的偏差，以便作出正确决定（√）\\n\\n40. 取消采用具有高风险的新技术，而采用原来热悉的技术\\\"是一种转移风险的规划策略（√）\\n\\n# 4 简答题\\n\\n1. **项目生命周期分为5个阶段，请简要概述（P6）**\\n\\n   1. 启动。项目获得授权正式被立项，并成立项目组，宣告项目开始。启动是一种认可过程，用来正式认可一个新项目或新阶段的存在。\\n   2. 计划。明确项目范围，定义和评估项目目标，选择实现项目目标的最佳策略，制订项目计划。\\n   3. 执行。调动资源，完成项目管理计划中确定的工作。\\n   4. 控制。监控和评估项目偏差，必要时采取纠正行动，以保证项自计划的执行，实现项目目标。\\n   5. 结束。完成项目验收，使其按程序结束。\\n\\n2. **简述 WBS 制定的原则。**\\n\\n   1. 某项具体的任务应该在一个工作包且只能在一个工作包中出现\\n   2. WBS中某项任务的内容是其下所有WBS项的总和\\n   3. 一个工作包只能由一个人负责\\n   4. 任务的分解，尽量与实际执行方式保持一致。\\n   5. 分解合理，具有良好的稳定性和适应性\\n   6. 鼓励项目团队成员积极参与创建WBS\\n   7. 所有成果需要文档化\\n\\n3.  **什么是质量管理，软件质量管理的保证组织有哪些?** \\n\\n   质量管理是指：确定质量方针、目标和职责并在质量体系中通过质量计划、质量控制、质量保证和质量改进使其实施的全部管理职能的所有活动。\\n\\n   1、采用技术手段和工具；2、组织正式技术平时；3、加强软件测试；4、推行软件工程规范（标准）；5、对软件的变更进行控制；6对软件质量进行度量。\\n\\n4. **简述应对风险的基本措施?**\\n\\n   1. 规避。通过变更项目计划消除风险或风险的触发条件，使目标免受影响。\\n   2. 转移。不能消除风险，而是将项目风险的结果连同应对的权利转移给第三方。\\n   3. 弱化。将风险时间的概率或结果降低到一个可以接受的程度，其中降低发生的概率更为有效。\\n   4. 接受。不改变项目计划，而考虑发生后如何应对\\n\\n5. **风险监控的措施有哪些?**\\n\\n   1. 风险识别\\n   2. 风险估计 \\n   3. 风险管理策略 \\n   4. 风险解决 \\n   5. 风险监控\\n\\n6. **如何确保知识经验共享?**\\n\\n   1. 企业角度\\n\\n      要先提倡和强调重要性。\\n\\n      其次要确立正确而鼓舞人心的知识管理愿景和战略目标。\\n\\n      再次要建立指导监督团队来提供足够的推动力。\\n\\n      激励知识共享的贡献者。\\n\\n   2. 个人角度\\n\\n      做到无私奉献，无偿分享。\\n\\n      积极参与知识的分享和讨论，在讨论中不断学习、相互提高，真正实现从知识到能力的跨越。\\n\\n7. 什么是绩效管理？如何做好绩效管理？\\n\\n   所谓绩效管理就是企业为了持续发展及保持良好的发展趋势，为了提高业绩与效率，制定一定的激励方式，让员工可以按时完成任务，整体提高员工工作积极性和提高企业产能。\\n\\n    1、绩效管理准备工作\\n\\n    2、明确绩效分工流程\\n\\n   3、做好绩效管理方案\\n\\n   4、绩效管理的反馈\\n\\n   5、绩效管理的改进\\n\\n   6、绩效管理的维护及存档\\n\\n8. 如何在项目监控阶段，区分缺陷的优先级和重要性？\\n\\n​\\t\\t\\t1. 缺陷跟踪\\n\\n​\\t\\t\\t2. 技术检查\\n\\n​\\t\\t\\t3. 源代码追踪\\n\\n​\\t\\t\\t4. 测试\\n\\n9. 简述项目验收的内容\\n\\n​\\t\\t\\t1. 软件系统验收\\n\\n​\\t\\t\\t2. 质量验收\\n\\n​\\t\\t\\t3. 资料验收\\n\\n10. 在进行项目总结时，应该注意哪些问题？\\n\\n​\\t\\t\\t1. 项目概况，质量结果分析；\\n\\n​\\t\\t\\t2. 项目进展情况；\\n\\n​\\t\\t\\t3. 好的经验；\\n\\n​\\t\\t\\t4. 不足之处；\\n\\n​\\t\\t\\t5. 改进方案和建议。\\n\\n# 5 计算器\\n\\n一、一个软件企业现在面对两个项目的选择\\n\\n一个软件企业现在面对两个项目的选择。他们经过分析得得出这样的结论:如果做项目A，盈利的概率是20%，可以盈利30万元，但是同时亏损的概既率是80%，亏损4万元;如果做项目B.盈利的概率是70%，盈利6万元，但同时有两种亏损的可能，其一是10%的概率亏损2万，其二是20%的概率亏损5万。请用决策树的方法计计算出两个项目的预期收益，并判断哪个项目是比较有利的选择。\\n\\n（1）：该企业两个项目的决策树如下：\\n\\n![image-20221101235338174](assets/软件项目管理考试/image-20221101235338174.png)\\n\\n---\\n\\n一、阅读以下说明，回答问题1至问题3。\\n\\n某信息系统集成企业承担了甲方的信息系统集成项目，在项目的采购过程中，某项采购合同是在甲方的授意下签订的，然而在项目进展过程中，项目经理发现该采购产品高于市场价格，而且有些性能指标也没有能够完全满足合同规定要求。当项目经理发现此类问题进行调查时，发现该供应商的资质和声誉都存在问题，并且就在不久前已经被其他公司并购，最麻烦的是合同的付款条件是提前支付相关款项，合同的大部分采购款已经支付。\\n\\n在项目的中期验收中，甲方发现了部分采购产品存在的问题，并要求项目组进行返工和更换相关产品。项目经理则以采购供应商是由甲方推荐为由，拒绝进行返工和更换。而甲方则认为，项目合同里面并没有规定由甲方承担采购责任，甲方只是为项目组推荐了部分供应商，而供应商已被收购，原先的公司已经不存在，原先的责任人已经离职为由，拒绝根据合同相关条款更换产品，项目经理对此束手无策。项目经理和甲方就该问题相持不下，项目处于停滞状态。\\n\\n1. 问题1结合案例，请指出项目组在采购合同管理中存在什么问题?\\n\\n   **合同签订有问题，不应轻易采用甲方的推荐。 2)合同支付条款不合理。 3)合同执行有问题，设备指标不满足要求时，未能及时有效的管控。4)合同变更问题，供应商被并购以后，合同没有及时变更相应条款。**\\n\\n2. 问题2在采购合同中，支付方式的规定一般包括哪些方面的内容?甲方的做法是否妥当，是分散否该为此承担主要责任?\\n\\n   **支付方式的内容:1)支付货款的条件;2)结算支付的时限、方式;3)拒付货款。发包方有权部分或全部拒付货款。4)甲方的做法不妥当。不应该承担主要责任。**\\n\\n3. 问题3供应商是否可以以公司变更、负责人离职为由，拒绝履行公司变更前签订的协议?为什么?对此而日经那该加何外开?\\n\\n   **不可以。因为供应商公司变更不影响其对已经售出的货物的质量保证义务，新公司需要继续履行原供应商签订的协议。项目经理可以启动索赔程序。先进行调解，调解不成，由经济合同仲裁委员会进行调解或仲裁。**\\n\\n---\\n\\n二、在项目的中期验收中，甲方发现了部分采购产品存在的问题，并要求项目组选行返工和更换相关产 品。项目经理则以采购供应商是由甲方推荐为由，拒绝送行返工和更换。而甲方则认为，项目合同里 面并没有规定由甲方系担采购责任，甲方只是为项目组推荐了部分供应商，而供应南己枝收购，原先 的公司己经不存在，原先的责任人已经高职为由，拒绝根据合同相关条款更换产品，项目经理对此束 手无策。项目经理和甲方就该问题相持不下，项目处手停滞状态。 \\n\\n问题 1 结合案例，请指出项目组在采购合同管理中存在什么问题？ \\n\\n**1）合同签订有问题，不应经易采用甲方的推荐。2）合同支付条款不合理。3）合同执行有问题，设备 指标不满足要求时，未能及时有放的管拉。4）合同支更问题，供应商被并购以后，合同没有及时变更 相应条款。** \\n\\n问题 2 在采购合同中，交付方式的规定一般包括哪些方面的内容？甲方的做法是否妥当，是否该为比 承担主要贡任？ \\n\\n**支付方式的内容：1）支付货款的条件：2）结算支付的时限、方式：3）拒付货款。发包方存权部分或 全部柜付货款。4）平方的做法不妥当，不应该承担主要责任。**\\n\\n问题 3 供应商是否可以以公司变更、众责人离职为由，拒绝履行公司变更前签订的协议？为什么？对 此项目经理该如何处理？ \\n\\n**不可以。因为供应商公司变更不影响其对己经售出的货物的质量保证义务，新公司需要继续履行原供 应商签订的协议。 项目经理可以启动索赔程序。先进行调解，阔解不成，由经济合同仲教委员会选行调解或仲裁。**\\n\\n---\\n\\n三、软件项目需求变更\\n\\n1. 提出变更\\n2. 评估变更\\n3. 决策变更\\n4. 实施变更\\n5. 验证变更\\n\\n---\\n\\n四、阅读以下说明，回答问题1至问题 3。\\n\\n某创业型公司乙在2015年1月，凭借着报价低的优势中标承接了一个信息系统工程项目。项目建设内容主要包括建设方甲公司的北京总公司ERP信息系统建设，以及甲公司成都分公司的机房改造项目。甲乙两公司协商签订了工程额为100万元的总价合同，工期为一年。乙公司指派有过ERP项目经验的张工承担项目经理，因公司还处于创业期间，所以公司管理层非常注重成本的控制，要求项目经理严格控制成本，每周汇报项目的实际花费。为了满足\\n\\n低成本的要求，考虑到北京、成都两地的材料、差旅费用等问题，在征得甲公司与管理层的同意后，张工将机房改造工程外包给成都当地的丙公司，并在合同中要求丙公司必须在2015年底之前完工。\\n\\n项目执行期间。张工指派了一名成本控制专员，负责每周统计该项目ERP 部分所发生的费用。同时向管理层提交费用统计报告。项目进展到6月份。项目 ERP 部分实际发生的总费用为30 万元。成都赶上了梅雨季节，丙公司反馈因机房处于某大厦的低层，太潮湿，机房改造工程被迫暂停。待梅雨季节过后继续施工。\\n\\n项目执行到2015年底，机房改造项目已确定无法在2016年1月如期完工，ERP部分虽然基本到了后期的测试阶段，但其总费用也已经达到了 60 万元。\\n\\n问题1根据案例，2016年1月机房改造工程无法如期完工，请指出乙公司是否可以向丙公司索赔?如可以，请说明可以申请什么索赔?如不可以，请说明理由。\\n\\n**可以索赔。可以申请延长工期索赔。 (机房改造属于室内施工，雨季不是进度延期的不可抗因素)**\\n\\n问题2结合以上案例，请帮助张工提出成本管理及成本控制方面的改进措施。\\n\\n**1.根据项目实际情况，制定成本管理计划，并得到公司高层批准。2、采用科学方法对项目进行成本估算和预算。 3、按计划掌握项目实际成本支出情况(包括北京、成都两地)。4将实际成本与成本计划进行比较，掌握项目成本绩效。 5、如果实际成本不符合计划，则进行偏差分析，制定相关纠偏措施。 6、做好相关文档的记录和存档。**\\n\\n问题 3结合以上案例，在项目后期，请帮助项目经理张工提出一些可以弥补工期耽误的方法。\\n\\n**1.要求丙方采取措施进行赶工。 2.对丙方工程进度严格控制。3.与甲方进行沟通，必要时，修改进度计划。**\\n\\n---\\n\\n五、已知某信息工程项目由A到G7个活动组成，项目根据项目目标特别施工期要求，经过分析、定义及评审，给出了该项目的活动历时。活动资源及活动逻辑关系如下表所示:\\n\\nA:需求分析 10 2\\n\\nB:软件设计 10 2 A\\n\\nC:测试案例编写 12 3 A\\n\\nD:编程实现 15 4 B\\n\\nE:软件测试 15 3 C、D\\n\\nF:编写用户手册 5 1 A\\n\\nG:调试软件系统 3 2 E\\n\\n \\n\\n问题 1:绘制该项目活动的前导网络图问题\\n\\n问题2:指出该项目的关键路径和工期问题\\n\\n问题3:指出其他路径的项目缓冲期\\n\\n问题4:为了配合甲方公司成立庆典，甲方要求该项目提前10天完工，并同意支付额外费用。承建单位经过论证，同意了甲方要求并按规范执行了审批流程。为了保质保量按期完工，\\n\\n![image-20221102005159821](assets/软件项目管理考试/image-20221102005159821.png)\\n\\n---\\n\\n\\n\",\"articleCover\":\"http://figurebed-1311634249.cos.ap-beijing.myqcloud.com/articles/9cdd0d0402007823150b1db80244cf0c.jpg\",\"articleTitle\":\"软件项目管理\",\"categoryName\":\"学习和技术总结\",\"id\":75,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"软件项目管理\"],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.101', '山西省太原市 移动', '2022-11-02 01:47:44', NULL);
INSERT INTO `tb_operation_log` VALUES (1280, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 1 选择题\\n\\n1. 下列工作中不属于项目的是\\n   - [ ] A.策划一场婚礼\\n   - [ ] B.开发一款软件\\n   - [x] C.为人民服务\\n   - [ ] D.主持一场会议\\n\\n2. 下列不属于项目特性的是\\n   - [ ] A.一次性  \\n   - [x] B.新颖性 \\n   - [ ] C.目标性  \\n   - [ ] D.约束性\\n\\n3. 项目管理的对象集中在对3P的管理，下列不属于3P的是\\n   - [ ] A.人员  \\n   - [ ] B.问题  \\n   - [ ] C.过程  \\n   - [x] D.保证\\n\\n4. 项目管理需要在互相间有冲突的要求中找到平衡，除了以下哪个\\n   - [x] A.甲方和乙方的利益          \\n   - [ ] B.范围、时间、成本、质量\\n   - [ ] C.有不同项目需求和期望的项目干系人 \\n   - [ ] D.明确和未明确表达的需求\\n\\n5. 项目管理中的三种组织结构，哪一种沟通最为复杂\\n   - [ ] A.职能型  \\n   - [ ] B.纯项目 \\n   - [x] C.矩阵型  \\n   - [ ] D.都一样\\n\\n6. 项目经理的职责不包括以下哪项内容\\n   - [ ] A.开发计划   \\n   - [ ] B.组织实施  \\n   - [ ] C.项目控制  \\n   - [x] D.系统支持\\n\\n7. 可以构建一部分系统的模型，通过用户试用提出优缺点，最好选择（）生存期模型 \\n   - [ ] A.增量式模型  \\n   - [x] B.原型    \\n   - [ ] C.螺旋型    \\n   - [ ] D.v模型\\n\\n8. 乙方在项目初始阶段的主要任务不包含以下哪一项\\n   - [ ]   A.项目分析   \\n   - [ ] B.招投标   \\n   - [x] C.合同管理   \\n   - [ ] D.合同签署\\n\\n10. 需求分析完成的标志是\\n    - [ ] A.开发出初步模型   \\n    - [x] B.提交一份完整的软件需求规格说明书\\n    - [ ] C.提交一份工作称述  \\n    - [ ] D.提交项目章程\\n\\n11. WBS中的每一个具体细目通常都指定唯一的\\n    - [x] A.编码  \\n    - [ ] B.责任人  \\n    - [ ] C.功能模块  \\n    - [ ] D.提交日期\\n\\n12. 项目计划方法中，（）是能直观的表达软件开发众多工序之间的逻辑关系与时间关系。 \\n    - [ ] A.滚动计划法  \\n    - [ ] B.工作结构分解 \\n    - [x] C.网络计划技术 \\n    - [ ] D.构造性成本法\\n\\n13. 代码行估算方法属于以下基本估算方法中的哪一种。（）\\n    - [x] A.分解法    \\n    - [ ] B.算数模型    \\n    - [ ] C.专家判断   \\n    - [ ] D.比例法\\n\\n14. 在项目估算的基本内容中，（）是软件项目量化的结果，很大程度上代表了项目范围的大小。\\n\\n    - [ ] A.风险估算  \\n\\n    - [ ] B.工作量估算 \\n\\n    - [x] C.规模估算  \\n\\n    - [ ] D.其他估算\\n\\n15. 下列不属于按照详细情况划分的3个等级构造性成本模型的是（）\\n    - [ ] A.基本 COCOMO    \\n    - [ ] B.中间 COCOMO \\n    - [x] C.发展 COCOMO    \\n    - [ ] D.详细 COCOMO\\n\\n16. 项目管理人员根据个人能力、是否有空闲时间进行项目活动人员分配时有A、P、R、S 四种类别，其中A表示（）\\n    - [x] A.负责    \\n    - [ ] B.参与   \\n    - [ ] C.检查    \\n    - [ ] D.批准\\n\\n17. 压缩软件项目的工期时，你应该关注（）\\n    - [x] A.关键路径  \\n    - [ ] B.非关键路径  \\n    - [ ] C.准关键活动  \\n    - [ ] D.活动缓冲期\\n\\n18. “软件编码完成之后，我才可以对它进行软件测试”这句话体现了项目活动之间的哪种关系\\n    - [ ] A.开始-开始   \\n    - [x] B.结束-开始   \\n    - [ ] C.结束-结束   \\n    - [ ] D.开始-结束\\n\\n19. 在成本管理过程中，项目经理确定的每个时间段，各个工作单元的成本是\\n    - [ ] A.估算    \\n    - [ ] B.预算     \\n    - [x] C.直接成本   \\n    - [ ] D.间接成本\\n\\n20. 估算文件不属于以下哪一项\\n    - [x] A.功能模块  \\n    - [ ] B.质量标准  \\n    - [ ] C.资源及数量   \\n    - [ ] D.估算成本\\n\\n21. 下列不属于软件评审方法的是\\n    - [ ] A.同行评审   \\n    - [ ] B.走查     \\n    - [ ] C.会议审查    \\n    - [x] D.测试\\n\\n22. 软件项目质量的组织保证是\\n    - [ ]  A.顾客     \\n    - [ ] B.用户     \\n    - [ ] C.提供者     \\n    - [x] D.SEPG组\\n\\n23. 项目质量管理的最终责任由谁来承担\\n    - [ ] A.项目开发经理        \\n    - [ ] B.质量经理\\n    - [ ] C.采购经理          \\n    - [x] D.项目经理\\n\\n24. “质量成本”是一个项目管理概念，它说明了下列哪项成本\\n    - [x] A.额外需求的成本      \\n    - [ ] B.需求变更的成本\\n    - [ ] C.确保符合需求的成本    \\n    - [ ] D.固定成本\\n\\n25. 软件项目的一个重要特点是需求变更频繁，在项目管理中缺乏有效的需求变更控制流程就极有可能引起项目风险。若按照风险来源的阶段对风险进行分类，这种项目风险属于\\n    - [x] A.需求风险  \\n    - [ ] B.设计风险   \\n    - [ ] C.编程风险    \\n    - [ ] D.维护风险\\n\\n26. 在风险分析过程中，确定已经识别的一个风险事件是无法避免的，也是不能减轻的，也不能投保，这是一个关键的风险事件，一旦发生可能造成项目的失败，项目经理最佳的选择是\\n    - [ ] A.降低风险的级别，项目团队将找到一个克服故障的方法\\n    - [x] B.特别关注，加强管理该风险事件和所有的相关事件\\n    - [ ] C.让风险评估小组继续分析该风险事件，直到降低预期影响\\n    - [ ] D.忽略风险评估，因为不管赋予什么值，都只是一个估算\\n\\n27. 风险的三个属性是\\n    - [ ] A.风险发生的时间、地点、责任人 \\n    - [ ] B.风险事件、时间、影响\\n    - [x] C.风险事件、概率、影响 \\n    - [ ] D.风险数量、风险影响程度、概率\\n\\n28. 下列哪项不是风险管理的过程\\n    - [ ] A.风险评估  \\n    - [ ] B.风险识别   \\n    - [ ] C.风险规划   \\n    - [x] D.风险收集\\n\\n29. 由于政府的一项新规定，某项目的项目经理必须变更该项目的范围。项目目标已经做了若干变更，项目经理已经对项目的技术和管理文件做了必要的修改，他下一步应该\\n    - [x] A.及时通知项目干系人     \\n    - [ ] B.修改公司的知识管理体系\\n    - [ ] C.获取客户的正式认可    \\n    - [ ] D.获得政府认可\\n\\n30. 小王负责一个管理信息系统项目，最近在与客户共同进行的质量审查中发现一个程序模块不符合客户的需求，进行追溯时，也未发现相应的变更请求。最终小王被迫对这一模块进行再设计并重新编程，造成此项返工的原因可解是\\n    - [ ] A.未进行需求变更      \\n    - [x] B.未进行范围确认 \\n    - [ ] C.未进行变更管理      \\n    - [ ] D.质量管理过严\\n\\n31. 客户已经正式接收了项目，该项目的项目经理下一步工作将是\\n    - [x] A.适当的将接收文件分发给其他项目干系人\\n    - [ ] B.将项目总结向项目档案库归档\\n    - [ ] C.记录你与小组成员获得的经验 \\n    - [ ] D.进行项目审计\\n\\n32. 在某个信息系统项目中，存在新老系统切换问题，在设置项目计划网络图时，新系统上线和老系统下线之间应设置成（）的关系。\\n    - [ ] A.结束—开始(FS型)      \\n    - [ ] B.结束—结束(FF型)\\n    - [x] C.开始—结束(SF型)     \\n    - [ ] D.开始一开始(ss型)\\n\\n33. 质量控制是\\n    - [ ] A.对每个工作包增加工作时间 \\n    - [x] B.项目生存期的各个阶段都要实施的\\n    - [ ] C.只需要做一次         \\n    - [ ] D.只有大的项目才需要\\n\\n34. 采用网络模型反向遍历的目的在于决定（）\\n    - [ ] A.关键路径          \\n    - [ ] B.最早完工日期\\n    - [x] C.最迟开始日期        \\n    - [ ] D.赶工日期\\n\\n35. 激励中的期望理论认为\\n    - [ ] A.相信付出的努力很可能会产生成功的结果\\n    - [ ] B.管理者不应对工人寄望过高\\n    - [x] C.激励应与期望中具有价值的产出相关联\\n    - [ ] D.管理者不应期望薪水高的雇员工作更努力\\n\\n36. 制定项目计划时，首先应该关注的是\\n    - [x] A.项目范围说明书        \\n    - [ ] B.工作分解结构 \\n    - [ ] C.风险管理计划        \\n    - [ ] D.质量计划\\n\\n37. 在进度可视化监控方法中，哪一种方法能简单、清除地展示项目整体进度\\n    - [ ] A.延迟图  \\n    - [ ] B.时间线   \\n    - [x] C.甘特图   \\n    - [ ] D.计划与实际对比图\\n\\n38. 在项目进行过程中，一个开发人员接到某个用户的电话，用户要求更改系统中存在的一个问题，这个开发人员应该\\n    - [ ] A.马上改正问题   \\n    - [x] B.记录问题并提交项目经理\\n    - [ ] C.不予理睬     \\n    - [ ] D.通过测试部经理，要求确认问题是否存在\\n\\n39. 下面哪一种质量改进方法最不可能产生积极结果\\n    - [ ] A.持续改进   \\n    - [ ] B.统计质量过程   \\n    - [ ] C.客户跟踪过程   \\n    - [x] D.增加检验\\n\\n40. 项目的项目范围已经发生变更，因此成本基线也将发生变更，项目经理需要尽快\\n    - [ ] A.进行范围变更策略     \\n    - [ ] B.更新预算\\n    - [ ] C.记录获得经验      \\n    - [x] D.执行得到批准的范围变更\\n\\n# 2 填空题\\n\\n1.  项目管理的基本内容是计划、组织和（**监控**）\\n\\n2. 根据项目管理方法论可以将项目管理分为阶段化管理、（**量化管理**）和优化管理，\\n\\n3. 影响项目可行性的因素可分为:经济可行性、技术可行性、（**风险和不确定性**）。\\n\\n4. 由于项目的组织结构中职能型和纯项目型的两个极端代表，为了综合它们各自的优势,（**矩阵型**）应用而生，他是职能型和纯项目型的结合体。\\n\\n5. 滚动计划法是一种迭代方法，它具有分而治之、（**逐步求精**）、动态规划、和谐过渡的特点。\\n\\n6. （**WBS 工作分解结构**）是一种将复杂问题分解为简单问题，然后再根据分解的结果进行计划的方法。\\n\\n7. WBs 最低层次的项目可交付成果称为（**工作包**）。\\n\\n8. （**德尔菲法**）是一种专家评估技术，适用于在没有或者没有足够历史数据的情况下，来评定软件采用不同的技术或新技术带来的差异，但专家的水平及对项目的理解程度是工作中的关键点。\\n\\n9. 里程碑事件的工期一般设置为（**零**）\\n\\n10. 在ADM 网络图中，有时为了表示逻辑关系，需要设置一个虚活动，虚活动是不需要时间和资源的，一般用（**虚箭线**）表示:\\n\\n11. （**里程碑**）定义了当前阶段完成的标准和下阶段启动的前提或条件。\\n\\n12. （**质量计划**）是进行项目质量管理、实现项目质量方针和目标的具体体现。\\n\\n13. （度量）提供了对项目进度评估、质量状况的洞察力和用于决策的有关数据。\\n\\n14. （**风险评审技术**）是为了适应某些有高度不确定性和风险性的决策问题而开发一种网络仿真系统。\\n\\n15. 外包是（**风险转移**）类型的风险处理策略。\\n\\n16. 涉及多个领域工作的复杂项目最好采用（**矩阵型组织**）来管理。\\n\\n17. 软件开发中大多数的变更都是来源于（**需求变更**）。\\n\\n18. （**收尾**）是项目生命周期的最后一个阶段，也是形成产品闭环的关键步骤。\\n\\n19. 马斯洛需求层次论把需求分为生理需求、安全需求、社会需求、尊重需求、（**自我实现需求**）。\\n\\n20. 良好的工作氛围概括起来就是：开放、（**真诚**）、平等、信任。\\n\\n# 3 判断题\\n\\n1. 受控环境中的项目是组织、管理和控制项目的方法，强调通过管理方法使项目环境得到控制。      （√）\\n2. 软件不同于一般的传统的产品，它是对物理世界的一种抽象，是逻辑性、知识性的产物。        （√）\\n3. 项目管理的核心是成本。  （×）\\n4. 根据项目管理方法论可以将项目管理分为阶段化管理、量化管理和优化管理，其中量化管理是项目管理的基本方法。 （×）\\n5. 项目建议书必须尽可能的详细。（×） \\n6. 项目可行性分析是项目启动阶段的关键活动，旨在判断一个项目是否值得做或者是挑选许多待选项目中的最佳项目。 （√）\\n7. 投资回收期分析法是经济可行性分析中最可靠的方法。（×）\\n8. 极限编程的基本思想是“沟通、简单、反馈、勇气”。（√）\\n9. WBS最底层的项目只能由一人负责。（√）\\n10. 在软件项目管理中，计划编制是最复杂的阶段，却经常不受重视。（√）\\n11. 软件项目的项目计划可以由一个人独立完成，不需要与项目干系人沟通。（×）\\n12. PMBOK 将项目计划过程分为核心过程和辅助过程两个部分。（√）\\n13. 软件估算的方法有许多，可以分为直接方法和间接方法，如功能点估算方法就是软件规模估算中的直接方法。（×）\\n14. 软件项目的估算结果都是比较准确地。（×）\\n15. 在进行软件项目估算时，可以参照其他企业的估算模型。（√）\\n16. 成本估算一般情况下都可能不是非常精确，尤其是软件项目更是如此。（√）\\n17. 甘特图可以显示任务的基本信息，使用甘特图能方便地查看任务的工期，开始和结束时间以及资源的信息。（√）\\n18. 为了得到一个相对准确的估算结果，项目管理者应该系统的学习相关的成本（√）\\n19. IT项目尤其是软件项目的成本管理一直没有一个好的口碑，但成本超支很少见。()错\\n20. 成本估算不准确有很多原因，有主观原因也有客观原因。（√）\\n21. PSP 指软件工程过程组，其要质量目标是编译和单元测试之前发现和修复缺陷。()错\\n22. 产品的缺陷密度或者测试阶段的缺陷率是概括性指标。（√）\\n23. 软件度量主要包括3部分:项目度量、产品度量和过程度量（√）\\n24. 鱼骨图分析方法要完成从小刺到主刺的思维和分析过程。（×）\\n25. TOP风险清单中的条目越多越好。（×）\\n26. 风险识别、风险评估、风险规划、风险控制是风险管理的四个过程。（√）\\n27. 当风险发生的概率极高、风险后果影响很严重时，才可以考虑采用回避风险策略。（×）\\n28. 风险是损失发生的不确定性，是对潜在的、未来可能发生损害的一种度量。（√）\\n29. 在当今高科技环境下，x理论和期望理论可以用来激励一个团队员工的工作士气。（×）\\n30. 在项目早期和信息不足的时候，可以采用自下而上的估算方法进行成本估算。（×）\\n31. 需求分析过程是确定项目如何实现的过程，并确定项目的技术方案（×）\\n32. 软件项目的估算结果是比较准确的。（×）\\n33. 基线产品是不能修改的。（×）\\n34. 在 IT 项目中，许多专家都认为：对于成功，威胁最大的就是沟通的失败。（√）\\n35. 采购是为了换行项目而从项目团队外部采购或者获取产品、服务或者结果的过程。（√）\\n36. 进度和成本是关系最为老切的两个目的，几乎成了对立关系，进度的缩短一定依靠增加成本实现，而成本的降低也一定牺牲工期进度为代价的。（×）\\n37. 项目早期和信息不足的时候，可以采用自下而上的估算方法进行成本估算（×）\\n38. 统计需求变更请求的数量是配置审核过程。（√）\\n39. 质量保证属于检查职能，而质量控制属于管理职能。（×）\\n40. 采用德尔菲方法来标识风险可以减少人为的偏差，以便作出正确决定（√）\\n41. 取消采用具有高风险的新技术，而采用原来热悉的技术\\\"是一种转移风险的规划策略（√）\\n\\n# 4 简答题\\n\\n1. **项目生命周期分为5个阶段，请简要概述（P6）**\\n\\n   1. 启动。项目获得授权正式被**立项，并成立项目组**，宣告项目开始。启动是一种认可过程，用来正式认可一个新项目或新阶段的存在。\\n   2. 计划。**明确项目范围**，定义和评估项目目标，选择实现项目目标的最佳策略，**制订项目计划。**\\n   3. 执行。调动资源，**完成项目管理计划中确定的工作**。\\n   4. 控制。**监控和评估项目偏差**，必要时采取纠正行动，以**保证项目计划的执行**，**实现项目目标**。\\n   5. 结束。**完成项目验收**，使其按程序结束。\\n\\n2. **简述 WBS 制定的原则。**\\n\\n   1. 某项具体的任务应该在一个工作包且只能在一个工作包中出现\\n   2. WBS中某项任务的内容是其下所有WBS项的总和\\n   3. 一个工作包只能由一个人负责\\n   4. 任务的分解，尽量与实际执行方式保持一致。\\n   5. 分解合理，具有良好的稳定性和适应性\\n   6. 鼓励项目团队成员积极参与创建WBS\\n   7. 所有成果需要文档化\\n\\n3.  **什么是质量管理，软件质量管理的保证组织有哪些?** \\n\\n   质量管理是指：确定质量方针、目标和职责并在质量体系中通过质量计划、质量控制、质量保证和质量改进使其实施的全部管理职能的所有活动。\\n\\n   1、采用技术手段和工具；2、组织正式技术平时；3、加强软件测试；4、推行软件工程规范（标准）；5、对软件的变更进行控制；6对软件质量进行度量。\\n\\n4. **简述应对风险的基本措施?**\\n\\n   1. 规避。通过变更项目计划消除风险或风险的触发条件，使目标免受影响。\\n   2. 转移。不能消除风险，而是将项目风险的结果连同应对的权利转移给第三方。\\n   3. 弱化。将风险时间的概率或结果降低到一个可以接受的程度，其中降低发生的概率更为有效。\\n   4. 接受。不改变项目计划，而考虑发生后如何应对\\n\\n5. **风险监控的措施有哪些?**\\n\\n   1. 风险识别\\n   2. 风险估计 \\n   3. 风险管理策略 \\n   4. 风险解决 \\n   5. 风险监控\\n\\n6. **如何确保知识经验共享?**\\n\\n   1. 企业角度\\n\\n      要先提倡和强调重要性。\\n\\n      其次要确立正确而鼓舞人心的知识管理愿景和战略目标。\\n\\n      再次要建立指导监督团队来提供足够的推动力。\\n\\n      激励知识共享的贡献者。\\n\\n   2. 个人角度\\n\\n      做到无私奉献，无偿分享。\\n\\n      积极参与知识的分享和讨论，在讨论中不断学习、相互提高，真正实现从知识到能力的跨越。\\n\\n7. 什么是绩效管理？如何做好绩效管理？\\n\\n   所谓绩效管理就是企业为了持续发展及保持良好的发展趋势，为了提高业绩与效率，制定一定的激励方式，让员工可以按时完成任务，整体提高员工工作积极性和提高企业产能。\\n\\n    1、绩效管理准备工作\\n\\n    2、明确绩效分工流程\\n\\n   3、做好绩效管理方案\\n\\n   4、绩效管理的反馈\\n\\n   5、绩效管理的改进\\n\\n   6、绩效管理的维护及存档\\n\\n8. 如何在项目监控阶段，区分缺陷的优先级和重要性？\\n\\n​\\t\\t\\t1. 缺陷跟踪\\n\\n​\\t\\t\\t2. 技术检查\\n\\n​\\t\\t\\t3. 源代码追踪\\n\\n​\\t\\t\\t4. 测试\\n\\n9. 简述项目验收的内容\\n\\n​\\t\\t\\t1. 软件系统验收\\n\\n​\\t\\t\\t2. 质量验收\\n\\n​\\t\\t\\t3. 资料验收\\n\\n10. 在进行项目总结时，应该注意哪些问题？\\n\\n​\\t\\t\\t1. 项目概况，质量结果分析；\\n\\n​\\t\\t\\t2. 项目进展情况；\\n\\n​\\t\\t\\t3. 好的经验；\\n\\n​\\t\\t\\t4. 不足之处；\\n\\n​\\t\\t\\t5. 改进方案和建议。\\n\\n# 5 计算器\\n\\n一、一个软件企业现在面对两个项目的选择\\n\\n一个软件企业现在面对两个项目的选择。他们经过分析得得出这样的结论:如果做项目A，盈利的概率是20%，可以盈利30万元，但是同时亏损的概既率是80%，亏损4万元;如果做项目B.盈利的概率是70%，盈利6万元，但同时有两种亏损的可能，其一是10%的概率亏损2万，其二是20%的概率亏损5万。请用决策树的方法计计算出两个项目的预期收益，并判断哪个项目是比较有利的选择。\\n\\n（1）：该企业两个项目的决策树如下：\\n\\n![image-20221101235338174](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%80%83%E8%AF%95/image-20221101235338174-d92.png)\\n\\n---\\n\\n一、阅读以下说明，回答问题1至问题3。\\n\\n某信息系统集成企业承担了甲方的信息系统集成项目，在项目的采购过程中，某项采购合同是在甲方的授意下签订的，然而在项目进展过程中，项目经理发现该采购产品高于市场价格，而且有些性能指标也没有能够完全满足合同规定要求。当项目经理发现此类问题进行调查时，发现该供应商的资质和声誉都存在问题，并且就在不久前已经被其他公司并购，最麻烦的是合同的付款条件是提前支付相关款项，合同的大部分采购款已经支付。\\n\\n在项目的中期验收中，甲方发现了部分采购产品存在的问题，并要求项目组进行返工和更换相关产品。项目经理则以采购供应商是由甲方推荐为由，拒绝进行返工和更换。而甲方则认为，项目合同里面并没有规定由甲方承担采购责任，甲方只是为项目组推荐了部分供应商，而供应商已被收购，原先的公司已经不存在，原先的责任人已经离职为由，拒绝根据合同相关条款更换产品，项目经理对此束手无策。项目经理和甲方就该问题相持不下，项目处于停滞状态。\\n\\n1. 问题1结合案例，请指出项目组在采购合同管理中存在什么问题?\\n\\n   1. **合同签订有问题，不应轻易采用甲方的推荐。**\\n   2. **合同支付条款不合理。**\\n   3. **合同执行有问题，设备指标不满足要求时，未能及时有效的管控。**\\n   4. **合同变更问题，供应商被并购以后，合同没有及时变更相应条款。**\\n\\n2. 问题2在采购合同中，支付方式的规定一般包括哪些方面的内容?甲方的做法是否妥当，是分散否该为此承担主要责任?\\n\\n   1. **支付方式的内容**\\n   2. **支付货款的条件**\\n   3. **结算支付的时限、方式**\\n   4. **拒付货款。发包方有权部分或全部拒付货款**\\n   5. **甲方的做法不妥当。不应该承担主要责任。**\\n\\n3. 问题3供应商是否可以以公司变更、负责人离职为由，拒绝履行公司变更前签订的协议?为什么?对此而日经那该加何外开?\\n\\n   **不可以。因为供应商公司变更不影响其对已经售出的货物的质量保证义务，新公司需要继续履行原供应商签订的协议。项目经理可以启动索赔程序。先进行调解，调解不成，由经济合同仲裁委员会进行调解或仲裁。**\\n\\n---\\n\\n二、在项目的中期验收中，甲方发现了部分采购产品存在的问题，并要求项目组选行返工和更换相关产 品。项目经理则以采购供应商是由甲方推荐为由，拒绝送行返工和更换。而甲方则认为，项目合同里 面并没有规定由甲方系担采购责任，甲方只是为项目组推荐了部分供应商，而供应南己枝收购，原先 的公司己经不存在，原先的责任人已经高职为由，拒绝根据合同相关条款更换产品，项目经理对此束 手无策。项目经理和甲方就该问题相持不下，项目处手停滞状态。 \\n\\n问题 1 结合案例，请指出项目组在采购合同管理中存在什么问题？ \\n\\n**1）合同签订有问题，不应经易采用甲方的推荐。2）合同支付条款不合理。3）合同执行有问题，设备 指标不满足要求时，未能及时有放的管拉。4）合同支更问题，供应商被并购以后，合同没有及时变更 相应条款。** \\n\\n问题 2 在采购合同中，交付方式的规定一般包括哪些方面的内容？甲方的做法是否妥当，是否该为比 承担主要贡任？ \\n\\n**支付方式的内容：1）支付货款的条件：2）结算支付的时限、方式：3）拒付货款。发包方存权部分或 全部柜付货款。4）平方的做法不妥当，不应该承担主要责任。**\\n\\n问题 3 供应商是否可以以公司变更、众责人离职为由，拒绝履行公司变更前签订的协议？为什么？对 此项目经理该如何处理？ \\n\\n**不可以。因为供应商公司变更不影响其对己经售出的货物的质量保证义务，新公司需要继续履行原供 应商签订的协议。 项目经理可以启动索赔程序。先进行调解，阔解不成，由经济合同仲教委员会选行调解或仲裁。**\\n\\n---\\n\\n三、软件项目需求变更\\n\\n1. 提出变更\\n2. 评估变更\\n3. 决策变更\\n4. 实施变更\\n5. 验证变更\\n\\n---\\n\\n四、阅读以下说明，回答问题1至问题 3。\\n\\n某创业型公司乙在2015年1月，凭借着报价低的优势中标承接了一个信息系统工程项目。项目建设内容主要包括建设方甲公司的北京总公司ERP信息系统建设，以及甲公司成都分公司的机房改造项目。甲乙两公司协商签订了工程额为100万元的总价合同，工期为一年。乙公司指派有过ERP项目经验的张工承担项目经理，因公司还处于创业期间，所以公司管理层非常注重成本的控制，要求项目经理严格控制成本，每周汇报项目的实际花费。为了满足\\n\\n低成本的要求，考虑到北京、成都两地的材料、差旅费用等问题，在征得甲公司与管理层的同意后，张工将机房改造工程外包给成都当地的丙公司，并在合同中要求丙公司必须在2015年底之前完工。\\n\\n项目执行期间。张工指派了一名成本控制专员，负责每周统计该项目ERP 部分所发生的费用。同时向管理层提交费用统计报告。项目进展到6月份。项目 ERP 部分实际发生的总费用为30 万元。成都赶上了梅雨季节，丙公司反馈因机房处于某大厦的低层，太潮湿，机房改造工程被迫暂停。待梅雨季节过后继续施工。\\n\\n项目执行到2015年底，机房改造项目已确定无法在2016年1月如期完工，ERP部分虽然基本到了后期的测试阶段，但其总费用也已经达到了 60 万元。\\n\\n问题1根据案例，2016年1月机房改造工程无法如期完工，请指出乙公司是否可以向丙公司索赔?如可以，请说明可以申请什么索赔?如不可以，请说明理由。\\n\\n**可以索赔。可以申请延长工期索赔。 (机房改造属于室内施工，雨季不是进度延期的不可抗因素)**\\n\\n问题2结合以上案例，请帮助张工提出成本管理及成本控制方面的改进措施。\\n\\n**1.根据项目实际情况，制定成本管理计划，并得到公司高层批准。2、采用科学方法对项目进行成本估算和预算。 3、按计划掌握项目实际成本支出情况(包括北京、成都两地)。4将实际成本与成本计划进行比较，掌握项目成本绩效。 5、如果实际成本不符合计划，则进行偏差分析，制定相关纠偏措施。 6、做好相关文档的记录和存档。**\\n\\n问题 3结合以上案例，在项目后期，请帮助项目经理张工提出一些可以弥补工期耽误的方法。\\n\\n**1.要求丙方采取措施进行赶工。 2.对丙方工程进度严格控制。3.与甲方进行沟通，必要时，修改进度计划。**\\n\\n---\\n\\n五、已知某信息工程项目由A到G7个活动组成，项目根据项目目标特别施工期要求，经过分析、定义及评审，给出了该项目的活动历时。活动资源及活动逻辑关系如下表所示:\\n\\nA:需求分析 10 2\\n\\nB:软件设计 10 2 A\\n\\nC:测试案例编写 12 3 A\\n\\nD:编程实现 15 4 B\\n\\nE:软件测试 15 3 C、D\\n\\nF:编写用户手册 5 1 A\\n\\nG:调试软件系统 3 2 E\\n\\n问题 1:绘制该项目活动的前导网络图问题\\n\\n问题2:指出该项目的关键路径和工期问题\\n\\n问题3:指出其他路径的项目缓冲期\\n\\n问题4:为了配合甲方公司成立庆典，甲方要求该项目提前10天完工，并同意支付额外费用。承建单位经过论证，同意了甲方要求并按规范执行了审批流程。为了保质保量按期完工，\\n\\n![image-20221102005159821](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%80%83%E8%AF%95/image-20221102005159821-33a.png)\\n\\n---\\n\\n六、\\n\\n项目经理小王目前正在负责—个小型的软件开发项目。—开始他觉得项目比较小，变更应该不多，流程也不需要太复杂，因此就没有制定项目变更管理计划，而是强调团队成员间的及时沟通来保证项目按照计划进行：根据项目经理小王的理解．所谓变更管理的主要目标就是保证项目能够按照计划进行，如果能够保证不发生超越项目进度计划、成本计划等控制范围外的偏差，就可以不用指定项目变更管理计划．就可以不用指定项目变更管理计划，以减少项目的工作量。而项目执行过程中对计划的微调根本不需要记录和管理，也不需要走项目变更管理流程。而且他认为如果所有项目变更都必简要向相关领导请示汇报，过程太复杂和麻烦，还不如由执行人员提出变更的方案，彼此讨论—直后来的更方便和快捷。\\n\\n但是在项目进入集成测试阶段的时候，突然多了很多莫名其妙的问题出现。如在调试过程中。由于相关设计和记录的简化和不规范，造成了调试的困难，很难定位各个问题模块的错误；由于项目执行过程中。人员的调配替换，造成了文档记录的不—敢，导致后期人员阅读和理解方面的障碍。并且由于缺乏对开发过程的配置管理和控制，导致版本混乱，很难形成有效支持各模块集成的文档。另外，面目中很多细小的改动由于没有准确的记录，或者是根本没有记录．导致集成测试发现问题时，根本没有办法更改。小王对此也没有办法，不知道因为什么原因导致目前的项目状态，项目面临返工的危险。\\n\\n【问题1】结合案例。请说项目经理小王对项目变更管理的认识哪些星正确的？哪些是不正确的?\\n\\n**1、小王对项目变更管理的认识正确的是：**\\n\\n**（1）变更管理的目的是保证项目按计划进行；**\\n\\n**（2）项目变更需要获得相关干系人认可，讨论一致。**\\n\\n**（每项1分，共2分）**\\n\\n**2、小王对项目变更管理认识不正确的是：**\\n\\n**（1）不用制定项目变更管理计划；**\\n\\n**（2）对计划的微调根本不需要记录和管理；**\\n\\n**（3）不需要走变更管理流程。**\\n\\n【问题2】根据你的理解，请说明项目变更管理在软件项目管理中的主要活动内容\\n\\n**变更管理在软件项目管理中的主要活动内容**\\n\\n**(1)识别可能发生的变更。**\\n\\n**(2)管理每个已识别的变更。**\\n\\n**(3)维持所有基线的完整性。**\\n\\n**(4)根据已批准的变更，更新范围、成本、预算、进度和质量要求，协调整体项目内的变更。**\\n\\n**(5)基于质量报告，控制项目质量使其符合标准。**\\n\\n**(6)维护一个及时、精确的关于项目产品及其相关文档的信息库，直至项目结束。**\\n\\n【问题3】针对项目的当前状态，小王应该采取说明补救措施？\\n\\n**1、补一个变更管理计划；**\\n\\n**2、建立变更管理的流程；**\\n\\n**3、建立变更管理委员会；**\\n\\n**4、加强配置管理；**\\n\\n**5、加强版本管控；**\\n\\n**6、加强变更管理，有变更走流程。**\\n\",\"articleCover\":\"http://figurebed-1311634249.cos.ap-beijing.myqcloud.com/articles/9cdd0d0402007823150b1db80244cf0c.jpg\",\"articleTitle\":\"软件项目管理\",\"categoryName\":\"学习和技术总结\",\"id\":75,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.105', '山西省太原市 移动', '2022-11-02 09:31:02', NULL);
INSERT INTO `tb_operation_log` VALUES (1281, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 1 选择题\\n\\n1. 下列工作中不属于项目的是\\n   - [ ] A.策划一场婚礼\\n   - [ ] B.开发一款软件\\n   - [x] C.为人民服务\\n   - [ ] D.主持一场会议\\n\\n2. 下列不属于项目特性的是\\n   - [ ] A.一次性  \\n   - [x] B.新颖性 \\n   - [ ] C.目标性  \\n   - [ ] D.约束性\\n\\n3. 项目管理的对象集中在对3P的管理，下列不属于3P的是\\n   - [ ] A.人员  \\n   - [ ] B.问题  \\n   - [ ] C.过程  \\n   - [x] D.保证\\n\\n4. 项目管理需要在互相间有冲突的要求中找到平衡，除了以下哪个\\n   - [x] A.甲方和乙方的利益          \\n   - [ ] B.范围、时间、成本、质量\\n   - [ ] C.有不同项目需求和期望的项目干系人 \\n   - [ ] D.明确和未明确表达的需求\\n\\n5. 项目管理中的三种组织结构，哪一种沟通最为复杂\\n   - [ ] A.职能型  \\n   - [ ] B.纯项目 \\n   - [x] C.矩阵型  \\n   - [ ] D.都一样\\n\\n6. 项目经理的职责不包括以下哪项内容\\n   - [ ] A.开发计划   \\n   - [ ] B.组织实施  \\n   - [ ] C.项目控制  \\n   - [x] D.系统支持\\n\\n7. 可以构建一部分系统的模型，通过用户试用提出优缺点，最好选择（）生存期模型 \\n   - [ ] A.增量式模型  \\n   - [x] B.原型    \\n   - [ ] C.螺旋型    \\n   - [ ] D.v模型\\n\\n8. 乙方在项目初始阶段的主要任务不包含以下哪一项\\n   - [ ]   A.项目分析   \\n   - [ ] B.招投标   \\n   - [x] C.合同管理   \\n   - [ ] D.合同签署\\n\\n10. 需求分析完成的标志是\\n    - [ ] A.开发出初步模型   \\n    - [x] B.提交一份完整的软件需求规格说明书\\n    - [ ] C.提交一份工作称述  \\n    - [ ] D.提交项目章程\\n\\n11. WBS中的每一个具体细目通常都指定唯一的\\n    - [x] A.编码  \\n    - [ ] B.责任人  \\n    - [ ] C.功能模块  \\n    - [ ] D.提交日期\\n\\n12. 项目计划方法中，（）是能直观的表达软件开发众多工序之间的逻辑关系与时间关系。 \\n    - [ ] A.滚动计划法  \\n    - [ ] B.工作结构分解 \\n    - [x] C.网络计划技术 \\n    - [ ] D.构造性成本法\\n\\n13. 代码行估算方法属于以下基本估算方法中的哪一种。（）\\n    - [x] A.分解法    \\n    - [ ] B.算数模型    \\n    - [ ] C.专家判断   \\n    - [ ] D.比例法\\n\\n14. 在项目估算的基本内容中，（）是软件项目量化的结果，很大程度上代表了项目范围的大小。\\n\\n    - [ ] A.风险估算  \\n\\n    - [ ] B.工作量估算 \\n\\n    - [x] C.规模估算  \\n\\n    - [ ] D.其他估算\\n\\n15. 下列不属于按照详细情况划分的3个等级构造性成本模型的是（）\\n    - [ ] A.基本 COCOMO    \\n    - [ ] B.中间 COCOMO \\n    - [x] C.发展 COCOMO    \\n    - [ ] D.详细 COCOMO\\n\\n16. 项目管理人员根据个人能力、是否有空闲时间进行项目活动人员分配时有A、P、R、S 四种类别，其中A表示（）\\n    - [x] A.负责    \\n    - [ ] B.参与   \\n    - [ ] C.检查    \\n    - [ ] D.批准\\n\\n17. 压缩软件项目的工期时，你应该关注（）\\n    - [x] A.关键路径  \\n    - [ ] B.非关键路径  \\n    - [ ] C.准关键活动  \\n    - [ ] D.活动缓冲期\\n\\n18. “软件编码完成之后，我才可以对它进行软件测试”这句话体现了项目活动之间的哪种关系\\n    - [ ] A.开始-开始   \\n    - [x] B.结束-开始   \\n    - [ ] C.结束-结束   \\n    - [ ] D.开始-结束\\n\\n19. 在成本管理过程中，项目经理确定的每个时间段，各个工作单元的成本是\\n    - [ ] A.估算    \\n    - [ ] B.预算     \\n    - [x] C.直接成本   \\n    - [ ] D.间接成本\\n\\n20. 估算文件不属于以下哪一项\\n    - [x] A.功能模块  \\n    - [ ] B.质量标准  \\n    - [ ] C.资源及数量   \\n    - [ ] D.估算成本\\n\\n21. 下列不属于软件评审方法的是\\n    - [ ] A.同行评审   \\n    - [ ] B.走查     \\n    - [ ] C.会议审查    \\n    - [x] D.测试\\n\\n22. 软件项目质量的组织保证是\\n    - [ ]  A.顾客     \\n    - [ ] B.用户     \\n    - [ ] C.提供者     \\n    - [x] D.SEPG组\\n\\n23. 项目质量管理的最终责任由谁来承担\\n    - [ ] A.项目开发经理        \\n    - [ ] B.质量经理\\n    - [ ] C.采购经理          \\n    - [x] D.项目经理\\n\\n24. “质量成本”是一个项目管理概念，它说明了下列哪项成本\\n    - [x] A.额外需求的成本      \\n    - [ ] B.需求变更的成本\\n    - [ ] C.确保符合需求的成本    \\n    - [ ] D.固定成本\\n\\n25. 软件项目的一个重要特点是需求变更频繁，在项目管理中缺乏有效的需求变更控制流程就极有可能引起项目风险。若按照风险来源的阶段对风险进行分类，这种项目风险属于\\n    - [x] A.需求风险  \\n    - [ ] B.设计风险   \\n    - [ ] C.编程风险    \\n    - [ ] D.维护风险\\n\\n26. 在风险分析过程中，确定已经识别的一个风险事件是无法避免的，也是不能减轻的，也不能投保，这是一个关键的风险事件，一旦发生可能造成项目的失败，项目经理最佳的选择是\\n    - [ ] A.降低风险的级别，项目团队将找到一个克服故障的方法\\n    - [x] B.特别关注，加强管理该风险事件和所有的相关事件\\n    - [ ] C.让风险评估小组继续分析该风险事件，直到降低预期影响\\n    - [ ] D.忽略风险评估，因为不管赋予什么值，都只是一个估算\\n\\n27. 风险的三个属性是\\n    - [ ] A.风险发生的时间、地点、责任人 \\n    - [ ] B.风险事件、时间、影响\\n    - [x] C.风险事件、概率、影响 \\n    - [ ] D.风险数量、风险影响程度、概率\\n\\n28. 下列哪项不是风险管理的过程\\n    - [ ] A.风险评估  \\n    - [ ] B.风险识别   \\n    - [ ] C.风险规划   \\n    - [x] D.风险收集\\n\\n29. 由于政府的一项新规定，某项目的项目经理必须变更该项目的范围。项目目标已经做了若干变更，项目经理已经对项目的技术和管理文件做了必要的修改，他下一步应该\\n    - [x] A.及时通知项目干系人     \\n    - [ ] B.修改公司的知识管理体系\\n    - [ ] C.获取客户的正式认可    \\n    - [ ] D.获得政府认可\\n\\n30. 小王负责一个管理信息系统项目，最近在与客户共同进行的质量审查中发现一个程序模块不符合客户的需求，进行追溯时，也未发现相应的变更请求。最终小王被迫对这一模块进行再设计并重新编程，造成此项返工的原因可解是\\n    - [ ] A.未进行需求变更      \\n    - [x] B.未进行范围确认 \\n    - [ ] C.未进行变更管理      \\n    - [ ] D.质量管理过严\\n\\n31. 客户已经正式接收了项目，该项目的项目经理下一步工作将是\\n    - [x] A.适当的将接收文件分发给其他项目干系人\\n    - [ ] B.将项目总结向项目档案库归档\\n    - [ ] C.记录你与小组成员获得的经验 \\n    - [ ] D.进行项目审计\\n\\n32. 在某个信息系统项目中，存在新老系统切换问题，在设置项目计划网络图时，新系统上线和老系统下线之间应设置成（）的关系。\\n    - [ ] A.结束—开始(FS型)      \\n    - [ ] B.结束—结束(FF型)\\n    - [x] C.开始—结束(SF型)     \\n    - [ ] D.开始一开始(ss型)\\n\\n33. 质量控制是\\n    - [ ] A.对每个工作包增加工作时间 \\n    - [x] B.项目生存期的各个阶段都要实施的\\n    - [ ] C.只需要做一次         \\n    - [ ] D.只有大的项目才需要\\n\\n34. 采用网络模型反向遍历的目的在于决定（）\\n    - [ ] A.关键路径          \\n    - [ ] B.最早完工日期\\n    - [x] C.最迟开始日期        \\n    - [ ] D.赶工日期\\n\\n35. 激励中的期望理论认为\\n    - [ ] A.相信付出的努力很可能会产生成功的结果\\n    - [ ] B.管理者不应对工人寄望过高\\n    - [x] C.激励应与期望中具有价值的产出相关联\\n    - [ ] D.管理者不应期望薪水高的雇员工作更努力\\n\\n36. 制定项目计划时，首先应该关注的是\\n    - [x] A.项目范围说明书        \\n    - [ ] B.工作分解结构 \\n    - [ ] C.风险管理计划        \\n    - [ ] D.质量计划\\n\\n37. 在进度可视化监控方法中，哪一种方法能简单、清除地展示项目整体进度\\n    - [ ] A.延迟图  \\n    - [ ] B.时间线   \\n    - [x] C.甘特图   \\n    - [ ] D.计划与实际对比图\\n\\n38. 在项目进行过程中，一个开发人员接到某个用户的电话，用户要求更改系统中存在的一个问题，这个开发人员应该\\n    - [ ] A.马上改正问题   \\n    - [x] B.记录问题并提交项目经理\\n    - [ ] C.不予理睬     \\n    - [ ] D.通过测试部经理，要求确认问题是否存在\\n\\n39. 下面哪一种质量改进方法最不可能产生积极结果\\n    - [ ] A.持续改进   \\n    - [ ] B.统计质量过程   \\n    - [ ] C.客户跟踪过程   \\n    - [x] D.增加检验\\n\\n40. 项目的项目范围已经发生变更，因此成本基线也将发生变更，项目经理需要尽快\\n    - [ ] A.进行范围变更策略     \\n    - [ ] B.更新预算\\n    - [ ] C.记录获得经验      \\n    - [x] D.执行得到批准的范围变更\\n\\n# 2 填空题\\n\\n1.  项目管理的基本内容是计划、组织和（**监控**）\\n\\n2. 根据项目管理方法论可以将项目管理分为阶段化管理、（**量化管理**）和优化管理，\\n\\n3. 影响项目可行性的因素可分为:经济可行性、技术可行性、（**风险和不确定性**）。\\n\\n4. 由于项目的组织结构中职能型和纯项目型的两个极端代表，为了综合它们各自的优势,（**矩阵型**）应用而生，他是职能型和纯项目型的结合体。\\n\\n5. 滚动计划法是一种迭代方法，它具有分而治之、（**逐步求精**）、动态规划、和谐过渡的特点。\\n\\n6. （**WBS 工作分解结构**）是一种将复杂问题分解为简单问题，然后再根据分解的结果进行计划的方法。\\n\\n7. WBs 最低层次的项目可交付成果称为（**工作包**）。\\n\\n8. （**德尔菲法**）是一种专家评估技术，适用于在没有或者没有足够历史数据的情况下，来评定软件采用不同的技术或新技术带来的差异，但专家的水平及对项目的理解程度是工作中的关键点。\\n\\n9. 里程碑事件的工期一般设置为（**零**）\\n\\n10. 在ADM 网络图中，有时为了表示逻辑关系，需要设置一个虚活动，虚活动是不需要时间和资源的，一般用（**虚箭线**）表示:\\n\\n11. （**里程碑**）定义了当前阶段完成的标准和下阶段启动的前提或条件。\\n\\n12. （**质量计划**）是进行项目质量管理、实现项目质量方针和目标的具体体现。\\n\\n13. （度量）提供了对项目进度评估、质量状况的洞察力和用于决策的有关数据。\\n\\n14. （**风险评审技术**）是为了适应某些有高度不确定性和风险性的决策问题而开发一种网络仿真系统。\\n\\n15. 外包是（**风险转移**）类型的风险处理策略。\\n\\n16. 涉及多个领域工作的复杂项目最好采用（**矩阵型组织**）来管理。\\n\\n17. 软件开发中大多数的变更都是来源于（**需求变更**）。\\n\\n18. （**收尾**）是项目生命周期的最后一个阶段，也是形成产品闭环的关键步骤。\\n\\n19. 马斯洛需求层次论把需求分为生理需求、安全需求、社会需求、尊重需求、（**自我实现需求**）。\\n\\n20. 良好的工作氛围概括起来就是：开放、（**真诚**）、平等、信任。\\n\\n# 3 判断题\\n\\n1. 受控环境中的项目是组织、管理和控制项目的方法，强调通过管理方法使项目环境得到控制。      （√）\\n2. 软件不同于一般的传统的产品，它是对物理世界的一种抽象，是逻辑性、知识性的产物。        （√）\\n3. 项目管理的核心是成本。  （×）\\n4. 根据项目管理方法论可以将项目管理分为阶段化管理、量化管理和优化管理，其中量化管理是项目管理的基本方法。 （×）\\n5. 项目建议书必须尽可能的详细。（×） \\n6. 项目可行性分析是项目启动阶段的关键活动，旨在判断一个项目是否值得做或者是挑选许多待选项目中的最佳项目。 （√）\\n7. 投资回收期分析法是经济可行性分析中最可靠的方法。（×）\\n8. 极限编程的基本思想是“沟通、简单、反馈、勇气”。（√）\\n9. WBS最底层的项目只能由一人负责。（√）\\n10. 在软件项目管理中，计划编制是最复杂的阶段，却经常不受重视。（√）\\n11. 软件项目的项目计划可以由一个人独立完成，不需要与项目干系人沟通。（×）\\n12. PMBOK 将项目计划过程分为核心过程和辅助过程两个部分。（√）\\n13. 软件估算的方法有许多，可以分为直接方法和间接方法，如功能点估算方法就是软件规模估算中的直接方法。（×）\\n14. 软件项目的估算结果都是比较准确地。（×）\\n15. 在进行软件项目估算时，可以参照其他企业的估算模型。（√）\\n16. 成本估算一般情况下都可能不是非常精确，尤其是软件项目更是如此。（√）\\n17. 甘特图可以显示任务的基本信息，使用甘特图能方便地查看任务的工期，开始和结束时间以及资源的信息。（√）\\n18. 为了得到一个相对准确的估算结果，项目管理者应该系统的学习相关的成本（√）\\n19. IT项目尤其是软件项目的成本管理一直没有一个好的口碑，但成本超支很少见。()错\\n20. 成本估算不准确有很多原因，有主观原因也有客观原因。（√）\\n21. PSP 指软件工程过程组，其要质量目标是编译和单元测试之前发现和修复缺陷。()错\\n22. 产品的缺陷密度或者测试阶段的缺陷率是概括性指标。（√）\\n23. 软件度量主要包括3部分:项目度量、产品度量和过程度量（√）\\n24. 鱼骨图分析方法要完成从小刺到主刺的思维和分析过程。（×）\\n25. TOP风险清单中的条目越多越好。（×）\\n26. 风险识别、风险评估、风险规划、风险控制是风险管理的四个过程。（√）\\n27. 当风险发生的概率极高、风险后果影响很严重时，才可以考虑采用回避风险策略。（×）\\n28. 风险是损失发生的不确定性，是对潜在的、未来可能发生损害的一种度量。（√）\\n29. 在当今高科技环境下，x理论和期望理论可以用来激励一个团队员工的工作士气。（×）\\n30. 在项目早期和信息不足的时候，可以采用自下而上的估算方法进行成本估算。（×）\\n31. 需求分析过程是确定项目如何实现的过程，并确定项目的技术方案（×）\\n32. 软件项目的估算结果是比较准确的。（×）\\n33. 基线产品是不能修改的。（×）\\n34. 在 IT 项目中，许多专家都认为：对于成功，威胁最大的就是沟通的失败。（√）\\n35. 采购是为了换行项目而从项目团队外部采购或者获取产品、服务或者结果的过程。（√）\\n36. 进度和成本是关系最为老切的两个目的，几乎成了对立关系，进度的缩短一定依靠增加成本实现，而成本的降低也一定牺牲工期进度为代价的。（×）\\n37. 项目早期和信息不足的时候，可以采用自下而上的估算方法进行成本估算（×）\\n38. 统计需求变更请求的数量是配置审核过程。（√）\\n39. 质量保证属于检查职能，而质量控制属于管理职能。（×）\\n40. 采用德尔菲方法来标识风险可以减少人为的偏差，以便作出正确决定（√）\\n41. 取消采用具有高风险的新技术，而采用原来热悉的技术\\\"是一种转移风险的规划策略（√）\\n\\n# 4 简答题\\n\\n1. **项目生命周期分为5个阶段，请简要概述（P6）**\\n\\n   1. 启动。项目获得授权正式被**立项，并成立项目组**，宣告项目开始。启动是一种认可过程，用来正式认可一个新项目或新阶段的存在。\\n   2. 计划。**明确项目范围**，定义和评估项目目标，选择实现项目目标的最佳策略，**制订项目计划。**\\n   3. 执行。调动资源，**完成项目管理计划中确定的工作**。\\n   4. 控制。**监控和评估项目偏差**，必要时采取纠正行动，以**保证项目计划的执行**，**实现项目目标**。\\n   5. 结束。**完成项目验收**，使其按程序结束。\\n\\n2. **简述 WBS 制定的原则。**\\n\\n   1. 某项具体的任务应该在一个工作包且只能在一个工作包中出现\\n   2. WBS中某项任务的内容是其下所有WBS项的总和\\n   3. 一个工作包只能由一个人负责\\n   4. 任务的分解，尽量与实际执行方式保持一致。\\n   5. 分解合理，具有良好的稳定性和适应性\\n   6. 鼓励项目团队成员积极参与创建WBS\\n   7. 所有成果需要文档化\\n\\n3.  **什么是质量管理，软件质量管理的保证组织有哪些?** \\n\\n   质量管理是指：确定质量方针、目标和职责并在质量体系中通过质量计划、质量控制、质量保证和质量改进使其实施的全部管理职能的所有活动。\\n\\n   1、采用技术手段和工具；2、组织正式技术平时；3、加强软件测试；4、推行软件工程规范（标准）；5、对软件的变更进行控制；6对软件质量进行度量。\\n\\n4. **简述应对风险的基本措施?**\\n\\n   1. 规避。通过变更项目计划消除风险或风险的触发条件，使目标免受影响。\\n   2. 转移。不能消除风险，而是将项目风险的结果连同应对的权利转移给第三方。\\n   3. 弱化。将风险时间的概率或结果降低到一个可以接受的程度，其中降低发生的概率更为有效。\\n   4. 接受。不改变项目计划，而考虑发生后如何应对\\n\\n5. **风险监控的措施有哪些?**\\n\\n   1. 风险识别\\n   2. 风险估计 \\n   3. 风险管理策略 \\n   4. 风险解决 \\n   5. 风险监控\\n\\n6. **如何确保知识经验共享?**\\n\\n   1. 企业角度\\n\\n      要先提倡和强调重要性。\\n\\n      其次要确立正确而鼓舞人心的知识管理愿景和战略目标。\\n\\n      再次要建立指导监督团队来提供足够的推动力。\\n\\n      激励知识共享的贡献者。\\n\\n   2. 个人角度\\n\\n      做到无私奉献，无偿分享。\\n\\n      积极参与知识的分享和讨论，在讨论中不断学习、相互提高，真正实现从知识到能力的跨越。\\n\\n7. 什么是绩效管理？如何做好绩效管理？\\n\\n   所谓绩效管理就是企业为了持续发展及保持良好的发展趋势，为了提高业绩与效率，制定一定的激励方式，让员工可以按时完成任务，整体提高员工工作积极性和提高企业产能。\\n\\n    1、绩效管理准备工作\\n\\n    2、明确绩效分工流程\\n\\n   3、做好绩效管理方案\\n\\n   4、绩效管理的反馈\\n\\n   5、绩效管理的改进\\n\\n   6、绩效管理的维护及存档\\n\\n8. 如何在项目监控阶段，区分缺陷的优先级和重要性？\\n\\n​\\t\\t\\t1. 缺陷跟踪\\n\\n​\\t\\t\\t2. 技术检查\\n\\n​\\t\\t\\t3. 源代码追踪\\n\\n​\\t\\t\\t4. 测试\\n\\n9. 简述项目验收的内容\\n\\n​\\t\\t\\t1. 软件系统验收\\n\\n​\\t\\t\\t2. 质量验收\\n\\n​\\t\\t\\t3. 资料验收\\n\\n10. 在进行项目总结时，应该注意哪些问题？\\n\\n​\\t\\t\\t1. 项目概况，质量结果分析；\\n\\n​\\t\\t\\t2. 项目进展情况；\\n\\n​\\t\\t\\t3. 好的经验；\\n\\n​\\t\\t\\t4. 不足之处；\\n\\n​\\t\\t\\t5. 改进方案和建议。\\n\\n# 5 计算器\\n\\n一、一个软件企业现在面对两个项目的选择\\n\\n一个软件企业现在面对两个项目的选择。他们经过分析得得出这样的结论:如果做项目A，盈利的概率是20%，可以盈利30万元，但是同时亏损的概既率是80%，亏损4万元;如果做项目B.盈利的概率是70%，盈利6万元，但同时有两种亏损的可能，其一是10%的概率亏损2万，其二是20%的概率亏损5万。请用决策树的方法计计算出两个项目的预期收益，并判断哪个项目是比较有利的选择。\\n\\n（1）：该企业两个项目的决策树如下：\\n\\n![image-20221101235338174](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%80%83%E8%AF%95/image-20221101235338174-d92.png)\\n\\n---\\n\\n一、阅读以下说明，回答问题1至问题3。\\n\\n某信息系统集成企业承担了甲方的信息系统集成项目，在项目的采购过程中，某项采购合同是在甲方的授意下签订的，然而在项目进展过程中，项目经理发现该采购产品高于市场价格，而且有些性能指标也没有能够完全满足合同规定要求。当项目经理发现此类问题进行调查时，发现该供应商的资质和声誉都存在问题，并且就在不久前已经被其他公司并购，最麻烦的是合同的付款条件是提前支付相关款项，合同的大部分采购款已经支付。\\n\\n在项目的中期验收中，甲方发现了部分采购产品存在的问题，并要求项目组进行返工和更换相关产品。项目经理则以采购供应商是由甲方推荐为由，拒绝进行返工和更换。而甲方则认为，项目合同里面并没有规定由甲方承担采购责任，甲方只是为项目组推荐了部分供应商，而供应商已被收购，原先的公司已经不存在，原先的责任人已经离职为由，拒绝根据合同相关条款更换产品，项目经理对此束手无策。项目经理和甲方就该问题相持不下，项目处于停滞状态。\\n\\n1. 问题1结合案例，请指出项目组在采购合同管理中存在什么问题?\\n\\n   1. **合同签订有问题，不应轻易采用甲方的推荐。**\\n   2. **合同支付条款不合理。**\\n   3. **合同执行有问题，设备指标不满足要求时，未能及时有效的管控。**\\n   4. **合同变更问题，供应商被并购以后，合同没有及时变更相应条款。**\\n\\n2. 问题2在采购合同中，支付方式的规定一般包括哪些方面的内容?甲方的做法是否妥当，是分散否该为此承担主要责任?\\n\\n   1. **支付方式的内容**\\n   2. **支付货款的条件**\\n   3. **结算支付的时限、方式**\\n   4. **拒付货款。发包方有权部分或全部拒付货款**\\n   5. **甲方的做法不妥当。不应该承担主要责任。**\\n\\n3. 问题3供应商是否可以以公司变更、负责人离职为由，拒绝履行公司变更前签订的协议?为什么?对此而日经那该加何外开?\\n\\n   **不可以。因为供应商公司变更不影响其对已经售出的货物的质量保证义务，新公司需要继续履行原供应商签订的协议。项目经理可以启动索赔程序。先进行调解，调解不成，由经济合同仲裁委员会进行调解或仲裁。**\\n\\n---\\n\\n二、在项目的中期验收中，甲方发现了部分采购产品存在的问题，并要求项目组选行返工和更换相关产 品。项目经理则以采购供应商是由甲方推荐为由，拒绝送行返工和更换。而甲方则认为，项目合同里 面并没有规定由甲方系担采购责任，甲方只是为项目组推荐了部分供应商，而供应南己枝收购，原先 的公司己经不存在，原先的责任人已经高职为由，拒绝根据合同相关条款更换产品，项目经理对此束 手无策。项目经理和甲方就该问题相持不下，项目处手停滞状态。 \\n\\n问题 1 结合案例，请指出项目组在采购合同管理中存在什么问题？ \\n\\n**1）合同签订有问题，不应经易采用甲方的推荐。2）合同支付条款不合理。3）合同执行有问题，设备 指标不满足要求时，未能及时有放的管拉。4）合同支更问题，供应商被并购以后，合同没有及时变更 相应条款。** \\n\\n问题 2 在采购合同中，交付方式的规定一般包括哪些方面的内容？甲方的做法是否妥当，是否该为比 承担主要贡任？ \\n\\n**支付方式的内容：1）支付货款的条件：2）结算支付的时限、方式：3）拒付货款。发包方存权部分或 全部柜付货款。4）平方的做法不妥当，不应该承担主要责任。**\\n\\n问题 3 供应商是否可以以公司变更、众责人离职为由，拒绝履行公司变更前签订的协议？为什么？对 此项目经理该如何处理？ \\n\\n**不可以。因为供应商公司变更不影响其对己经售出的货物的质量保证义务，新公司需要继续履行原供 应商签订的协议。 项目经理可以启动索赔程序。先进行调解，阔解不成，由经济合同仲教委员会选行调解或仲裁。**\\n\\n---\\n\\n三、软件项目需求变更\\n\\n1. 提出变更\\n2. 评估变更\\n3. 决策变更\\n4. 实施变更\\n5. 验证变更\\n\\n---\\n\\n四、阅读以下说明，回答问题1至问题 3。\\n\\n某创业型公司乙在2015年1月，凭借着报价低的优势中标承接了一个信息系统工程项目。项目建设内容主要包括建设方甲公司的北京总公司ERP信息系统建设，以及甲公司成都分公司的机房改造项目。甲乙两公司协商签订了工程额为100万元的总价合同，工期为一年。乙公司指派有过ERP项目经验的张工承担项目经理，因公司还处于创业期间，所以公司管理层非常注重成本的控制，要求项目经理严格控制成本，每周汇报项目的实际花费。为了满足\\n\\n低成本的要求，考虑到北京、成都两地的材料、差旅费用等问题，在征得甲公司与管理层的同意后，张工将机房改造工程外包给成都当地的丙公司，并在合同中要求丙公司必须在2015年底之前完工。\\n\\n项目执行期间。张工指派了一名成本控制专员，负责每周统计该项目ERP 部分所发生的费用。同时向管理层提交费用统计报告。项目进展到6月份。项目 ERP 部分实际发生的总费用为30 万元。成都赶上了梅雨季节，丙公司反馈因机房处于某大厦的低层，太潮湿，机房改造工程被迫暂停。待梅雨季节过后继续施工。\\n\\n项目执行到2015年底，机房改造项目已确定无法在2016年1月如期完工，ERP部分虽然基本到了后期的测试阶段，但其总费用也已经达到了 60 万元。\\n\\n问题1根据案例，2016年1月机房改造工程无法如期完工，请指出乙公司是否可以向丙公司索赔?如可以，请说明可以申请什么索赔?如不可以，请说明理由。\\n\\n**可以索赔。可以申请延长工期索赔。 (机房改造属于室内施工，雨季不是进度延期的不可抗因素)**\\n\\n问题2结合以上案例，请帮助张工提出成本管理及成本控制方面的改进措施。\\n\\n**1.根据项目实际情况，制定成本管理计划，并得到公司高层批准。2、采用科学方法对项目进行成本估算和预算。 3、按计划掌握项目实际成本支出情况(包括北京、成都两地)。4将实际成本与成本计划进行比较，掌握项目成本绩效。 5、如果实际成本不符合计划，则进行偏差分析，制定相关纠偏措施。 6、做好相关文档的记录和存档。**\\n\\n问题 3结合以上案例，在项目后期，请帮助项目经理张工提出一些可以弥补工期耽误的方法。\\n\\n**1.要求丙方采取措施进行赶工。 2.对丙方工程进度严格控制。3.与甲方进行沟通，必要时，修改进度计划。**\\n\\n---\\n\\n五、已知某信息工程项目由A到G7个活动组成，项目根据项目目标特别施工期要求，经过分析、定义及评审，给出了该项目的活动历时。活动资源及活动逻辑关系如下表所示:\\n\\nA:需求分析 10 2\\n\\nB:软件设计 10 2 A\\n\\nC:测试案例编写 12 3 A\\n\\nD:编程实现 15 4 B\\n\\nE:软件测试 15 3 C、D\\n\\nF:编写用户手册 5 1 A\\n\\nG:调试软件系统 3 2 E\\n\\n问题 1:绘制该项目活动的前导网络图问题\\n\\n问题2:指出该项目的关键路径和工期问题\\n\\n问题3:指出其他路径的项目缓冲期\\n\\n问题4:为了配合甲方公司成立庆典，甲方要求该项目提前10天完工，并同意支付额外费用。承建单位经过论证，同意了甲方要求并按规范执行了审批流程。为了保质保量按期完工，\\n\\n![image-20221102005159821](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%80%83%E8%AF%95/image-20221102005159821-33a.png)\\n\\n---\\n\\n六、\\n\\n项目经理小王目前正在负责—个小型的软件开发项目。—开始他觉得项目比较小，变更应该不多，流程也不需要太复杂，因此就没有制定项目变更管理计划，而是强调团队成员间的及时沟通来保证项目按照计划进行：根据项目经理小王的理解．所谓变更管理的主要目标就是<u>保证项目能够按照计划进行</u>，如果能够保证不发生超越项目进度计划、成本计划等控制范围外的偏差，就可以<u>不用指定项目变更管理计划</u>．就可以不用指定项目变更管理计划，以减少项目的工作量。而项目执行过程中对计划的微调根本<u>不需要记录和管理</u>，也<u>不需要走项目变更管理流程</u>。而且他认为如果所有<u>项目变更都必简要向相关领导请示汇报</u>，过程太复杂和麻烦，还不如由执行人员提出变更的方案，彼此讨论—直后来的更方便和快捷。\\n\\n但是在项目进入集成测试阶段的时候，突然多了很多莫名其妙的问题出现。如在调试过程中。由于相关设计和记录的简化和不规范，造成了调试的困难，很难定位各个问题模块的错误；由于项目执行过程中。人员的调配替换，造成了文档记录的不—敢，导致后期人员阅读和理解方面的障碍。并且由于缺乏对开发过程的配置管理和控制，导致版本混乱，很难形成有效支持各模块集成的文档。另外，面目中很多细小的改动由于没有准确的记录，或者是根本没有记录．导致集成测试发现问题时，根本没有办法更改。小王对此也没有办法，不知道因为什么原因导致目前的项目状态，项目面临返工的危险。\\n\\n【问题1】结合案例。请说项目经理小王对项目变更管理的认识哪些星正确的？哪些是不正确的?\\n\\n**1、小王对项目变更管理的认识正确的是：**\\n\\n**（1）变更管理的目的是保证项目按计划进行；**\\n\\n**（2）项目变更需要获得相关干系人认可，讨论一致。**\\n\\n**（每项1分，共2分）**\\n\\n**2、小王对项目变更管理认识不正确的是：**\\n\\n**（1）不用制定项目变更管理计划；**\\n\\n**（2）对计划的微调根本不需要记录和管理；**\\n\\n**（3）不需要走变更管理流程。**\\n\\n【问题2】根据你的理解，请说明项目变更管理在软件项目管理中的主要活动内容\\n\\n**变更管理在软件项目管理中的主要活动内容**\\n\\n**(1)识别可能发生的变更。**\\n\\n**(2)管理每个已识别的变更。**\\n\\n**(3)维持所有基线的完整性。**\\n\\n**(4)根据已批准的变更，更新范围、成本、预算、进度和质量要求，协调整体项目内的变更。**\\n\\n**(5)基于质量报告，控制项目质量使其符合标准。**\\n\\n**(6)维护一个及时、精确的关于项目产品及其相关文档的信息库，直至项目结束。**\\n\\n【问题3】针对项目的当前状态，小王应该采取说明补救措施？\\n\\n**1、补一个变更管理计划；**\\n\\n**2、建立变更管理的流程；**\\n\\n**3、建立变更管理委员会；**\\n\\n**4、加强配置管理；**\\n\\n**5、加强版本管控；**\\n\\n**6、加强变更管理，有变更走流程。**\\n\",\"articleCover\":\"http://figurebed-1311634249.cos.ap-beijing.myqcloud.com/articles/9cdd0d0402007823150b1db80244cf0c.jpg\",\"articleTitle\":\"软件项目管理\",\"categoryName\":\"学习和技术总结\",\"id\":75,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.104', '山西省太原市 移动', '2022-11-02 09:42:40', NULL);
INSERT INTO `tb_operation_log` VALUES (1282, '文章模块', '新增或修改', '/admin/articles', 'com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 1 选择题\\n\\n1. 下列工作中不属于项目的是\\n   - [ ] A.策划一场婚礼\\n   - [ ] B.开发一款软件\\n   - [x] C.为人民服务\\n   - [ ] D.主持一场会议\\n\\n2. 下列不属于项目特性的是\\n   - [ ] A.一次性  \\n   - [x] B.新颖性 \\n   - [ ] C.目标性  \\n   - [ ] D.约束性\\n\\n3. 项目管理的对象集中在对3P的管理，下列不属于3P的是\\n   - [ ] A.人员  \\n   - [ ] B.问题  \\n   - [ ] C.过程  \\n   - [x] D.保证\\n\\n4. 项目管理需要在互相间有冲突的要求中找到平衡，除了以下哪个\\n   - [x] A.甲方和乙方的利益          \\n   - [ ] B.范围、时间、成本、质量\\n   - [ ] C.有不同项目需求和期望的项目干系人 \\n   - [ ] D.明确和未明确表达的需求\\n\\n5. 项目管理中的三种组织结构，哪一种沟通最为复杂\\n   - [ ] A.职能型  \\n   - [ ] B.纯项目 \\n   - [x] C.矩阵型  \\n   - [ ] D.都一样\\n\\n6. 项目经理的职责不包括以下哪项内容\\n   - [ ] A.开发计划   \\n   - [ ] B.组织实施  \\n   - [ ] C.项目控制  \\n   - [x] D.系统支持\\n\\n7. 可以构建一部分系统的模型，通过用户试用提出优缺点，最好选择（）生存期模型 \\n   - [ ] A.增量式模型  \\n   - [x] B.原型    \\n   - [ ] C.螺旋型    \\n   - [ ] D.v模型\\n\\n8. 乙方在项目初始阶段的主要任务不包含以下哪一项\\n   - [ ]   A.项目分析   \\n   - [ ] B.招投标   \\n   - [x] C.合同管理   \\n   - [ ] D.合同签署\\n\\n10. 需求分析完成的标志是\\n    - [ ] A.开发出初步模型   \\n    - [x] B.提交一份完整的软件需求规格说明书\\n    - [ ] C.提交一份工作称述  \\n    - [ ] D.提交项目章程\\n\\n11. WBS中的每一个具体细目通常都指定唯一的\\n    - [x] A.编码  \\n    - [ ] B.责任人  \\n    - [ ] C.功能模块  \\n    - [ ] D.提交日期\\n\\n12. 项目计划方法中，（）是能直观的表达软件开发众多工序之间的逻辑关系与时间关系。 \\n    - [ ] A.滚动计划法  \\n    - [ ] B.工作结构分解 \\n    - [x] C.网络计划技术 \\n    - [ ] D.构造性成本法\\n\\n13. 代码行估算方法属于以下基本估算方法中的哪一种。（）\\n    - [x] A.分解法    \\n    - [ ] B.算数模型    \\n    - [ ] C.专家判断   \\n    - [ ] D.比例法\\n\\n14. 在项目估算的基本内容中，（）是软件项目量化的结果，很大程度上代表了项目范围的大小。\\n\\n    - [ ] A.风险估算  \\n\\n    - [ ] B.工作量估算 \\n\\n    - [x] C.规模估算  \\n\\n    - [ ] D.其他估算\\n\\n15. 下列不属于按照详细情况划分的3个等级构造性成本模型的是（）\\n    - [ ] A.基本 COCOMO    \\n    - [ ] B.中间 COCOMO \\n    - [x] C.发展 COCOMO    \\n    - [ ] D.详细 COCOMO\\n\\n16. 项目管理人员根据个人能力、是否有空闲时间进行项目活动人员分配时有A、P、R、S 四种类别，其中A表示（）\\n    - [x] A.负责    \\n    - [ ] B.参与   \\n    - [ ] C.检查    \\n    - [ ] D.批准\\n\\n17. 压缩软件项目的工期时，你应该关注（）\\n    - [x] A.关键路径  \\n    - [ ] B.非关键路径  \\n    - [ ] C.准关键活动  \\n    - [ ] D.活动缓冲期\\n\\n18. “软件编码完成之后，我才可以对它进行软件测试”这句话体现了项目活动之间的哪种关系\\n    - [ ] A.开始-开始   \\n    - [x] B.结束-开始   \\n    - [ ] C.结束-结束   \\n    - [ ] D.开始-结束\\n\\n19. 在成本管理过程中，项目经理确定的每个时间段，各个工作单元的成本是\\n    - [ ] A.估算    \\n    - [ ] B.预算     \\n    - [x] C.直接成本   \\n    - [ ] D.间接成本\\n\\n20. 估算文件不属于以下哪一项\\n    - [x] A.功能模块  \\n    - [ ] B.质量标准  \\n    - [ ] C.资源及数量   \\n    - [ ] D.估算成本\\n\\n21. 下列不属于软件评审方法的是\\n    - [ ] A.同行评审   \\n    - [ ] B.走查     \\n    - [ ] C.会议审查    \\n    - [x] D.测试\\n\\n22. 软件项目质量的组织保证是\\n    - [ ]  A.顾客     \\n    - [ ] B.用户     \\n    - [ ] C.提供者     \\n    - [x] D.SEPG组\\n\\n23. 项目质量管理的最终责任由谁来承担\\n    - [ ] A.项目开发经理        \\n    - [ ] B.质量经理\\n    - [ ] C.采购经理          \\n    - [x] D.项目经理\\n\\n24. “质量成本”是一个项目管理概念，它说明了下列哪项成本\\n    - [x] A.额外需求的成本      \\n    - [ ] B.需求变更的成本\\n    - [ ] C.确保符合需求的成本    \\n    - [ ] D.固定成本\\n\\n25. 软件项目的一个重要特点是需求变更频繁，在项目管理中缺乏有效的需求变更控制流程就极有可能引起项目风险。若按照风险来源的阶段对风险进行分类，这种项目风险属于\\n    - [x] A.需求风险  \\n    - [ ] B.设计风险   \\n    - [ ] C.编程风险    \\n    - [ ] D.维护风险\\n\\n26. 在风险分析过程中，确定已经识别的一个风险事件是无法避免的，也是不能减轻的，也不能投保，这是一个关键的风险事件，一旦发生可能造成项目的失败，项目经理最佳的选择是\\n    - [ ] A.降低风险的级别，项目团队将找到一个克服故障的方法\\n    - [x] B.特别关注，加强管理该风险事件和所有的相关事件\\n    - [ ] C.让风险评估小组继续分析该风险事件，直到降低预期影响\\n    - [ ] D.忽略风险评估，因为不管赋予什么值，都只是一个估算\\n\\n27. 风险的三个属性是\\n    - [ ] A.风险发生的时间、地点、责任人 \\n    - [ ] B.风险事件、时间、影响\\n    - [x] C.风险事件、概率、影响 \\n    - [ ] D.风险数量、风险影响程度、概率\\n\\n28. 下列哪项不是风险管理的过程\\n    - [ ] A.风险评估  \\n    - [ ] B.风险识别   \\n    - [ ] C.风险规划   \\n    - [x] D.风险收集\\n\\n29. 由于政府的一项新规定，某项目的项目经理必须变更该项目的范围。项目目标已经做了若干变更，项目经理已经对项目的技术和管理文件做了必要的修改，他下一步应该\\n    - [x] A.及时通知项目干系人     \\n    - [ ] B.修改公司的知识管理体系\\n    - [ ] C.获取客户的正式认可    \\n    - [ ] D.获得政府认可\\n\\n30. 小王负责一个管理信息系统项目，最近在与客户共同进行的质量审查中发现一个程序模块不符合客户的需求，进行追溯时，也未发现相应的变更请求。最终小王被迫对这一模块进行再设计并重新编程，造成此项返工的原因可解是\\n    - [ ] A.未进行需求变更      \\n    - [x] B.未进行范围确认 \\n    - [ ] C.未进行变更管理      \\n    - [ ] D.质量管理过严\\n\\n31. 客户已经正式接收了项目，该项目的项目经理下一步工作将是\\n    - [x] A.适当的将接收文件分发给其他项目干系人\\n    - [ ] B.将项目总结向项目档案库归档\\n    - [ ] C.记录你与小组成员获得的经验 \\n    - [ ] D.进行项目审计\\n\\n32. 在某个信息系统项目中，存在新老系统切换问题，在设置项目计划网络图时，新系统上线和老系统下线之间应设置成（）的关系。\\n    - [ ] A.结束—开始(FS型)      \\n    - [ ] B.结束—结束(FF型)\\n    - [x] C.开始—结束(SF型)     \\n    - [ ] D.开始一开始(ss型)\\n\\n33. 质量控制是\\n    - [ ] A.对每个工作包增加工作时间 \\n    - [x] B.项目生存期的各个阶段都要实施的\\n    - [ ] C.只需要做一次         \\n    - [ ] D.只有大的项目才需要\\n\\n34. 采用网络模型反向遍历的目的在于决定（）\\n    - [ ] A.关键路径          \\n    - [ ] B.最早完工日期\\n    - [x] C.最迟开始日期        \\n    - [ ] D.赶工日期\\n\\n35. 激励中的期望理论认为\\n    - [ ] A.相信付出的努力很可能会产生成功的结果\\n    - [ ] B.管理者不应对工人寄望过高\\n    - [x] C.激励应与期望中具有价值的产出相关联\\n    - [ ] D.管理者不应期望薪水高的雇员工作更努力\\n\\n36. 制定项目计划时，首先应该关注的是\\n    - [x] A.项目范围说明书        \\n    - [ ] B.工作分解结构 \\n    - [ ] C.风险管理计划        \\n    - [ ] D.质量计划\\n\\n37. 在进度可视化监控方法中，哪一种方法能简单、清除地展示项目整体进度\\n    - [ ] A.延迟图  \\n    - [ ] B.时间线   \\n    - [x] C.甘特图   \\n    - [ ] D.计划与实际对比图\\n\\n38. 在项目进行过程中，一个开发人员接到某个用户的电话，用户要求更改系统中存在的一个问题，这个开发人员应该\\n    - [ ] A.马上改正问题   \\n    - [x] B.记录问题并提交项目经理\\n    - [ ] C.不予理睬     \\n    - [ ] D.通过测试部经理，要求确认问题是否存在\\n\\n39. 下面哪一种质量改进方法最不可能产生积极结果\\n    - [ ] A.持续改进   \\n    - [ ] B.统计质量过程   \\n    - [ ] C.客户跟踪过程   \\n    - [x] D.增加检验\\n\\n40. 项目的项目范围已经发生变更，因此成本基线也将发生变更，项目经理需要尽快\\n    - [ ] A.进行范围变更策略     \\n    - [ ] B.更新预算\\n    - [ ] C.记录获得经验      \\n    - [x] D.执行得到批准的范围变更\\n\\n# 2 填空题\\n\\n1.  项目管理的基本内容是计划、组织和（**监控**）\\n\\n2. 根据项目管理方法论可以将项目管理分为阶段化管理、（**量化管理**）和优化管理，\\n\\n3. 影响项目可行性的因素可分为:经济可行性、技术可行性、（**风险和不确定性**）。\\n\\n4. 由于项目的组织结构中职能型和纯项目型的两个极端代表，为了综合它们各自的优势,（**矩阵型**）应用而生，他是职能型和纯项目型的结合体。\\n\\n5. 滚动计划法是一种迭代方法，它具有分而治之、（**逐步求精**）、动态规划、和谐过渡的特点。\\n\\n6. （**WBS 工作分解结构**）是一种将复杂问题分解为简单问题，然后再根据分解的结果进行计划的方法。\\n\\n7. WBs 最低层次的项目可交付成果称为（**工作包**）。\\n\\n8. （**德尔菲法**）是一种专家评估技术，适用于在没有或者没有足够历史数据的情况下，来评定软件采用不同的技术或新技术带来的差异，但专家的水平及对项目的理解程度是工作中的关键点。\\n\\n9. 里程碑事件的工期一般设置为（**零**）\\n\\n10. 在ADM 网络图中，有时为了表示逻辑关系，需要设置一个虚活动，虚活动是不需要时间和资源的，一般用（**虚箭线**）表示:\\n\\n11. （**里程碑**）定义了当前阶段完成的标准和下阶段启动的前提或条件。\\n\\n12. （**质量计划**）是进行项目质量管理、实现项目质量方针和目标的具体体现。\\n\\n13. （度量）提供了对项目进度评估、质量状况的洞察力和用于决策的有关数据。\\n\\n14. （**风险评审技术**）是为了适应某些有高度不确定性和风险性的决策问题而开发一种网络仿真系统。\\n\\n15. 外包是（**风险转移**）类型的风险处理策略。\\n\\n16. 涉及多个领域工作的复杂项目最好采用（**矩阵型组织**）来管理。\\n\\n17. 软件开发中大多数的变更都是来源于（**需求变更**）。\\n\\n18. （**收尾**）是项目生命周期的最后一个阶段，也是形成产品闭环的关键步骤。\\n\\n19. 马斯洛需求层次论把需求分为生理需求、安全需求、社会需求、尊重需求、（**自我实现需求**）。\\n\\n20. 良好的工作氛围概括起来就是：开放、（**真诚**）、平等、信任。\\n\\n# 3 判断题\\n\\n1. 受控环境中的项目是组织、管理和控制项目的方法，强调通过管理方法使项目环境得到控制。      （√）\\n2. 软件不同于一般的传统的产品，它是对物理世界的一种抽象，是逻辑性、知识性的产物。        （√）\\n3. 项目管理的核心是成本。  （×）\\n4. 根据项目管理方法论可以将项目管理分为阶段化管理、量化管理和优化管理，其中量化管理是项目管理的基本方法。 （×）\\n5. 项目建议书必须尽可能的详细。（×） \\n6. 项目可行性分析是项目启动阶段的关键活动，旨在判断一个项目是否值得做或者是挑选许多待选项目中的最佳项目。 （√）\\n7. 投资回收期分析法是经济可行性分析中最可靠的方法。（×）\\n8. 极限编程的基本思想是“沟通、简单、反馈、勇气”。（√）\\n9. WBS最底层的项目只能由一人负责。（√）\\n10. 在软件项目管理中，计划编制是最复杂的阶段，却经常不受重视。（√）\\n11. 软件项目的项目计划可以由一个人独立完成，不需要与项目干系人沟通。（×）\\n12. PMBOK 将项目计划过程分为核心过程和辅助过程两个部分。（√）\\n13. 软件估算的方法有许多，可以分为直接方法和间接方法，如功能点估算方法就是软件规模估算中的直接方法。（×）\\n14. 软件项目的估算结果都是比较准确地。（×）\\n15. 在进行软件项目估算时，可以参照其他企业的估算模型。（√）\\n16. 成本估算一般情况下都可能不是非常精确，尤其是软件项目更是如此。（√）\\n17. 甘特图可以显示任务的基本信息，使用甘特图能方便地查看任务的工期，开始和结束时间以及资源的信息。（√）\\n18. 为了得到一个相对准确的估算结果，项目管理者应该系统的学习相关的成本（√）\\n19. IT项目尤其是软件项目的成本管理一直没有一个好的口碑，但成本超支很少见。()错\\n20. 成本估算不准确有很多原因，有主观原因也有客观原因。（√）\\n21. PSP 指软件工程过程组，其要质量目标是编译和单元测试之前发现和修复缺陷。()错\\n22. 产品的缺陷密度或者测试阶段的缺陷率是概括性指标。（√）\\n23. 软件度量主要包括3部分:项目度量、产品度量和过程度量（√）\\n24. 鱼骨图分析方法要完成从小刺到主刺的思维和分析过程。（×）\\n25. TOP风险清单中的条目越多越好。（×）\\n26. 风险识别、风险评估、风险规划、风险控制是风险管理的四个过程。（√）\\n27. 当风险发生的概率极高、风险后果影响很严重时，才可以考虑采用回避风险策略。（×）\\n28. 风险是损失发生的不确定性，是对潜在的、未来可能发生损害的一种度量。（√）\\n29. 在当今高科技环境下，x理论和期望理论可以用来激励一个团队员工的工作士气。（×）\\n30. 在项目早期和信息不足的时候，可以采用自下而上的估算方法进行成本估算。（×）\\n31. 需求分析过程是确定项目如何实现的过程，并确定项目的技术方案（×）\\n32. 软件项目的估算结果是比较准确的。（×）\\n33. 基线产品是不能修改的。（×）\\n34. 在 IT 项目中，许多专家都认为：对于成功，威胁最大的就是沟通的失败。（√）\\n35. 采购是为了换行项目而从项目团队外部采购或者获取产品、服务或者结果的过程。（√）\\n36. 进度和成本是关系最为老切的两个目的，几乎成了对立关系，进度的缩短一定依靠增加成本实现，而成本的降低也一定牺牲工期进度为代价的。（×）\\n37. 项目早期和信息不足的时候，可以采用自下而上的估算方法进行成本估算（×）\\n38. 统计需求变更请求的数量是配置审核过程。（√）\\n39. 质量保证属于检查职能，而质量控制属于管理职能。（×）\\n40. 采用德尔菲方法来标识风险可以减少人为的偏差，以便作出正确决定（√）\\n41. 取消采用具有高风险的新技术，而采用原来热悉的技术\\\"是一种转移风险的规划策略（√）\\n\\n# 4 简答题\\n\\n1. **项目生命周期分为5个阶段，请简要概述（P6）**\\n\\n   1. 启动。项目获得授权正式被**立项，并成立项目组**，宣告项目开始。启动是一种认可过程，用来正式认可一个新项目或新阶段的存在。\\n   2. 计划。**明确项目范围**，定义和评估项目目标，选择实现项目目标的最佳策略，**制订项目计划。**\\n   3. 执行。调动资源，**完成项目管理计划中确定的工作**。\\n   4. 控制。**监控和评估项目偏差**，必要时采取纠正行动，以**保证项目计划的执行**，**实现项目目标**。\\n   5. 结束。**完成项目验收**，使其按程序结束。\\n\\n2. **简述 WBS 制定的原则。**\\n\\n   1. 某项具体的任务应该在一个工作包且只能在一个工作包中出现\\n   2. WBS中某项任务的内容是其下所有WBS项的总和\\n   3. 一个工作包只能由一个人负责\\n   4. 任务的分解，尽量与实际执行方式保持一致。\\n   5. 分解合理，具有良好的稳定性和适应性\\n   6. 鼓励项目团队成员积极参与创建WBS\\n   7. 所有成果需要文档化\\n\\n3.  **什么是质量管理，软件质量管理的保证组织有哪些?** \\n\\n   质量管理是指：确定质量方针、目标和职责并在质量体系中通过质量计划、质量控制、质量保证和质量改进使其实施的全部管理职能的所有活动。\\n\\n   1、采用技术手段和工具；2、组织正式技术平时；3、加强软件测试；4、推行软件工程规范（标准）；5、对软件的变更进行控制；6对软件质量进行度量。\\n\\n4. **简述应对风险的基本措施?**\\n\\n   1. 规避。通过变更项目计划消除风险或风险的触发条件，使目标免受影响。\\n   2. 转移。不能消除风险，而是将项目风险的结果连同应对的权利转移给第三方。\\n   3. 弱化。将风险时间的概率或结果降低到一个可以接受的程度，其中降低发生的概率更为有效。\\n   4. 接受。不改变项目计划，而考虑发生后如何应对\\n\\n5. **风险监控的措施有哪些?**\\n\\n   1. 风险识别\\n   2. 风险估计 \\n   3. 风险管理策略 \\n   4. 风险解决 \\n   5. 风险监控\\n\\n6. **如何确保知识经验共享?**\\n\\n   1. 企业角度\\n\\n      要先提倡和强调重要性。\\n\\n      其次要确立正确而鼓舞人心的知识管理愿景和战略目标。\\n\\n      再次要建立指导监督团队来提供足够的推动力。\\n\\n      激励知识共享的贡献者。\\n\\n   2. 个人角度\\n\\n      做到无私奉献，无偿分享。\\n\\n      积极参与知识的分享和讨论，在讨论中不断学习、相互提高，真正实现从知识到能力的跨越。\\n\\n7. 什么是绩效管理？如何做好绩效管理？\\n\\n   所谓绩效管理就是企业为了持续发展及保持良好的发展趋势，为了提高业绩与效率，制定一定的激励方式，让员工可以按时完成任务，整体提高员工工作积极性和提高企业产能。\\n\\n    1、绩效管理准备工作\\n\\n    2、明确绩效分工流程\\n\\n   3、做好绩效管理方案\\n\\n   4、绩效管理的反馈\\n\\n   5、绩效管理的改进\\n\\n   6、绩效管理的维护及存档\\n\\n8. 如何在项目监控阶段，区分缺陷的优先级和重要性？\\n\\n​\\t\\t\\t1. 缺陷跟踪\\n\\n​\\t\\t\\t2. 技术检查\\n\\n​\\t\\t\\t3. 源代码追踪\\n\\n​\\t\\t\\t4. 测试\\n\\n9. 简述项目验收的内容\\n\\n​\\t\\t\\t1. 软件系统验收\\n\\n​\\t\\t\\t2. 质量验收\\n\\n​\\t\\t\\t3. 资料验收\\n\\n10. 在进行项目总结时，应该注意哪些问题？\\n\\n​\\t\\t\\t1. 项目概况，质量结果分析；\\n\\n​\\t\\t\\t2. 项目进展情况；\\n\\n​\\t\\t\\t3. 好的经验；\\n\\n​\\t\\t\\t4. 不足之处；\\n\\n​\\t\\t\\t5. 改进方案和建议。\\n\\n# 5 计算器\\n\\n一、一个软件企业现在面对两个项目的选择\\n\\n一个软件企业现在面对两个项目的选择。他们经过分析得得出这样的结论:如果做项目A，盈利的概率是20%，可以盈利30万元，但是同时亏损的概既率是80%，亏损4万元;如果做项目B.盈利的概率是70%，盈利6万元，但同时有两种亏损的可能，其一是10%的概率亏损2万，其二是20%的概率亏损5万。请用决策树的方法计计算出两个项目的预期收益，并判断哪个项目是比较有利的选择。\\n\\n（1）：该企业两个项目的决策树如下：\\n\\n![image-20221101235338174](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%80%83%E8%AF%95/image-20221101235338174-d92.png)\\n\\n---\\n\\n一、阅读以下说明，回答问题1至问题3。\\n\\n某信息系统集成企业承担了甲方的信息系统集成项目，在项目的采购过程中，某项采购合同是在甲方的授意下签订的，然而在项目进展过程中，项目经理发现该采购产品高于市场价格，而且有些性能指标也没有能够完全满足合同规定要求。当项目经理发现此类问题进行调查时，发现该供应商的资质和声誉都存在问题，并且就在不久前已经被其他公司并购，最麻烦的是合同的付款条件是提前支付相关款项，合同的大部分采购款已经支付。\\n\\n在项目的中期验收中，甲方发现了部分采购产品存在的问题，并要求项目组进行返工和更换相关产品。项目经理则以采购供应商是由甲方推荐为由，拒绝进行返工和更换。而甲方则认为，项目合同里面并没有规定由甲方承担采购责任，甲方只是为项目组推荐了部分供应商，而供应商已被收购，原先的公司已经不存在，原先的责任人已经离职为由，拒绝根据合同相关条款更换产品，项目经理对此束手无策。项目经理和甲方就该问题相持不下，项目处于停滞状态。\\n\\n1. 问题1结合案例，请指出项目组在采购合同管理中存在什么问题?\\n\\n   1. **合同签订有问题，不应轻易采用甲方的推荐。**\\n   2. **合同支付条款不合理。**\\n   3. **合同执行有问题，设备指标不满足要求时，未能及时有效的管控。**\\n   4. **合同变更问题，供应商被并购以后，合同没有及时变更相应条款。**\\n\\n2. 问题2在采购合同中，支付方式的规定一般包括哪些方面的内容?甲方的做法是否妥当，是分散否该为此承担主要责任?\\n\\n   1. **支付方式的内容**\\n   2. **支付货款的条件**\\n   3. **结算支付的时限、方式**\\n   4. **拒付货款。发包方有权部分或全部拒付货款**\\n   5. **甲方的做法不妥当。不应该承担主要责任。**\\n\\n3. 问题3供应商是否可以以公司变更、负责人离职为由，拒绝履行公司变更前签订的协议?为什么?对此而日经那该加何外开?\\n\\n   **不可以。因为供应商公司变更不影响其对已经售出的货物的质量保证义务，新公司需要继续履行原供应商签订的协议。项目经理可以启动索赔程序。先进行调解，调解不成，由经济合同仲裁委员会进行调解或仲裁。**\\n\\n---\\n\\n二、在项目的中期验收中，甲方发现了部分采购产品存在的问题，并要求项目组选行返工和更换相关产 品。项目经理则以采购供应商是由甲方推荐为由，拒绝送行返工和更换。而甲方则认为，项目合同里 面并没有规定由甲方系担采购责任，甲方只是为项目组推荐了部分供应商，而供应南己枝收购，原先 的公司己经不存在，原先的责任人已经高职为由，拒绝根据合同相关条款更换产品，项目经理对此束 手无策。项目经理和甲方就该问题相持不下，项目处手停滞状态。 \\n\\n问题 1 结合案例，请指出项目组在采购合同管理中存在什么问题？ \\n\\n**1）合同签订有问题，不应经易采用甲方的推荐。2）合同支付条款不合理。3）合同执行有问题，设备 指标不满足要求时，未能及时有放的管拉。4）合同支更问题，供应商被并购以后，合同没有及时变更 相应条款。** \\n\\n问题 2 在采购合同中，交付方式的规定一般包括哪些方面的内容？甲方的做法是否妥当，是否该为比 承担主要贡任？ \\n\\n**支付方式的内容：1）支付货款的条件：2）结算支付的时限、方式：3）拒付货款。发包方存权部分或 全部柜付货款。4）平方的做法不妥当，不应该承担主要责任。**\\n\\n问题 3 供应商是否可以以公司变更、众责人离职为由，拒绝履行公司变更前签订的协议？为什么？对 此项目经理该如何处理？ \\n\\n**不可以。因为供应商公司变更不影响其对己经售出的货物的质量保证义务，新公司需要继续履行原供 应商签订的协议。 项目经理可以启动索赔程序。先进行调解，阔解不成，由经济合同仲教委员会选行调解或仲裁。**\\n\\n---\\n\\n三、软件项目需求变更\\n\\n1. 提出变更\\n2. 评估变更\\n3. 决策变更\\n4. 实施变更\\n5. 验证变更\\n\\n---\\n\\n四、阅读以下说明，回答问题1至问题 3。\\n\\n某创业型公司乙在2015年1月，凭借着报价低的优势中标承接了一个信息系统工程项目。项目建设内容主要包括建设方甲公司的北京总公司ERP信息系统建设，以及甲公司成都分公司的机房改造项目。甲乙两公司协商签订了工程额为100万元的总价合同，工期为一年。乙公司指派有过ERP项目经验的张工承担项目经理，因公司还处于创业期间，所以公司管理层非常注重成本的控制，要求项目经理严格控制成本，每周汇报项目的实际花费。为了满足\\n\\n低成本的要求，考虑到北京、成都两地的材料、差旅费用等问题，在征得甲公司与管理层的同意后，张工将机房改造工程外包给成都当地的丙公司，并在合同中要求丙公司必须在2015年底之前完工。\\n\\n项目执行期间。张工指派了一名成本控制专员，负责每周统计该项目ERP 部分所发生的费用。同时向管理层提交费用统计报告。项目进展到6月份。项目 ERP 部分实际发生的总费用为30 万元。成都赶上了梅雨季节，丙公司反馈因机房处于某大厦的低层，太潮湿，机房改造工程被迫暂停。待梅雨季节过后继续施工。\\n\\n项目执行到2015年底，机房改造项目已确定无法在2016年1月如期完工，ERP部分虽然基本到了后期的测试阶段，但其总费用也已经达到了 60 万元。\\n\\n问题1根据案例，2016年1月机房改造工程无法如期完工，请指出乙公司是否可以向丙公司索赔?如可以，请说明可以申请什么索赔?如不可以，请说明理由。\\n\\n**可以索赔。可以申请延长工期索赔。 (机房改造属于室内施工，雨季不是进度延期的不可抗因素)**\\n\\n问题2结合以上案例，请帮助张工提出成本管理及成本控制方面的改进措施。\\n\\n**1.根据项目实际情况，制定成本管理计划，并得到公司高层批准。2、采用科学方法对项目进行成本估算和预算。 3、按计划掌握项目实际成本支出情况(包括北京、成都两地)。4将实际成本与成本计划进行比较，掌握项目成本绩效。 5、如果实际成本不符合计划，则进行偏差分析，制定相关纠偏措施。 6、做好相关文档的记录和存档。**\\n\\n问题 3结合以上案例，在项目后期，请帮助项目经理张工提出一些可以弥补工期耽误的方法。\\n\\n**1.要求丙方采取措施进行赶工。 2.对丙方工程进度严格控制。3.与甲方进行沟通，必要时，修改进度计划。**\\n\\n---\\n\\n五、已知某信息工程项目由A到G7个活动组成，项目根据项目目标特别施工期要求，经过分析、定义及评审，给出了该项目的活动历时。活动资源及活动逻辑关系如下表所示:\\n\\nA:需求分析 10 2\\n\\nB:软件设计 10 2 A\\n\\nC:测试案例编写 12 3 A\\n\\nD:编程实现 15 4 B\\n\\nE:软件测试 15 3 C、D\\n\\nF:编写用户手册 5 1 A\\n\\nG:调试软件系统 3 2 E\\n\\n问题 1:绘制该项目活动的前导网络图问题\\n\\n问题2:指出该项目的关键路径和工期问题\\n\\n问题3:指出其他路径的项目缓冲期\\n\\n问题4:为了配合甲方公司成立庆典，甲方要求该项目提前10天完工，并同意支付额外费用。承建单位经过论证，同意了甲方要求并按规范执行了审批流程。为了保质保量按期完工，\\n\\n![image-20221102005159821](https://figurebed-1311634249.cos.ap-beijing.myqcloud.com/2022/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8A%80%E6%9C%AF/%E8%BF%9E%E8%BD%BD/assets/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%80%83%E8%AF%95/image-20221102005159821-33a.png)\\n\\n---\\n\\n六、\\n\\n项目经理小王目前正在负责—个小型的软件开发项目。—开始他觉得项目比较小，变更应该不多，流程也不需要太复杂，因此就没有制定项目变更管理计划，而是强调团队成员间的及时沟通来保证项目按照计划进行：根据项目经理小王的理解．所谓变更管理的主要目标就是<u>保证项目能够按照计划进行</u>，如果能够保证不发生超越项目进度计划、成本计划等控制范围外的偏差，就可以<u>不用指定项目变更管理计划</u>．就可以不用指定项目变更管理计划，以减少项目的工作量。而项目执行过程中对计划的微调根本<u>不需要记录和管理</u>，也<u>不需要走项目变更管理流程</u>。而且他认为如果所有<u>项目变更都必简要向相关领导请示汇报</u>，过程太复杂和麻烦，还不如由执行人员提出变更的方案，彼此讨论—直后来的更方便和快捷。\\n\\n但是在项目进入集成测试阶段的时候，突然多了很多莫名其妙的问题出现。如在调试过程中。由于相关设计和记录的简化和不规范，造成了调试的困难，很难定位各个问题模块的错误；由于项目执行过程中。人员的调配替换，造成了文档记录的不—敢，导致后期人员阅读和理解方面的障碍。并且由于缺乏对开发过程的配置管理和控制，导致版本混乱，很难形成有效支持各模块集成的文档。另外，面目中很多细小的改动由于没有准确的记录，或者是根本没有记录．导致集成测试发现问题时，根本没有办法更改。小王对此也没有办法，不知道因为什么原因导致目前的项目状态，项目面临返工的危险。\\n\\n【问题1】结合案例。请说项目经理小王对项目变更管理的认识哪些星正确的？哪些是不正确的?\\n\\n**1、小王对项目变更管理的认识正确的是：**\\n\\n**（1）变更管理的目的是保证项目按计划进行；**\\n\\n**（2）项目变更需要获得相关干系人认可，讨论一致。**\\n\\n**（每项1分，共2分）**\\n\\n**2、小王对项目变更管理认识不正确的是：**\\n\\n**（1）不用制定项目变更管理计划；**\\n\\n**（2）对计划的微调根本不需要记录和管理；**\\n\\n**（3）不需要走变更管理流程。**\\n\\n【问题2】根据你的理解，请说明项目变更管理在软件项目管理中的主要活动内容\\n\\n**变更管理在软件项目管理中的主要活动内容**\\n\\n**(1)识别可能发生的变更。**\\n\\n**(2)管理每个已识别的变更。**\\n\\n**(3)维持所有基线的完整性。**\\n\\n**(4)根据已批准的变更，更新范围、成本、预算、进度和质量要求，协调整体项目内的变更。**\\n\\n**(5)基于质量报告，控制项目质量使其符合标准。**\\n\\n**(6)维护一个及时、精确的关于项目产品及其相关文档的信息库，直至项目结束。**\\n\\n【问题3】针对项目的当前状态，小王应该采取说明补救措施？\\n\\n**1、补一个变更管理计划；**\\n\\n**2、建立变更管理的流程；**\\n\\n**3、建立变更管理委员会；**\\n\\n**4、加强配置管理；**\\n\\n**5、加强版本管控；**\\n\\n**6、加强变更管理，有变更走流程。**\\n\",\"articleCover\":\"http://figurebed-1311634249.cos.ap-beijing.myqcloud.com/articles/9cdd0d0402007823150b1db80244cf0c.jpg\",\"articleTitle\":\"软件项目管理\",\"categoryName\":\"学习和技术总结\",\"id\":75,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'lxuan', '111.53.209.103', '山西省太原市 移动', '2022-11-02 12:12:06', NULL);

-- ----------------------------
-- Table structure for tb_page
-- ----------------------------
DROP TABLE IF EXISTS `tb_page`;
CREATE TABLE `tb_page`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '页面id',
  `page_name` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '页面名',
  `page_label` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '页面标签',
  `page_cover` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '页面封面',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 905 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '页面' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_page
-- ----------------------------
INSERT INTO `tb_page` VALUES (1, '首页', 'home', 'https://figurebed-1311634249.file.myqcloud.com/2022/E/我的/壁纸/微信图片_20220528204052-704.png', '2021-08-07 10:32:36', '2022-04-30 15:59:30');
INSERT INTO `tb_page` VALUES (2, '归档', 'archive', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/01b23013b53294818d6cc0a569decc2e.jpg', '2021-08-07 10:32:36', '2022-05-31 23:31:02');
INSERT INTO `tb_page` VALUES (3, '分类', 'category', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/6d8a383af6be677d0714e0609edec9cf.jpg', '2021-08-07 10:32:36', '2022-05-31 23:32:41');
INSERT INTO `tb_page` VALUES (4, '标签', 'tag', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/57e41d1e62844fe5531ae2d257e4557c.jpg', '2021-08-07 10:32:36', '2022-05-31 23:34:44');
INSERT INTO `tb_page` VALUES (5, '相册', 'album', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/9cadfbea1257d74061e5703bba9c2d4d.jpg', '2021-08-07 10:32:36', '2022-05-31 23:39:15');
INSERT INTO `tb_page` VALUES (6, '友链', 'link', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/9320e8374a24bdd803f2033b2b632897.png', '2021-08-07 10:32:36', '2022-05-31 23:42:48');
INSERT INTO `tb_page` VALUES (7, '关于', 'about', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/36803b7104780e774571d39723b48697.jpg', '2021-08-07 10:32:36', '2022-05-31 23:52:10');
INSERT INTO `tb_page` VALUES (8, '留言', 'message', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0104f602f28efd133433541d133200cf.jpg', '2021-08-07 10:32:36', '2022-05-31 23:53:09');
INSERT INTO `tb_page` VALUES (9, '个人中心', 'user', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/ea13ebd2a81b9064fb05fe7556dc3325.jpg', '2021-08-07 10:32:36', '2022-06-01 00:02:32');
INSERT INTO `tb_page` VALUES (10, '文章列表', 'articleList', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/319f9c19b813df3b58614bafb7ccca8d.jpg', '2021-08-10 15:36:19', '2022-06-01 00:01:50');
INSERT INTO `tb_page` VALUES (904, '说说', 'talk', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/7cae82bdcd6aa2baae8eda5655f0b75c.jpg', '2022-01-23 00:51:24', '2022-05-31 23:49:37');

-- ----------------------------
-- Table structure for tb_photo
-- ----------------------------
DROP TABLE IF EXISTS `tb_photo`;
CREATE TABLE `tb_photo`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `album_id` int NOT NULL COMMENT '相册id',
  `photo_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '照片名',
  `photo_desc` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '照片描述',
  `photo_src` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '照片地址',
  `is_delete` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否删除',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 37 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '照片' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_photo
-- ----------------------------

-- ----------------------------
-- Table structure for tb_photo_album
-- ----------------------------
DROP TABLE IF EXISTS `tb_photo_album`;
CREATE TABLE `tb_photo_album`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `album_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '相册名',
  `album_desc` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '相册描述',
  `album_cover` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '相册封面',
  `is_delete` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否删除',
  `status` tinyint(1) NOT NULL DEFAULT 1 COMMENT '状态值 1公开 2私密',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 12 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '相册' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_photo_album
-- ----------------------------

-- ----------------------------
-- Table structure for tb_resource
-- ----------------------------
DROP TABLE IF EXISTS `tb_resource`;
CREATE TABLE `tb_resource`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `resource_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '资源名',
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '权限路径',
  `request_method` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '请求方式',
  `parent_id` int NULL DEFAULT NULL COMMENT '父权限id',
  `is_anonymous` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否匿名访问 0否 1是',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 288 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_resource
-- ----------------------------
INSERT INTO `tb_resource` VALUES (165, '分类模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `tb_resource` VALUES (166, '博客信息模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `tb_resource` VALUES (167, '友链模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `tb_resource` VALUES (168, '文章模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `tb_resource` VALUES (169, '日志模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `tb_resource` VALUES (170, '标签模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `tb_resource` VALUES (171, '照片模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `tb_resource` VALUES (172, '用户信息模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `tb_resource` VALUES (173, '用户账号模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `tb_resource` VALUES (174, '留言模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `tb_resource` VALUES (175, '相册模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `tb_resource` VALUES (176, '菜单模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `tb_resource` VALUES (177, '角色模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `tb_resource` VALUES (178, '评论模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `tb_resource` VALUES (179, '资源模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `tb_resource` VALUES (180, '页面模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `tb_resource` VALUES (181, '查看博客信息', '/', 'GET', 166, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:29');
INSERT INTO `tb_resource` VALUES (182, '查看关于我信息', '/about', 'GET', 166, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:29');
INSERT INTO `tb_resource` VALUES (183, '查看后台信息', '/admin', 'GET', 166, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (184, '修改关于我信息', '/admin/about', 'PUT', 166, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (185, '查看后台文章', '/admin/articles', 'GET', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (186, '添加或修改文章', '/admin/articles', 'POST', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (187, '恢复或删除文章', '/admin/articles', 'PUT', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (188, '物理删除文章', '/admin/articles', 'DELETE', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (189, '上传文章图片', '/admin/articles/images', 'POST', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (190, '修改文章置顶', '/admin/articles/top', 'PUT', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (191, '根据id查看后台文章', '/admin/articles/*', 'GET', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (192, '查看后台分类列表', '/admin/categories', 'GET', 165, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (193, '添加或修改分类', '/admin/categories', 'POST', 165, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (194, '删除分类', '/admin/categories', 'DELETE', 165, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (195, '搜索文章分类', '/admin/categories/search', 'GET', 165, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (196, '查询后台评论', '/admin/comments', 'GET', 178, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (197, '删除评论', '/admin/comments', 'DELETE', 178, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (198, '审核评论', '/admin/comments/review', 'PUT', 178, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (199, '查看后台友链列表', '/admin/links', 'GET', 167, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (200, '保存或修改友链', '/admin/links', 'POST', 167, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (201, '删除友链', '/admin/links', 'DELETE', 167, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (202, '查看菜单列表', '/admin/menus', 'GET', 176, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (203, '新增或修改菜单', '/admin/menus', 'POST', 176, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (204, '删除菜单', '/admin/menus/*', 'DELETE', 176, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (205, '查看后台留言列表', '/admin/messages', 'GET', 174, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (206, '删除留言', '/admin/messages', 'DELETE', 174, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (207, '审核留言', '/admin/messages/review', 'PUT', 174, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (208, '查看操作日志', '/admin/operation/logs', 'GET', 169, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (209, '删除操作日志', '/admin/operation/logs', 'DELETE', 169, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (210, '获取页面列表', '/admin/pages', 'GET', 180, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (211, '保存或更新页面', '/admin/pages', 'POST', 180, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (212, '删除页面', '/admin/pages/*', 'DELETE', 180, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (213, '根据相册id获取照片列表', '/admin/photos', 'GET', 171, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (214, '保存照片', '/admin/photos', 'POST', 171, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (215, '更新照片信息', '/admin/photos', 'PUT', 171, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (216, '删除照片', '/admin/photos', 'DELETE', 171, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (217, '移动照片相册', '/admin/photos/album', 'PUT', 171, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (218, '查看后台相册列表', '/admin/photos/albums', 'GET', 175, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (219, '保存或更新相册', '/admin/photos/albums', 'POST', 175, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (220, '上传相册封面', '/admin/photos/albums/cover', 'POST', 175, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (221, '获取后台相册列表信息', '/admin/photos/albums/info', 'GET', 175, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (222, '根据id删除相册', '/admin/photos/albums/*', 'DELETE', 175, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (223, '根据id获取后台相册信息', '/admin/photos/albums/*/info', 'GET', 175, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (224, '更新照片删除状态', '/admin/photos/delete', 'PUT', 171, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (225, '查看资源列表', '/admin/resources', 'GET', 179, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (226, '新增或修改资源', '/admin/resources', 'POST', 179, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (227, '导入swagger接口', '/admin/resources/import/swagger', 'GET', 179, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (228, '删除资源', '/admin/resources/*', 'DELETE', 179, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (229, '保存或更新角色', '/admin/role', 'POST', 177, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (230, '查看角色菜单选项', '/admin/role/menus', 'GET', 176, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (231, '查看角色资源选项', '/admin/role/resources', 'GET', 179, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (232, '查询角色列表', '/admin/roles', 'GET', 177, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (233, '删除角色', '/admin/roles', 'DELETE', 177, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (234, '查询后台标签列表', '/admin/tags', 'GET', 170, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (235, '添加或修改标签', '/admin/tags', 'POST', 170, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (236, '删除标签', '/admin/tags', 'DELETE', 170, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (237, '搜索文章标签', '/admin/tags/search', 'GET', 170, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (238, '查看当前用户菜单', '/admin/user/menus', 'GET', 176, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (239, '查询后台用户列表', '/admin/users', 'GET', 173, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (240, '修改用户禁用状态', '/admin/users/disable', 'PUT', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (241, '查看在线用户', '/admin/users/online', 'GET', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (242, '修改管理员密码', '/admin/users/password', 'PUT', 173, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (243, '查询用户角色选项', '/admin/users/role', 'GET', 177, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (244, '修改用户角色', '/admin/users/role', 'PUT', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (245, '下线用户', '/admin/users/*/online', 'DELETE', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (246, '获取网站配置', '/admin/website/config', 'GET', 166, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (247, '更新网站配置', '/admin/website/config', 'PUT', 166, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (248, '根据相册id查看照片列表', '/albums/*/photos', 'GET', 171, 1, '2021-08-11 21:04:22', '2021-08-11 21:06:35');
INSERT INTO `tb_resource` VALUES (249, '查看首页文章', '/articles', 'GET', 168, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:45');
INSERT INTO `tb_resource` VALUES (250, '查看文章归档', '/articles/archives', 'GET', 168, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:47');
INSERT INTO `tb_resource` VALUES (251, '根据条件查询文章', '/articles/condition', 'GET', 168, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:47');
INSERT INTO `tb_resource` VALUES (252, '搜索文章', '/articles/search', 'GET', 168, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:48');
INSERT INTO `tb_resource` VALUES (253, '根据id查看文章', '/articles/*', 'GET', 168, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:49');
INSERT INTO `tb_resource` VALUES (254, '点赞文章', '/articles/*/like', 'POST', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (255, '查看分类列表', '/categories', 'GET', 165, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:26');
INSERT INTO `tb_resource` VALUES (256, '查询评论', '/comments', 'GET', 178, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:33');
INSERT INTO `tb_resource` VALUES (257, '添加评论', '/comments', 'POST', 178, 0, '2021-08-11 21:04:22', '2021-08-11 21:10:05');
INSERT INTO `tb_resource` VALUES (258, '评论点赞', '/comments/*/like', 'POST', 178, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (259, '查询评论下的回复', '/comments/*/replies', 'GET', 178, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:30');
INSERT INTO `tb_resource` VALUES (260, '查看友链列表', '/links', 'GET', 167, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:41');
INSERT INTO `tb_resource` VALUES (261, '查看留言列表', '/messages', 'GET', 174, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:14');
INSERT INTO `tb_resource` VALUES (262, '添加留言', '/messages', 'POST', 174, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:15');
INSERT INTO `tb_resource` VALUES (263, '获取相册列表', '/photos/albums', 'GET', 175, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:20');
INSERT INTO `tb_resource` VALUES (264, '用户注册', '/register', 'POST', 173, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:01');
INSERT INTO `tb_resource` VALUES (265, '查询标签列表', '/tags', 'GET', 170, 1, '2021-08-11 21:04:22', '2021-08-11 21:06:30');
INSERT INTO `tb_resource` VALUES (267, '更新用户头像', '/users/avatar', 'POST', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (268, '发送邮箱验证码', '/users/code', 'GET', 173, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:02');
INSERT INTO `tb_resource` VALUES (269, '绑定用户邮箱', '/users/email', 'POST', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (270, '更新用户信息', '/users/info', 'PUT', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `tb_resource` VALUES (271, 'qq登录', '/users/oauth/qq', 'POST', 173, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:06');
INSERT INTO `tb_resource` VALUES (272, '微博登录', '/users/oauth/weibo', 'POST', 173, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:06');
INSERT INTO `tb_resource` VALUES (273, '修改密码', '/users/password', 'PUT', 173, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:09');
INSERT INTO `tb_resource` VALUES (274, '上传语音', '/voice', 'POST', 166, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:33');
INSERT INTO `tb_resource` VALUES (275, '上传访客信息', '/report', 'POST', 166, 1, '2021-08-24 00:32:05', '2021-08-24 00:32:07');
INSERT INTO `tb_resource` VALUES (276, '获取用户区域分布', '/admin/users/area', 'GET', 173, 0, '2021-08-24 00:32:35', '2021-09-24 16:25:34');
INSERT INTO `tb_resource` VALUES (278, '说说模块', NULL, NULL, NULL, 0, '2022-01-24 01:29:13', NULL);
INSERT INTO `tb_resource` VALUES (279, '查看首页说说', '/home/talks', 'GET', 278, 1, '2022-01-24 01:29:29', '2022-01-24 01:31:56');
INSERT INTO `tb_resource` VALUES (280, '查看说说列表', '/talks', 'GET', 278, 1, '2022-01-24 01:29:52', '2022-01-24 01:31:56');
INSERT INTO `tb_resource` VALUES (281, '根据id查看说说', '/talks/*', 'GET', 278, 1, '2022-01-24 01:30:10', '2022-01-24 01:31:57');
INSERT INTO `tb_resource` VALUES (282, '点赞说说', '/talks/*/like', 'POST', 278, 0, '2022-01-24 01:30:30', NULL);
INSERT INTO `tb_resource` VALUES (283, '上传说说图片', '/admin/talks/images', 'POST', 278, 0, '2022-01-24 01:30:46', NULL);
INSERT INTO `tb_resource` VALUES (284, '保存或修改说说', '/admin/talks', 'POST', 278, 0, '2022-01-24 01:31:04', NULL);
INSERT INTO `tb_resource` VALUES (285, '删除说说', '/admin/talks', 'DELETE', 278, 0, '2022-01-24 01:31:22', NULL);
INSERT INTO `tb_resource` VALUES (286, '查看后台说说', '/admin/talks', 'GET', 278, 0, '2022-01-24 01:31:38', NULL);
INSERT INTO `tb_resource` VALUES (287, '根据id查看后台说说', '/admin/talks/*', 'GET', 278, 0, '2022-01-24 01:31:53', '2022-01-24 01:33:14');

-- ----------------------------
-- Table structure for tb_role
-- ----------------------------
DROP TABLE IF EXISTS `tb_role`;
CREATE TABLE `tb_role`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `role_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '角色名',
  `role_label` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '角色描述',
  `is_disable` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否禁用  0否 1是',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_role
-- ----------------------------
INSERT INTO `tb_role` VALUES (1, '管理员', 'admin', 0, '2021-03-22 14:10:21', '2022-01-24 01:32:26');
INSERT INTO `tb_role` VALUES (2, '用户', 'user', 0, '2021-03-22 14:25:25', '2022-01-24 01:32:21');
INSERT INTO `tb_role` VALUES (3, '测试', 'test', 0, '2021-03-22 14:42:23', '2022-01-24 01:32:59');

-- ----------------------------
-- Table structure for tb_role_menu
-- ----------------------------
DROP TABLE IF EXISTS `tb_role_menu`;
CREATE TABLE `tb_role_menu`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `role_id` int NULL DEFAULT NULL COMMENT '角色id',
  `menu_id` int NULL DEFAULT NULL COMMENT '菜单id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2527 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_role_menu
-- ----------------------------
INSERT INTO `tb_role_menu` VALUES (1397, 8, 1);
INSERT INTO `tb_role_menu` VALUES (1398, 8, 2);
INSERT INTO `tb_role_menu` VALUES (1399, 8, 6);
INSERT INTO `tb_role_menu` VALUES (1400, 8, 7);
INSERT INTO `tb_role_menu` VALUES (1401, 8, 8);
INSERT INTO `tb_role_menu` VALUES (1402, 8, 9);
INSERT INTO `tb_role_menu` VALUES (1403, 8, 10);
INSERT INTO `tb_role_menu` VALUES (1404, 8, 3);
INSERT INTO `tb_role_menu` VALUES (1405, 8, 11);
INSERT INTO `tb_role_menu` VALUES (1406, 8, 12);
INSERT INTO `tb_role_menu` VALUES (1407, 8, 202);
INSERT INTO `tb_role_menu` VALUES (1408, 8, 13);
INSERT INTO `tb_role_menu` VALUES (1409, 8, 14);
INSERT INTO `tb_role_menu` VALUES (1410, 8, 201);
INSERT INTO `tb_role_menu` VALUES (1411, 8, 4);
INSERT INTO `tb_role_menu` VALUES (1412, 8, 16);
INSERT INTO `tb_role_menu` VALUES (1413, 8, 15);
INSERT INTO `tb_role_menu` VALUES (1414, 8, 17);
INSERT INTO `tb_role_menu` VALUES (1415, 8, 18);
INSERT INTO `tb_role_menu` VALUES (1416, 8, 19);
INSERT INTO `tb_role_menu` VALUES (1417, 8, 20);
INSERT INTO `tb_role_menu` VALUES (1418, 8, 5);
INSERT INTO `tb_role_menu` VALUES (1595, 9, 1);
INSERT INTO `tb_role_menu` VALUES (1596, 9, 2);
INSERT INTO `tb_role_menu` VALUES (1597, 9, 6);
INSERT INTO `tb_role_menu` VALUES (1598, 9, 7);
INSERT INTO `tb_role_menu` VALUES (1599, 9, 8);
INSERT INTO `tb_role_menu` VALUES (1600, 9, 9);
INSERT INTO `tb_role_menu` VALUES (1601, 9, 10);
INSERT INTO `tb_role_menu` VALUES (1602, 9, 3);
INSERT INTO `tb_role_menu` VALUES (1603, 9, 11);
INSERT INTO `tb_role_menu` VALUES (1604, 9, 12);
INSERT INTO `tb_role_menu` VALUES (1605, 9, 202);
INSERT INTO `tb_role_menu` VALUES (1606, 9, 13);
INSERT INTO `tb_role_menu` VALUES (1607, 9, 14);
INSERT INTO `tb_role_menu` VALUES (1608, 9, 201);
INSERT INTO `tb_role_menu` VALUES (1609, 9, 4);
INSERT INTO `tb_role_menu` VALUES (1610, 9, 16);
INSERT INTO `tb_role_menu` VALUES (1611, 9, 15);
INSERT INTO `tb_role_menu` VALUES (1612, 9, 17);
INSERT INTO `tb_role_menu` VALUES (1613, 9, 18);
INSERT INTO `tb_role_menu` VALUES (1614, 9, 19);
INSERT INTO `tb_role_menu` VALUES (1615, 9, 20);
INSERT INTO `tb_role_menu` VALUES (1616, 9, 5);
INSERT INTO `tb_role_menu` VALUES (1639, 13, 2);
INSERT INTO `tb_role_menu` VALUES (1640, 13, 6);
INSERT INTO `tb_role_menu` VALUES (1641, 13, 7);
INSERT INTO `tb_role_menu` VALUES (1642, 13, 8);
INSERT INTO `tb_role_menu` VALUES (1643, 13, 9);
INSERT INTO `tb_role_menu` VALUES (1644, 13, 10);
INSERT INTO `tb_role_menu` VALUES (1645, 13, 3);
INSERT INTO `tb_role_menu` VALUES (1646, 13, 11);
INSERT INTO `tb_role_menu` VALUES (1647, 13, 12);
INSERT INTO `tb_role_menu` VALUES (2366, 14, 1);
INSERT INTO `tb_role_menu` VALUES (2367, 14, 2);
INSERT INTO `tb_role_menu` VALUES (2461, 1, 1);
INSERT INTO `tb_role_menu` VALUES (2462, 1, 2);
INSERT INTO `tb_role_menu` VALUES (2463, 1, 6);
INSERT INTO `tb_role_menu` VALUES (2464, 1, 7);
INSERT INTO `tb_role_menu` VALUES (2465, 1, 8);
INSERT INTO `tb_role_menu` VALUES (2466, 1, 9);
INSERT INTO `tb_role_menu` VALUES (2467, 1, 10);
INSERT INTO `tb_role_menu` VALUES (2468, 1, 3);
INSERT INTO `tb_role_menu` VALUES (2469, 1, 11);
INSERT INTO `tb_role_menu` VALUES (2470, 1, 12);
INSERT INTO `tb_role_menu` VALUES (2471, 1, 202);
INSERT INTO `tb_role_menu` VALUES (2472, 1, 13);
INSERT INTO `tb_role_menu` VALUES (2473, 1, 201);
INSERT INTO `tb_role_menu` VALUES (2474, 1, 213);
INSERT INTO `tb_role_menu` VALUES (2475, 1, 14);
INSERT INTO `tb_role_menu` VALUES (2476, 1, 15);
INSERT INTO `tb_role_menu` VALUES (2477, 1, 16);
INSERT INTO `tb_role_menu` VALUES (2478, 1, 4);
INSERT INTO `tb_role_menu` VALUES (2479, 1, 214);
INSERT INTO `tb_role_menu` VALUES (2480, 1, 209);
INSERT INTO `tb_role_menu` VALUES (2481, 1, 17);
INSERT INTO `tb_role_menu` VALUES (2482, 1, 18);
INSERT INTO `tb_role_menu` VALUES (2483, 1, 205);
INSERT INTO `tb_role_menu` VALUES (2484, 1, 206);
INSERT INTO `tb_role_menu` VALUES (2485, 1, 208);
INSERT INTO `tb_role_menu` VALUES (2486, 1, 210);
INSERT INTO `tb_role_menu` VALUES (2487, 1, 215);
INSERT INTO `tb_role_menu` VALUES (2488, 1, 216);
INSERT INTO `tb_role_menu` VALUES (2489, 1, 217);
INSERT INTO `tb_role_menu` VALUES (2490, 1, 218);
INSERT INTO `tb_role_menu` VALUES (2491, 1, 19);
INSERT INTO `tb_role_menu` VALUES (2492, 1, 20);
INSERT INTO `tb_role_menu` VALUES (2493, 1, 5);
INSERT INTO `tb_role_menu` VALUES (2494, 3, 1);
INSERT INTO `tb_role_menu` VALUES (2495, 3, 2);
INSERT INTO `tb_role_menu` VALUES (2496, 3, 6);
INSERT INTO `tb_role_menu` VALUES (2497, 3, 7);
INSERT INTO `tb_role_menu` VALUES (2498, 3, 8);
INSERT INTO `tb_role_menu` VALUES (2499, 3, 9);
INSERT INTO `tb_role_menu` VALUES (2500, 3, 10);
INSERT INTO `tb_role_menu` VALUES (2501, 3, 3);
INSERT INTO `tb_role_menu` VALUES (2502, 3, 11);
INSERT INTO `tb_role_menu` VALUES (2503, 3, 12);
INSERT INTO `tb_role_menu` VALUES (2504, 3, 202);
INSERT INTO `tb_role_menu` VALUES (2505, 3, 13);
INSERT INTO `tb_role_menu` VALUES (2506, 3, 201);
INSERT INTO `tb_role_menu` VALUES (2507, 3, 213);
INSERT INTO `tb_role_menu` VALUES (2508, 3, 14);
INSERT INTO `tb_role_menu` VALUES (2509, 3, 15);
INSERT INTO `tb_role_menu` VALUES (2510, 3, 16);
INSERT INTO `tb_role_menu` VALUES (2511, 3, 4);
INSERT INTO `tb_role_menu` VALUES (2512, 3, 214);
INSERT INTO `tb_role_menu` VALUES (2513, 3, 209);
INSERT INTO `tb_role_menu` VALUES (2514, 3, 17);
INSERT INTO `tb_role_menu` VALUES (2515, 3, 18);
INSERT INTO `tb_role_menu` VALUES (2516, 3, 205);
INSERT INTO `tb_role_menu` VALUES (2517, 3, 206);
INSERT INTO `tb_role_menu` VALUES (2518, 3, 208);
INSERT INTO `tb_role_menu` VALUES (2519, 3, 210);
INSERT INTO `tb_role_menu` VALUES (2520, 3, 215);
INSERT INTO `tb_role_menu` VALUES (2521, 3, 216);
INSERT INTO `tb_role_menu` VALUES (2522, 3, 217);
INSERT INTO `tb_role_menu` VALUES (2523, 3, 218);
INSERT INTO `tb_role_menu` VALUES (2524, 3, 19);
INSERT INTO `tb_role_menu` VALUES (2525, 3, 20);
INSERT INTO `tb_role_menu` VALUES (2526, 3, 5);

-- ----------------------------
-- Table structure for tb_role_resource
-- ----------------------------
DROP TABLE IF EXISTS `tb_role_resource`;
CREATE TABLE `tb_role_resource`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `role_id` int NULL DEFAULT NULL COMMENT '角色id',
  `resource_id` int NULL DEFAULT NULL COMMENT '权限id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4886 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_role_resource
-- ----------------------------
INSERT INTO `tb_role_resource` VALUES (4750, 14, 238);
INSERT INTO `tb_role_resource` VALUES (4751, 2, 254);
INSERT INTO `tb_role_resource` VALUES (4752, 2, 267);
INSERT INTO `tb_role_resource` VALUES (4753, 2, 269);
INSERT INTO `tb_role_resource` VALUES (4754, 2, 270);
INSERT INTO `tb_role_resource` VALUES (4755, 2, 257);
INSERT INTO `tb_role_resource` VALUES (4756, 2, 258);
INSERT INTO `tb_role_resource` VALUES (4757, 2, 282);
INSERT INTO `tb_role_resource` VALUES (4758, 1, 165);
INSERT INTO `tb_role_resource` VALUES (4759, 1, 192);
INSERT INTO `tb_role_resource` VALUES (4760, 1, 193);
INSERT INTO `tb_role_resource` VALUES (4761, 1, 194);
INSERT INTO `tb_role_resource` VALUES (4762, 1, 195);
INSERT INTO `tb_role_resource` VALUES (4763, 1, 166);
INSERT INTO `tb_role_resource` VALUES (4764, 1, 183);
INSERT INTO `tb_role_resource` VALUES (4765, 1, 184);
INSERT INTO `tb_role_resource` VALUES (4766, 1, 246);
INSERT INTO `tb_role_resource` VALUES (4767, 1, 247);
INSERT INTO `tb_role_resource` VALUES (4768, 1, 167);
INSERT INTO `tb_role_resource` VALUES (4769, 1, 199);
INSERT INTO `tb_role_resource` VALUES (4770, 1, 200);
INSERT INTO `tb_role_resource` VALUES (4771, 1, 201);
INSERT INTO `tb_role_resource` VALUES (4772, 1, 168);
INSERT INTO `tb_role_resource` VALUES (4773, 1, 185);
INSERT INTO `tb_role_resource` VALUES (4774, 1, 186);
INSERT INTO `tb_role_resource` VALUES (4775, 1, 187);
INSERT INTO `tb_role_resource` VALUES (4776, 1, 188);
INSERT INTO `tb_role_resource` VALUES (4777, 1, 189);
INSERT INTO `tb_role_resource` VALUES (4778, 1, 190);
INSERT INTO `tb_role_resource` VALUES (4779, 1, 191);
INSERT INTO `tb_role_resource` VALUES (4780, 1, 254);
INSERT INTO `tb_role_resource` VALUES (4781, 1, 169);
INSERT INTO `tb_role_resource` VALUES (4782, 1, 208);
INSERT INTO `tb_role_resource` VALUES (4783, 1, 209);
INSERT INTO `tb_role_resource` VALUES (4784, 1, 170);
INSERT INTO `tb_role_resource` VALUES (4785, 1, 234);
INSERT INTO `tb_role_resource` VALUES (4786, 1, 235);
INSERT INTO `tb_role_resource` VALUES (4787, 1, 236);
INSERT INTO `tb_role_resource` VALUES (4788, 1, 237);
INSERT INTO `tb_role_resource` VALUES (4789, 1, 171);
INSERT INTO `tb_role_resource` VALUES (4790, 1, 213);
INSERT INTO `tb_role_resource` VALUES (4791, 1, 214);
INSERT INTO `tb_role_resource` VALUES (4792, 1, 215);
INSERT INTO `tb_role_resource` VALUES (4793, 1, 216);
INSERT INTO `tb_role_resource` VALUES (4794, 1, 217);
INSERT INTO `tb_role_resource` VALUES (4795, 1, 224);
INSERT INTO `tb_role_resource` VALUES (4796, 1, 172);
INSERT INTO `tb_role_resource` VALUES (4797, 1, 240);
INSERT INTO `tb_role_resource` VALUES (4798, 1, 241);
INSERT INTO `tb_role_resource` VALUES (4799, 1, 244);
INSERT INTO `tb_role_resource` VALUES (4800, 1, 245);
INSERT INTO `tb_role_resource` VALUES (4801, 1, 267);
INSERT INTO `tb_role_resource` VALUES (4802, 1, 269);
INSERT INTO `tb_role_resource` VALUES (4803, 1, 270);
INSERT INTO `tb_role_resource` VALUES (4804, 1, 173);
INSERT INTO `tb_role_resource` VALUES (4805, 1, 239);
INSERT INTO `tb_role_resource` VALUES (4806, 1, 242);
INSERT INTO `tb_role_resource` VALUES (4807, 1, 276);
INSERT INTO `tb_role_resource` VALUES (4808, 1, 174);
INSERT INTO `tb_role_resource` VALUES (4809, 1, 205);
INSERT INTO `tb_role_resource` VALUES (4810, 1, 206);
INSERT INTO `tb_role_resource` VALUES (4811, 1, 207);
INSERT INTO `tb_role_resource` VALUES (4812, 1, 175);
INSERT INTO `tb_role_resource` VALUES (4813, 1, 218);
INSERT INTO `tb_role_resource` VALUES (4814, 1, 219);
INSERT INTO `tb_role_resource` VALUES (4815, 1, 220);
INSERT INTO `tb_role_resource` VALUES (4816, 1, 221);
INSERT INTO `tb_role_resource` VALUES (4817, 1, 222);
INSERT INTO `tb_role_resource` VALUES (4818, 1, 223);
INSERT INTO `tb_role_resource` VALUES (4819, 1, 176);
INSERT INTO `tb_role_resource` VALUES (4820, 1, 202);
INSERT INTO `tb_role_resource` VALUES (4821, 1, 203);
INSERT INTO `tb_role_resource` VALUES (4822, 1, 204);
INSERT INTO `tb_role_resource` VALUES (4823, 1, 230);
INSERT INTO `tb_role_resource` VALUES (4824, 1, 238);
INSERT INTO `tb_role_resource` VALUES (4825, 1, 177);
INSERT INTO `tb_role_resource` VALUES (4826, 1, 229);
INSERT INTO `tb_role_resource` VALUES (4827, 1, 232);
INSERT INTO `tb_role_resource` VALUES (4828, 1, 233);
INSERT INTO `tb_role_resource` VALUES (4829, 1, 243);
INSERT INTO `tb_role_resource` VALUES (4830, 1, 178);
INSERT INTO `tb_role_resource` VALUES (4831, 1, 196);
INSERT INTO `tb_role_resource` VALUES (4832, 1, 197);
INSERT INTO `tb_role_resource` VALUES (4833, 1, 198);
INSERT INTO `tb_role_resource` VALUES (4834, 1, 257);
INSERT INTO `tb_role_resource` VALUES (4835, 1, 258);
INSERT INTO `tb_role_resource` VALUES (4836, 1, 179);
INSERT INTO `tb_role_resource` VALUES (4837, 1, 225);
INSERT INTO `tb_role_resource` VALUES (4838, 1, 226);
INSERT INTO `tb_role_resource` VALUES (4839, 1, 227);
INSERT INTO `tb_role_resource` VALUES (4840, 1, 228);
INSERT INTO `tb_role_resource` VALUES (4841, 1, 231);
INSERT INTO `tb_role_resource` VALUES (4842, 1, 180);
INSERT INTO `tb_role_resource` VALUES (4843, 1, 210);
INSERT INTO `tb_role_resource` VALUES (4844, 1, 211);
INSERT INTO `tb_role_resource` VALUES (4845, 1, 212);
INSERT INTO `tb_role_resource` VALUES (4846, 1, 278);
INSERT INTO `tb_role_resource` VALUES (4847, 1, 282);
INSERT INTO `tb_role_resource` VALUES (4848, 1, 283);
INSERT INTO `tb_role_resource` VALUES (4849, 1, 284);
INSERT INTO `tb_role_resource` VALUES (4850, 1, 285);
INSERT INTO `tb_role_resource` VALUES (4851, 1, 286);
INSERT INTO `tb_role_resource` VALUES (4852, 1, 287);
INSERT INTO `tb_role_resource` VALUES (4853, 3, 192);
INSERT INTO `tb_role_resource` VALUES (4854, 3, 195);
INSERT INTO `tb_role_resource` VALUES (4855, 3, 183);
INSERT INTO `tb_role_resource` VALUES (4856, 3, 246);
INSERT INTO `tb_role_resource` VALUES (4857, 3, 199);
INSERT INTO `tb_role_resource` VALUES (4858, 3, 185);
INSERT INTO `tb_role_resource` VALUES (4859, 3, 191);
INSERT INTO `tb_role_resource` VALUES (4860, 3, 254);
INSERT INTO `tb_role_resource` VALUES (4861, 3, 208);
INSERT INTO `tb_role_resource` VALUES (4862, 3, 234);
INSERT INTO `tb_role_resource` VALUES (4863, 3, 237);
INSERT INTO `tb_role_resource` VALUES (4864, 3, 213);
INSERT INTO `tb_role_resource` VALUES (4865, 3, 241);
INSERT INTO `tb_role_resource` VALUES (4866, 3, 239);
INSERT INTO `tb_role_resource` VALUES (4867, 3, 276);
INSERT INTO `tb_role_resource` VALUES (4868, 3, 205);
INSERT INTO `tb_role_resource` VALUES (4869, 3, 218);
INSERT INTO `tb_role_resource` VALUES (4870, 3, 221);
INSERT INTO `tb_role_resource` VALUES (4871, 3, 223);
INSERT INTO `tb_role_resource` VALUES (4872, 3, 202);
INSERT INTO `tb_role_resource` VALUES (4873, 3, 230);
INSERT INTO `tb_role_resource` VALUES (4874, 3, 238);
INSERT INTO `tb_role_resource` VALUES (4875, 3, 232);
INSERT INTO `tb_role_resource` VALUES (4876, 3, 243);
INSERT INTO `tb_role_resource` VALUES (4877, 3, 196);
INSERT INTO `tb_role_resource` VALUES (4878, 3, 257);
INSERT INTO `tb_role_resource` VALUES (4879, 3, 258);
INSERT INTO `tb_role_resource` VALUES (4880, 3, 225);
INSERT INTO `tb_role_resource` VALUES (4881, 3, 231);
INSERT INTO `tb_role_resource` VALUES (4882, 3, 210);
INSERT INTO `tb_role_resource` VALUES (4883, 3, 282);
INSERT INTO `tb_role_resource` VALUES (4884, 3, 286);
INSERT INTO `tb_role_resource` VALUES (4885, 3, 287);

-- ----------------------------
-- Table structure for tb_tag
-- ----------------------------
DROP TABLE IF EXISTS `tb_tag`;
CREATE TABLE `tb_tag`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '标签名',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 46 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_tag
-- ----------------------------
INSERT INTO `tb_tag` VALUES (29, '测试标签', '2022-01-24 23:33:57', NULL);
INSERT INTO `tb_tag` VALUES (30, 'GitHub', '2022-04-29 22:45:47', NULL);
INSERT INTO `tb_tag` VALUES (31, '多仓库配置', '2022-04-29 22:45:47', NULL);
INSERT INTO `tb_tag` VALUES (32, 'hexo', '2022-04-30 04:15:26', NULL);
INSERT INTO `tb_tag` VALUES (33, 'icarus主题', '2022-04-30 04:15:26', NULL);
INSERT INTO `tb_tag` VALUES (34, 'gitalk评论', '2022-04-30 04:15:26', NULL);
INSERT INTO `tb_tag` VALUES (35, '图床', '2022-04-30 04:21:17', NULL);
INSERT INTO `tb_tag` VALUES (36, 'PicGO', '2022-04-30 04:21:17', NULL);
INSERT INTO `tb_tag` VALUES (37, '腾讯云', '2022-04-30 04:21:17', NULL);
INSERT INTO `tb_tag` VALUES (38, '公告', '2022-06-14 14:30:55', NULL);
INSERT INTO `tb_tag` VALUES (39, '算法', '2022-06-22 01:58:54', NULL);
INSERT INTO `tb_tag` VALUES (40, '设计模式', '2022-06-24 01:54:45', NULL);
INSERT INTO `tb_tag` VALUES (41, '课程', '2022-06-24 01:54:45', NULL);
INSERT INTO `tb_tag` VALUES (42, 'Java', '2022-06-27 15:01:01', NULL);
INSERT INTO `tb_tag` VALUES (43, '动漫', '2022-06-30 22:36:45', NULL);
INSERT INTO `tb_tag` VALUES (44, '京阿尼', '2022-06-30 22:36:45', NULL);
INSERT INTO `tb_tag` VALUES (45, '软件项目管理', '2022-11-02 01:47:44', NULL);

-- ----------------------------
-- Table structure for tb_talk
-- ----------------------------
DROP TABLE IF EXISTS `tb_talk`;
CREATE TABLE `tb_talk`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '说说id',
  `user_id` int NOT NULL COMMENT '用户id',
  `content` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '说说内容',
  `images` varchar(2500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '图片',
  `is_top` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否置顶',
  `status` tinyint(1) NOT NULL DEFAULT 1 COMMENT '状态 1.公开 2.私密',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 52 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_talk
-- ----------------------------
INSERT INTO `tb_talk` VALUES (49, 1, '测试说说<img src=\"https://static.talkxj.com/emoji/goutou.jpg\" width=\"24\" height=\"24\" alt=\"[狗头]\" style=\"margin: 0 1px;vertical-align: text-bottom\">', NULL, 0, 1, '2022-01-24 23:34:59', NULL);
INSERT INTO `tb_talk` VALUES (50, 1, '测试说说', NULL, 0, 1, '2022-04-29 12:24:14', NULL);
INSERT INTO `tb_talk` VALUES (51, 1, '热死人了，要死了要死了，混凝土白天吸饱饱的热能，晚上就开始放热了，整个宿舍像蒸笼一样。最关键的是大晚上一点风都刮不进来，空气都好沉好黏着，但凡走两步身子都虚浮地左摇右晃，他妈的，当初冬天的时候为什么会期盼夏天。', NULL, 0, 1, '2022-06-20 22:35:41', NULL);

-- ----------------------------
-- Table structure for tb_unique_view
-- ----------------------------
DROP TABLE IF EXISTS `tb_unique_view`;
CREATE TABLE `tb_unique_view`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `views_count` int NOT NULL COMMENT '访问量',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 769 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_unique_view
-- ----------------------------
INSERT INTO `tb_unique_view` VALUES (568, 6, '2022-05-31 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (569, 5, '2022-06-01 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (570, 2, '2022-06-02 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (571, 16, '2022-06-03 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (572, 13, '2022-06-04 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (573, 2, '2022-06-05 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (574, 6, '2022-06-06 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (575, 8, '2022-06-07 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (576, 5, '2022-06-08 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (577, 3, '2022-06-09 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (578, 10, '2022-06-10 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (579, 2, '2022-06-11 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (580, 1, '2022-06-12 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (581, 5, '2022-06-13 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (582, 8, '2022-06-14 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (583, 3, '2022-06-15 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (584, 2, '2022-06-16 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (585, 3, '2022-06-17 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (586, 4, '2022-06-18 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (587, 9, '2022-06-19 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (588, 7, '2022-06-20 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (589, 4, '2022-06-21 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (590, 13, '2022-06-22 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (591, 6, '2022-06-23 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (592, 16, '2022-06-24 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (593, 12, '2022-06-25 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (594, 1, '2022-06-26 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (595, 8, '2022-06-27 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (596, 0, '2022-06-28 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (597, 11, '2022-06-29 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (598, 7, '2022-06-30 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (599, 1, '2022-07-01 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (600, 0, '2022-07-02 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (601, 3, '2022-07-03 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (602, 1, '2022-07-04 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (603, 0, '2022-07-05 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (604, 2, '2022-07-06 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (605, 4, '2022-07-07 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (606, 1, '2022-07-08 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (607, 0, '2022-07-09 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (608, 3, '2022-07-10 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (609, 0, '2022-07-11 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (610, 0, '2022-07-12 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (611, 2, '2022-07-13 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (612, 0, '2022-07-14 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (613, 1, '2022-07-15 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (614, 2, '2022-07-16 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (615, 1, '2022-07-23 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (616, 17, '2022-07-24 00:00:01', NULL);
INSERT INTO `tb_unique_view` VALUES (617, 7, '2022-10-22 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (618, 7, '2022-10-23 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (619, 4, '2022-10-24 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (620, 0, '2022-10-25 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (621, 2, '2022-10-26 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (622, 0, '2022-10-27 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (623, 2, '2022-10-28 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (624, 3, '2022-10-29 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (625, 4, '2022-10-30 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (626, 1, '2022-10-31 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (627, 0, '2022-11-01 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (628, 19, '2022-11-02 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (629, 1, '2022-11-03 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (630, 0, '2022-11-04 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (631, 1, '2022-11-05 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (632, 1, '2022-11-06 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (633, 0, '2022-11-07 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (634, 0, '2022-11-08 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (635, 0, '2022-11-09 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (636, 0, '2022-11-10 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (637, 0, '2022-11-11 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (638, 5, '2022-11-12 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (639, 1, '2022-11-13 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (640, 2, '2022-11-14 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (641, 0, '2022-11-15 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (642, 0, '2022-11-16 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (643, 0, '2022-11-17 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (644, 2, '2022-11-18 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (645, 1, '2022-11-19 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (646, 3, '2022-11-20 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (647, 0, '2022-11-21 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (648, 0, '2022-11-22 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (649, 2, '2022-11-23 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (650, 0, '2022-11-24 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (651, 7, '2022-11-25 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (652, 1, '2022-11-26 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (653, 0, '2022-11-27 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (654, 0, '2022-11-28 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (655, 0, '2022-11-29 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (656, 0, '2022-11-30 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (657, 1, '2022-12-01 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (658, 3, '2022-12-02 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (659, 0, '2022-12-03 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (660, 0, '2022-12-04 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (661, 0, '2022-12-05 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (662, 1, '2022-12-06 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (663, 4, '2022-12-07 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (664, 0, '2022-12-08 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (665, 0, '2022-12-09 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (666, 2, '2022-12-10 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (667, 0, '2022-12-11 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (668, 0, '2022-12-12 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (669, 0, '2022-12-13 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (670, 0, '2022-12-14 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (671, 0, '2022-12-15 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (672, 1, '2022-12-16 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (673, 0, '2022-12-17 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (674, 1, '2022-12-18 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (675, 0, '2022-12-19 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (676, 1, '2022-12-20 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (677, 2, '2022-12-21 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (678, 0, '2022-12-22 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (679, 0, '2022-12-23 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (680, 0, '2022-12-24 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (681, 1, '2022-12-25 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (682, 0, '2022-12-26 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (683, 0, '2022-12-27 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (684, 0, '2022-12-28 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (685, 0, '2022-12-29 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (686, 2, '2022-12-30 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (687, 0, '2022-12-31 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (688, 0, '2023-01-01 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (689, 1, '2023-01-02 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (690, 1, '2023-01-03 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (691, 0, '2023-01-04 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (692, 0, '2023-01-05 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (693, 2, '2023-01-06 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (694, 1, '2023-01-07 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (695, 1, '2023-01-08 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (696, 0, '2023-01-09 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (697, 0, '2023-01-10 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (698, 2, '2023-01-11 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (699, 0, '2023-01-12 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (700, 1, '2023-01-13 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (701, 2, '2023-01-14 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (702, 2, '2023-01-15 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (703, 0, '2023-01-16 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (704, 1, '2023-01-17 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (705, 0, '2023-01-18 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (706, 0, '2023-01-19 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (707, 0, '2023-01-20 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (708, 0, '2023-01-21 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (709, 2, '2023-01-22 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (710, 0, '2023-01-23 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (711, 0, '2023-01-24 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (712, 1, '2023-01-25 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (713, 1, '2023-01-26 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (714, 2, '2023-01-27 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (715, 0, '2023-01-28 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (716, 1, '2023-01-29 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (717, 1, '2023-01-30 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (718, 2, '2023-01-31 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (719, 0, '2023-02-01 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (720, 1, '2023-02-02 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (721, 2, '2023-02-03 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (722, 1, '2023-02-04 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (723, 2, '2023-02-05 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (724, 0, '2023-02-06 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (725, 2, '2023-02-07 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (726, 0, '2023-02-08 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (727, 0, '2023-02-09 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (728, 2, '2023-02-10 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (729, 0, '2023-02-11 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (730, 0, '2023-02-12 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (731, 0, '2023-02-13 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (732, 2, '2023-02-14 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (733, 1, '2023-02-15 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (734, 0, '2023-02-16 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (735, 0, '2023-02-17 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (736, 0, '2023-02-18 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (737, 0, '2023-02-19 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (738, 1, '2023-02-20 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (739, 1, '2023-02-21 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (740, 3, '2023-02-22 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (741, 1, '2023-02-23 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (742, 2, '2023-02-24 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (743, 1, '2023-02-25 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (744, 1, '2023-02-26 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (745, 0, '2023-02-27 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (746, 1, '2023-02-28 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (747, 2, '2023-03-01 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (748, 0, '2023-03-02 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (749, 0, '2023-03-03 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (750, 1, '2023-03-04 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (751, 0, '2023-03-05 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (752, 1, '2023-03-06 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (753, 3, '2023-03-07 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (754, 1, '2023-03-08 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (755, 0, '2023-03-09 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (756, 1, '2023-03-10 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (757, 0, '2023-03-11 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (758, 0, '2023-03-12 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (759, 1, '2023-03-13 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (760, 0, '2023-03-14 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (761, 2, '2023-03-15 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (762, 1, '2023-03-16 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (763, 0, '2023-03-17 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (764, 0, '2023-03-18 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (765, 0, '2023-03-19 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (766, 6, '2023-03-20 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (767, 0, '2023-03-21 00:00:00', NULL);
INSERT INTO `tb_unique_view` VALUES (768, 0, '2023-03-22 00:00:00', NULL);

-- ----------------------------
-- Table structure for tb_user_auth
-- ----------------------------
DROP TABLE IF EXISTS `tb_user_auth`;
CREATE TABLE `tb_user_auth`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_info_id` int NOT NULL COMMENT '用户信息id',
  `username` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户名',
  `password` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '密码',
  `login_type` tinyint(1) NOT NULL COMMENT '登录类型',
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户登录ip',
  `ip_source` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'ip来源',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `last_login_time` datetime NULL DEFAULT NULL COMMENT '上次登录时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `username`(`username`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1006 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_user_auth
-- ----------------------------
INSERT INTO `tb_user_auth` VALUES (1, 1, 'admin@qq.com', '$2a$10$ZqoFIqpqnqJhGyJyVYaGdO9i82aXB19pTK99HWvcVjhMOaJSuXqcG', 1, '198.211.27.20', '美国加利福尼亚洛杉矶', '2021-08-12 15:43:18', '2023-03-20 18:25:01', '2023-03-20 18:25:01');
INSERT INTO `tb_user_auth` VALUES (995, 1005, 'xiaainy@163.com', '$2a$10$K7KQJ8mED4NKLvaNlAOx5ey4NbcU1CUDrEJnL9zCWNIvnbjrhwOnK', 1, '61.222.202.239', '台湾省', '2022-01-27 10:58:11', '2022-01-27 10:58:12', '2022-01-27 10:58:12');
INSERT INTO `tb_user_auth` VALUES (998, 1008, '1031445424@qq.com', '$2a$10$XYo4UKRqnwgQCzX29f1.xu6JNjOYMxGPSXNkLoYa5TXmz4/68RToK', 1, '111.53.209.104', '山西省太原市 移动', '2022-06-01 15:03:33', '2022-06-01 15:03:34', '2022-06-01 15:03:33');
INSERT INTO `tb_user_auth` VALUES (999, 1009, 'lxiuaunng@gmail.com', '$2a$10$AM.a2EMZli1BbfqI/aUw7.lCSAOnTRqsoGAwAo6Syu8xZbb7a7ODq', 1, '198.211.27.20', '美国加利福尼亚洛杉矶', '2022-06-08 00:10:28', '2023-03-20 19:03:11', '2023-03-20 19:03:11');
INSERT INTO `tb_user_auth` VALUES (1000, 1010, '782299@1kite.vip', '$2a$10$2YyclihgD79rUaLckbH8rOeO8a67sN8Ah8kF1eHtq2XETEqeyLVo2', 1, '111.53.209.101', '山西省太原市 移动', '2022-06-08 14:45:50', '2022-06-08 14:45:51', '2022-06-08 14:45:51');
INSERT INTO `tb_user_auth` VALUES (1001, 1011, '7280713074', '2.00CEIjwHTwreOC22ad7ac0d7S_ZCDE', 3, '111.53.209.102', '山西省太原市 移动', '2022-06-13 21:45:12', '2022-10-11 16:53:32', '2022-10-11 16:53:32');
INSERT INTO `tb_user_auth` VALUES (1002, 1012, 'B636D40036B0FCEE80560F4B39E226BD', 'A2EB865A23B7E372D22AD6139433D93F', 2, '198.211.27.20', '美国加利福尼亚洛杉矶', '2022-06-14 14:18:52', '2023-03-20 19:00:43', '2023-03-20 19:00:43');
INSERT INTO `tb_user_auth` VALUES (1003, 1013, '6C3A6DD053ABAB03FA795C587DD4B0E5', '3F9CF56A24BB934A92A42FB5E28A980A', 2, '111.53.209.100', '山西省太原市 移动', '2022-06-15 10:09:36', '2022-06-15 10:14:25', '2022-06-15 02:14:25');
INSERT INTO `tb_user_auth` VALUES (1004, 1014, '807EC5625948E71A1ECAF93752388F9C', '21F4A03E6B8D61067BE0853D47784636', 2, '120.208.43.37', '山西省长治市 移动', '2022-06-24 16:44:41', '2022-06-24 16:50:29', '2022-06-24 08:50:29');
INSERT INTO `tb_user_auth` VALUES (1005, 1015, '1274872144@qq.com', '$2a$10$xvp57gV/HdXbIM0eeO/eleVdci5ToxMfYXnq/8GHDd/.kUE06eA/O', 1, '152.69.200.243', '美国', '2022-07-24 02:55:49', '2022-07-24 02:55:50', '2022-07-24 02:55:50');

-- ----------------------------
-- Table structure for tb_user_info
-- ----------------------------
DROP TABLE IF EXISTS `tb_user_info`;
CREATE TABLE `tb_user_info`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  `email` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '邮箱号',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户昵称',
  `avatar` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT '' COMMENT '用户头像',
  `intro` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户简介',
  `web_site` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '个人网站',
  `is_disable` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否禁用',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1016 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_user_info
-- ----------------------------
INSERT INTO `tb_user_info` VALUES (1, 'admin@qq.com', 'lxuan', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/img/2022/C/Users/12748/Desktop/avatar-22c.png', 'lxuan', 'http://www.lxuan.fun/', 0, '2021-08-12 15:43:17', '2022-06-20 22:36:29');
INSERT INTO `tb_user_info` VALUES (1005, 'xiaainy@163.com', '用户1486533968342859778', 'https://static.talkxj.com/config/2cd793c8744199053323546875655f32.jpg', NULL, NULL, 0, '2022-01-27 10:58:11', NULL);
INSERT INTO `tb_user_info` VALUES (1008, '1031445424@qq.com', '用户1531894196509159425', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0b7d537a8fce1c5d0e3e4cfcabf01ca4.jpg', NULL, NULL, 0, '2022-06-01 15:03:32', NULL);
INSERT INTO `tb_user_info` VALUES (1009, 'lxiuaunng@gmail.com', '用户1534206161860505601', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0b7d537a8fce1c5d0e3e4cfcabf01ca4.jpg', NULL, NULL, 0, '2022-06-08 00:10:28', NULL);
INSERT INTO `tb_user_info` VALUES (1010, '782299@1kite.vip', '用户1534426454940004354', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0b7d537a8fce1c5d0e3e4cfcabf01ca4.jpg', NULL, NULL, 0, '2022-06-08 14:45:50', NULL);
INSERT INTO `tb_user_info` VALUES (1011, NULL, '梁谨生', 'https://tvax4.sinaimg.cn/crop.0.0.996.996.1024/007WJ842ly8gimma2z0d2j30ro0rojtu.jpg?KID=imgbed,tva&Expires=1655138711&ssig=vMCAWaoEDH', NULL, NULL, 0, '2022-06-13 21:45:12', NULL);
INSERT INTO `tb_user_info` VALUES (1012, '1274872144@qq.com', 'rm -rf /*', 'http://thirdqq.qlogo.cn/g?b=oidb&k=6Llzc8S9bKW440SgE2GFmw&s=40&t=1643967589', NULL, 'http://www.lxuan.fun', 0, '2022-06-14 14:18:51', '2023-01-06 19:59:18');
INSERT INTO `tb_user_info` VALUES (1013, '1031445424@qq.com', '残霜', 'http://thirdqq.qlogo.cn/g?b=oidb&k=qS4FbeqoYOlZZcS5gDXolA&s=40&t=1588892605', NULL, NULL, 0, '2022-06-15 10:09:36', '2022-06-15 10:12:41');
INSERT INTO `tb_user_info` VALUES (1014, NULL, '风间九尾', 'http://thirdqq.qlogo.cn/g?b=oidb&k=qSFP2D05xY2ZETukCOrdFA&s=40&t=1655033465', NULL, NULL, 0, '2022-06-24 16:44:41', NULL);
INSERT INTO `tb_user_info` VALUES (1015, '1274872144@qq.com', '用户1550917611312197633', 'https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0b7d537a8fce1c5d0e3e4cfcabf01ca4.jpg', NULL, NULL, 0, '2022-07-24 02:55:48', NULL);

-- ----------------------------
-- Table structure for tb_user_role
-- ----------------------------
DROP TABLE IF EXISTS `tb_user_role`;
CREATE TABLE `tb_user_role`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NULL DEFAULT NULL COMMENT '用户id',
  `role_id` int NULL DEFAULT NULL COMMENT '角色id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1023 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_user_role
-- ----------------------------
INSERT INTO `tb_user_role` VALUES (1002, 1005, 2);
INSERT INTO `tb_user_role` VALUES (1013, 1, 1);
INSERT INTO `tb_user_role` VALUES (1014, 1007, 2);
INSERT INTO `tb_user_role` VALUES (1015, 1008, 2);
INSERT INTO `tb_user_role` VALUES (1016, 1009, 2);
INSERT INTO `tb_user_role` VALUES (1017, 1010, 2);
INSERT INTO `tb_user_role` VALUES (1018, 1011, 2);
INSERT INTO `tb_user_role` VALUES (1019, 1012, 2);
INSERT INTO `tb_user_role` VALUES (1020, 1013, 2);
INSERT INTO `tb_user_role` VALUES (1021, 1014, 2);
INSERT INTO `tb_user_role` VALUES (1022, 1015, 2);

-- ----------------------------
-- Table structure for tb_website_config
-- ----------------------------
DROP TABLE IF EXISTS `tb_website_config`;
CREATE TABLE `tb_website_config`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `config` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '配置信息',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_website_config
-- ----------------------------
INSERT INTO `tb_website_config` VALUES (1, '{\"alipayQRCode\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0011565be60480311cfb4fdbdf1c2399.jpg\",\"gitee\":\"https://gitee.com/guaiwu111\",\"github\":\"https://hellolxuan.github.io/\",\"isChatRoom\":1,\"isCommentReview\":0,\"isEmailNotice\":1,\"isMessageReview\":0,\"isMusicPlayer\":0,\"isReward\":1,\"qq\":\"https://user.qzone.qq.com/1274872144/infocenter\",\"socialLoginList\":[\"qq\",\"weibo\"],\"socialUrlList\":[\"qq\",\"github\",\"gitee\"],\"touristAvatar\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png\",\"userAvatar\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0b7d537a8fce1c5d0e3e4cfcabf01ca4.jpg\",\"websiteAuthor\":\"苏谨生\",\"websiteAvatar\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/0aa9385d6335ebeb7affe5ee7ea54dfb.png\",\"websiteCreateTime\":\"2022-04-30\",\"websiteIntro\":\"此博客基于风、宇大佬的博客模板，暂时用于学习前后端开发和部署。\",\"websiteName\":\"苏谨生的博客\",\"websiteNotice\":\"2022/7/24 \",\"websiteRecordNo\":\"\",\"websocketUrl\":\"ws://www.ws.lxuan.fun\",\"weiXinQRCode\":\"https://lxuanblog.oss-cn-beijing.aliyuncs.com/config/79bbc2cae5e175a5a7e959e7c2a3a696.jpg\"}', '2021-08-09 19:37:30', '2023-03-20 19:00:25');

SET FOREIGN_KEY_CHECKS = 1;
